[{"Owner":"brianzinn","Date":"2018-02-23T19:53:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tBasic support for Google Daydream controller PR was merged into BabylonJS_co_ so should be in alpha11.  Adding Daydream was more enjoyable and super easy compared to Gear VR.  Sorry it_t_s a long rambling post - it took me more time to write this forum post than the controller code itself! _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTLDR_dd_ Daydream controller has basic support (buttons work) - there_t_s additional info here if you wanted to work on that or add a new controller.  If you want to test your Daydream controller enable two flags in chrome_dd_//flags.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs announced last month_co_ BabylonJS added basic support for Gear VR.  I put some instructions there for debugging GearVR as well.\n_lt_/p_gt_\n_lt_iframe allowfullscreen_eq__qt__qt_ data-controller_eq__qt_core.front.core.autosizeiframe_qt_ data-embedcontent_eq__qt__qt_ data-embedid_eq__qt_embed8347972451_qt_ scrolling_eq__qt_no_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/35003-basic-gearvr-controller-support-and-wifi-debugging/?do_eq_embed_qt_ style_eq__qt_height_dd_207px_sm_max-width_dd_502px_sm__qt__gt__lt_/iframe_gt_\n\n_lt_p_gt_\n\tSetting up your  phone for Daydream VR.  I have a Pixel 2 and even with the Pixel 2_co_ surprisingly you need to change some settings to get a good experience.  Before I enabled these flags it was not an immersive experience even full screen (as I was testing it).  That_t_s unfortunate_co_ but I think these features will be enabled by default in the future. Open up Chrome and visit chrome_dd_//flags to enable feature toggles for Gamepad extensions and WebVR_dd__lt_br /_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ data-fileid_eq__qt_17173_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/Screenshot_20180217-165520-daydream.png.3be220f4343896f6432ace52d80d68a1.png_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_Screenshot_20180217-165520-daydream.thumb.png.80aa0303388a5c468dd0dbe0cd0395fa.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_17173_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/Screenshot_20180217-165520-daydream.thumb.png.80aa0303388a5c468dd0dbe0cd0395fa.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe nice thing about the Daydream Headset is that you can use it while plugged into USB for ADB over USB.  For Gear VR you needed to debug over WiFi by design.  You will need to follow instructions to enable USB debugging on your phone and the ADB instructions are in the GearVR post - just remember that WiFi is optional for Daydream.  Should end up looking like this on your _qt_Remote Devices_qt_ tab on Chrome on your desktop_dd__lt_br /_gt_\n\t_lt_img alt_eq__qt_inspect.png.1df054f2329acaa839edb1d21081d13d.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_17177_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/inspect.png.1df054f2329acaa839edb1d21081d13d.png_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe first time I plugged in the headset basically shows what the fallback (Generic) controller will output.  This is helpful for you to figure out what indexes the buttons are in the Gamepad API.  Here_t_s the output_dd__lt_br /_gt_\n\t_lt_img alt_eq__qt_console_1.png.f54aeb37210e57f5c6a1f9cee03c6dc4.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_17174_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/console_1.png.f54aeb37210e57f5c6a1f9cee03c6dc4.png_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPressing the home and app buttons did not output anything_co_ so that lets you know that they aren_t_t connected to the Gamepad API.  The buttons do work on your phone_co_ but for built-in OS features.  What I did was grab the ID of the controller by adding a console.log and then create a new controller class.  Here is the full output of what is generated from the Gamepad_dd__lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ data-fileid_eq__qt_17176_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/daydream_gamepad.png.7ebeed1a3480bea2fbf2e73a2b1272e0.png_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_daydream_gamepad.thumb.png.f50c9f9aaed9ac325e234be48265c326.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_17176_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_02/daydream_gamepad.thumb.png.f50c9f9aaed9ac325e234be48265c326.png_qt_ /_gt__lt_/a_gt__lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat I want to do here is also outline steps to follow to add your own controller.  There was a post about an unsupported 6DoF controller that led to a github issue (future feature) tagged _qt_Help Wanted_qt_ (_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/issues/3514_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/issues/3514_lt_/a_gt_) to basically allow devs to dynamically register support for new controllers and it will probably work similar to how the Model Loaders work_co_ so your registered controller class would get asked if it supports_dd_ ie_dd_ _qt_Daydream Controller_qt__co_ but we are not there yet.  Not to get too side tracked_co_ but the cool thing about that idea is we could use NPM to create and load new controllers_sm_ maybe even all VR and make BabylonJS core even smaller.  I think also a notion of priorities may be needed to override defaults vs. custom vs. generic_co_ but I digress...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRight now you need to manually edit some files to allow your custom Controller to run instead of the Generic controller.  Looking at the PR you can see there_t_s only a couple of lines of code to wire this controller in - it only needs to be detected before the generic fallback to be used.  Assuming that your new controller supports _t_pose_t_ in the gamepad API then you could hook it up here_dd__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Gamepad/Controllers/babylon.poseEnabledController.ts#L46_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Gamepad/Controllers/babylon.poseEnabledController.ts#L46_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\tAn astute reader who hasn_t_t fallen asleep this far into the post may have noticed that _t_hasPosition_t_ is false and _t_position_t_ is null.  That_t_s basically saying that the controller does not support it_t_s physical location in 3D space (it only knows gyro rotation).  Typically when discussing 3DoF the position is available and nothing else (vs 6DoF with position &amp_sm_ rotation) - here we are talking about rotational data being available and positional info not.  ie_dd_ Vive has Lighthouse tracking and WinMR tracks controllers from HMD for accurate position of the controller in space and are both 6DoF.  If you look in the BJS source and come across this in the WebVRCamera you would notice that the hasPosition property is _qt_missing_qt__dd__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Cameras/VR/babylon.webVRCamera.ts#L12_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Cameras/VR/babylon.webVRCamera.ts#L12_lt_/a_gt__lt_br /_gt_\n\tThat_t_s because VRPose and GamepadPose are different.  Here is the spec on GamepadPose (not in BJS source_co_ but should be at some point because right now the parameters are typed as _t_any_t_)_dd__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//developer.mozilla.org/en-US/docs/Web/API/GamepadPose_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//developer.mozilla.org/en-US/docs/Web/API/GamepadPose_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOK_co_ so I_t_ll come back to that in another post as I want to in the future make this 3DoF controller a 6Dof experience.   Some very naïve code that does not work would look like this_co_ but I feel the changes belong in WebVRController and not in each Controller...\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_this.capableOfPosition _eq_ vrGamepad.pose || vrGamepad.pose.hasPosition _eq__eq__eq_ true_sm_\n\nif (!this.capableOfPosition) {\n    // Device not capable of position (ie_dd_ 3DoF rotation only).\n    // Position estimated from VR experience helper default height 1.7m.\n    let controllerPosition _eq_ new BABYLON.Vector3(0.5_co_ -1.0_co_ -0.25)_sm_\n\n    if (this._defaultModel &amp_sm_&amp_sm_ this._defaultModel.getScene().useRightHandedSystem) {\n        controllerPosition.z *_eq_ -1_sm_\n    }\n\n    controllerPosition.scaleInPlace(this.deviceScaleFactor)_sm_\n    console.log(_t_setting default controller position_dd__t__co_ controllerPosition)_sm_\n    this._defaultModel.position _eq_ controllerPosition_sm_\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tSo_co_ next steps are to create the 6DoF experience to get away from rays coming from your eyes (think superman heat vision).  It will be based_co_ I think_co_ by guessing first where your elbow is.  The elbow is following your head rotations as your HMR rotates (and torso).  Probably moving up a bit with your HMD and backwards when you look down.  Then with the known gyro rotation of the controller you just position the controller where the hand would be based on that rotation and elbow position and forearm length.  I_t_m going to try a few more experiments within the Daydream and Oculus environments to see how they position the elbow and when they guess your torso is rotating (I think camera intertia will play a role in that movement - like ignore low inertia maybe).  I have to look again_co_ but I don_t_t think the default height and model scaling are available from VRExperienceHelper_co_ but they need to be - they_t_re definitely not in the _t_update_t_ method_co_ but I think those need to be taken into account for a good experience.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tController models are still needed (also for GearVR).  Luckily google VR has made models available under Apache 2.0 (one is low poly with texture) and I think we can bring those in - I_t_ll let the license experts decide_dd__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/googlevr/gvr-unity-sdk/tree/master/Assets/GoogleVR/Models_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/googlevr/gvr-unity-sdk/tree/master/Assets/GoogleVR/Models_lt_/a_gt__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/googlevr/gvr-android-sdk/tree/master/assets/controller_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/googlevr/gvr-android-sdk/tree/master/assets/controller_lt_/a_gt__lt_br /_gt_\n\t_lt_br /_gt_\n\tAnway_co_ first goal is reached that both Samsung and Google phone controllers buttons can interact through BJS.  Of course_co_ anybody else is fully welcome to implement those changes if they wanted.  Let me know here so we don_t_t do double work.  I_t_ll do another post later on when I start on the 6DoF stuff_co_ but pretty busy for next 3-4 weeks.  Cheers.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2018-02-26T16:54:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWow!  A fantastic bit of work/research_co_ BZ!  Well done!  You_t_re a natural docs-writer/teacher.  What a clear and thorough report.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span style_eq__qt_font-size_dd_14px_sm__qt__gt__lt_strong_gt_THANK YOU!_lt_/strong_gt_  _lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]