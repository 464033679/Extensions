[{"Owner":"Nockawa","Date":"2016-05-14T21:13:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk folks_co_ this is the last quick post I have for you (I think)...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe name of the class is well...I had to find a name_co_ that_t_s all...\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt__lt_u_gt_The problematic_dd__lt_/u_gt__lt_/strong_gt_ to render efficiently we have to minimize the draw calls as much as possible_co_ so when it_t_s possible we have to rely on the _lt_a href_eq__qt_https_dd_//www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/_qt_ rel_eq__qt_external nofollow_qt__gt_WebGL Instanced Array_lt_/a_gt_ extension. Basically_co_ this extension is used to create an Array Buffer that will contains all the settings specific to each instance of the same object you want to render multiple time. Say _lt_a href_eq__qt_http_dd_//babylonjs-playground.com/#OWCCR%235_qt_ rel_eq__qt_external nofollow_qt__gt_hundreds_co_ thousands of Rounded Rectangles in the Canvas2D_lt_/a_gt__co_ drawn in one call for instance!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut how to feed the beast (the array buffer) ? Especially if the objects you send are subject to things like culling_co_ clipping_co_ visibility change_dd_ which make the whole list change frequently!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt__lt_u_gt_The solution_dd__lt_/u_gt__lt_/strong_gt_ A class designed to allocate/free elements_co_ storing them into a Float32Array (because believe me_dd_ size does matter_co_ and 32bits per number is ok for us!) and providing a method to defragment its content in order to update the Instanced Array buffer without worries.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWell_co_ ok_co_ you_t_ve guessed_co_ that_t_s what DynamicFloatArray is about!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen you create an instance of this class you specify the size of one element (the size is in floats_co_ NOT in bytes)_dd_ this is called the Stride. So if you need to store 4 Vector4 for a transformation matrix and one Color4 for the color of you object_co_ the stride will be 4*4 + 1 _eq_ 17! You also specify the initial count of elements the Float32Array can contains without being resized (and it will_co_ after this count is reached_co_ by 50%_co_ I know it may looks a lot_co_ but resizing in not my friend!)...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThen it_t_s pretty simple_dd_ when you need to store one new element_co_ you call allocElement()_co_ it returns an instance of the DynamicFloatArrayElementInfo class (I know the name couldn_t_t have been longer) which contains the offset into the Float32Array of where your element first float is located. It_t_s up to you to be a big nice boy and copy the data accordingly_co_ otherwise face the consequences!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you don_t_t need this element anymore_co_ just call freeElement() giving the corresponding DynamicFloatArrayElementInfo object.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow_co_ what is the deal you might ask? When you call freeElement() it creates _qt_holes_qt_ in your Float32Array_co_ holes that you can_t_t send to the Instanced Array buffer without facing another kind of very bad consequence!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo all you have to do thanks to this class_co_ is to call the pack() method (which I spent 3 hours to write_co_ true story_co_ that long...) which will defrag the Float32Array_co_ removing the holes by moving valid elements to fill them (the holes!). Don_t_t fear to call this method_co_ if nothing is fragmented it will return in no time_co_ if the content if full of holes_co_ well_co_ I spent 3 hours to make sure it defrags it very quickly! Calling pack() returns what is called a _lt_a href_eq__qt_https_dd_//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray_qt_ rel_eq__qt_external nofollow_qt__gt_subArray_lt_/a_gt__co_ this is NOT a copy (I hate copies_co_ like resizing_co_ a little less though)_co_ but a view of your dear unfragmented Float32Array_co_ ready to feed the Instanced Array Buffer!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo to sum up_dd_ at each render when you use an Instanced Array_co_ call pack() and update the Array Buffer that you just bind. (sadly_co_ it_t_s still up to you to detect if there was changes and if the update is needed or not_co_ but it shouldn_t_t be a big deal for you to handle)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt__lt_u_gt_Beware!_lt_/u_gt__lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs the smartest of you may have noticed_co_ calling pack() will _lt_em_gt_move_lt_/em_gt_ some elements_co_ which means their position in the Float32Array will change! That is why I return an instance of the DynamicFloatArrayElementInfo class (which only contain a single property_dd_ the offset) and not a single number I wouldn_t_t be able to update for you! When an element is moved_co_ its offset in the DynamicFloatArrayElementInfo object is updated accordingly and it_t_s _lt_strong_gt_your_lt_/strong_gt_ responsibility to get this offset every time you are going to update a given element.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_u_gt__lt_strong_gt_Conclusion_lt_/strong_gt__lt_/u_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWell_co_ I forgot to say the DynamicFloatArray will grow when needed...but will never shrink_co_ sadly...a such feature could be open for debate.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you plan to use Instanced Array_co_ I believe this will a great help to you as it was for me when developing the Canvas2D. So far the class looks pretty reliable_co_ but I have to admit_dd_ the pack() method...is not the easiest thing to code! (efficiently_co_ for me at least!)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOh_co_ by the way_co_ it might interest you_co_ but now the methods Engine.updateAndBindInstancesBuffer() and Engine.unBindInstancesBuffer() are able to update any kind of Instanced Array_co_ useful! _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ All you have to do is using the offsetLocation argument as a InstancingAttributeInfo[] which contains everything to wire the Array correctly !\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHave fun !\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-05-15T02:26:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tLol you_t_re unstoppable!\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-05-15T18:54:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tgreatissimo !\n_lt_/p_gt_\n\n_lt_p_gt_\n\tbut how could you invent things to optimize the use of  webgl and in the same time choose so longVerboseAndComplicatedNames for your functions ? _lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tjust kidding\n_lt_/p_gt_\n\n_lt_p_gt_\n\texcellent tool !\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]