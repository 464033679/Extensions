[{"Owner":"splash27","Date":"2018-01-13T13:11:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi_co_ everyone!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI want to share my wind implementation in BabylonJS with explanations.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt may to seem obvious. Wind is just an adding the vector to objects position. But if we_t_ll go this way_co_ then result will be boring. We_t_ll just get sliding objects. Our goal is to perform the storm with bouncing and collisions.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst of all we need to enable collisions for all meshes and camera. We_t_ ll also configure gravity here._lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_scene.gravity _eq_ new BABYLON.Vector3(0_co_ -0.9_co_ 0)_sm_\n\nscene.collisionsEnabled _eq_ true_sm_\n\ncamera.checkCollisions _eq_ true_sm_\ncamera.applyGravity _eq_ true_sm_\ncamera._needMoveForGravity _eq_ true_sm_\n\nground.checkCollisions _eq_ true_sm_\nbox.checkCollisions _eq_ true_sm_\nc1.checkCollisions _eq_ true_sm_\nc2.checkCollisions _eq_ true_sm_\nc3.checkCollisions _eq_ true_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThen we need to implement a kind of objects pushing. When camera can pushes objects. I decided to mark meshes that can be pushed by camera with special property _qt_pushable_qt_. Here is implementation.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var physicsPlugin _eq_ new BABYLON.CannonJSPlugin()_sm_\nscene.enablePhysics()_sm_\n\nground.physicsImpostor _eq_ new BABYLON.PhysicsImpostor(ground_co_ BABYLON.PhysicsImpostor.BoxImpostor_co_ { mass_dd_ 0_co_ restitution_dd_ 0.9 }_co_ scene)_sm_\nbox.physicsImpostor _eq_ new BABYLON.PhysicsImpostor(box_co_ BABYLON.PhysicsImpostor.BoxImpostor_co_ { mass_dd_ 10_co_ restitution_dd_ 0.1 }_co_ scene)_sm_\nc1.physicsImpostor _eq_ new BABYLON.PhysicsImpostor(c1_co_ BABYLON.PhysicsImpostor.BoxImpostor_co_ { mass_dd_ 20_co_ restitution_dd_ 0.1 }_co_ scene)_sm_\nc2.physicsImpostor _eq_ new BABYLON.PhysicsImpostor(c2_co_ BABYLON.PhysicsImpostor.BoxImpostor_co_ { mass_dd_ 20_co_ restitution_dd_ 0.1 }_co_ scene)_sm_\nc3.physicsImpostor _eq_ new BABYLON.PhysicsImpostor(c3_co_ BABYLON.PhysicsImpostor.BoxImpostor_co_ { mass_dd_ 150_co_ restitution_dd_ 0.1 }_co_ scene)_sm_\n\n//handling when camera pushes other meshes\nvar playerImpulse _eq_ 30_sm_ //we can use fixed value_co_ because player mass and velocity is constant in most cases\n\ncamera.onCollide _eq_ function (mesh) {\n    if (mesh.pushable) {\n        var givenVelocity _eq_ playerImpulse / mesh.physicsImpostor.mass_sm_\n        var camPosition _eq_ camera.position.clone()_sm_\n        camPosition.y -_eq_ camera.ellipsoid.y * 0.80_sm_ //kick height\n        var movementDirectionVector _eq_ mesh.getAbsolutePosition().subtract(camPosition)_sm_                \n        mesh.physicsImpostor.setLinearVelocity(movementDirectionVector.scale(givenVelocity))_sm_\n    }\n}_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tOk_co_ when we _qt_touch_qt_ a mesh we detect if it_t_s pushable_co_ then calculate direction using camera and mesh positions. Thanks _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5733-wingnut/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5733_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5733-wingnut/_qt_ rel_eq__qt__qt__gt_@Wingnut_lt_/a_gt_ for tips with this part. Also_co_ I correct direction at y property. It needed to make things look like the player applies force using his leg. So I correct the height at which the force will be applied. I don_t_t use addImpulse method_co_ because CannonJS accumulate impulses and we can boost meshes to incredible velocities by several touches. It_t_s better to set the final velocities.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd now the wind. We need some things to keep in mind to procced.\n_lt_/p_gt_\n\n_lt_ul_gt__lt_li_gt_\n\t\tWind should preserve current meshes velocities. It should not to override_co_ for example_co_ a gravity effect.\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tWind should be applied to camera also for best user_t_s experience. But we know that camera has now physicsImpostor.\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tWe must provide safe places_co_ where we can hide from the wind_co_ for example_co_ in a cave or behind the building. Should work for meshes and camera.\n\t_lt_/li_gt_\n_lt_/ul_gt__lt_p_gt_\n\tAnd now the implementation goes.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    var wb1 _eq_ BABYLON.MeshBuilder.CreateBox(_qt_wb1_qt__co_ {width_dd_ 8_co_ height_dd_ 8_co_ depth_dd_ 8}_co_ scene)_sm_\n    var wbMat _eq_ new BABYLON.StandardMaterial(_qt_wbmat_qt__co_ scene)_sm_\n    wbMat.wireframe _eq_ true_sm_\n    wb1.position _eq_ new BABYLON.Vector3(55_co_ -6_co_ 2)_sm_\n    wb1.material _eq_ wbMat_sm_\n\n    var wb2 _eq_ BABYLON.MeshBuilder.CreateBox(_qt_wb2_qt__co_ {width_dd_ 8_co_ height_dd_ 8_co_ depth_dd_ 8}_co_ scene)_sm_\n    wb2.position _eq_ new BABYLON.Vector3(40_co_ -6_co_ 20)_sm_\n    wb2.material _eq_ wbMat_sm_\n\n    function pointIntersectsAny(volumes_co_ point) {\n        for (var k _eq_ volumes.length - 1_sm_ k &gt_sm__eq_ 0_sm_ k--) {\n            if (volumes[k].intersectsPoint(point)) {\n                return true_sm_\n            }\n        }\n        return false_sm_\n    }\n\n    function meshIntersectsAny(volumes_co_ mesh) {\n        for (var k _eq_ volumes.length - 1_sm_ k &gt_sm__eq_ 0_sm_ k--) {\n            if (volumes[k].intersectsMesh(mesh_co_ false)) {\n                return true_sm_\n            }\n        }\n        return false_sm_\n    }\n\n    //wind processor_co_ should be called from gaming loop\n    function processWind (scene_co_ camera_co_ vector_co_ meshWindScale_co_ windBlocks) {\n        var scale _eq_ meshWindScale || 1_sm_\n        var windBlocks _eq_ windBlocks || []_sm_\n\n        if (!pointIntersectsAny(windBlocks_co_ camera.position)){\n            camera.position _eq_ camera.position.add(vector)_sm_\n        }\n\n        var meshes _eq_ scene.meshes_sm_\n        for (var i _eq_ meshes.length - 1_sm_ i&gt_sm__eq_0_sm_ i--) {\n            if (meshes[i].pushable &amp_sm_&amp_sm_ meshes[i].physicsImpostor) {\n                if (!meshIntersectsAny(windBlocks_co_ meshes[i])) {\n                    meshes[i].physicsImpostor.setLinearVelocity(meshes[i].physicsImpostor.getLinearVelocity().add(vector.scale(scale)))_sm_\n                }\n            }\n        }\n    }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tOk_co_ wb1 and wb2 are safe volumes where is no wind at any conditions. I use a wireframe to display_co_ later these meshes can be set as invisible. pointIntersectsAny and meshIntersectsAny are helpers and pretty self-explanatory.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe main action is inside processWind function. We handle the camera and meshes separately. Actually_co_ we don_t_t see the player outside of the camera_co_ so_co_ we can manipulate it_t_s position directly. What concerns the meshes_co_ we should apply linearVelocity to them to make CannonJS to handle their movements in physical manner. Look how we preserved the initial linearVelocity using getLinearVelocity. Of cource the wind can_t_t move the heavy objects if wind_t_s strength is not big enough.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf a camera or meshes are inside the safe volume then no wind will be applied to it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI also added an ability to scale the wind applied to meshes. It could be useful for some effects. For example_co_ when player has a special boots with high friction value. So the player can resist the wind.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAlso important to say_co_ that wind could be applied only to _qt_pushable_qt_ meshes that have physicsImpostors.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd all we need is just launch whe wind.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var windAllowed _eq_ false_sm_\n\n//press _qt_f_qt_ to launch the wind\ndocument.addEventListener(_qt_keydown_qt__co_ function (e) {\n    if (e.keyCode _eq__eq_ 70) {\n        windAllowed _eq_ true_sm_\n    }\n})_sm_\n\nscene.registerBeforeRender(function () {\n    if (windAllowed) {\n        processWind(scene_co_ scene.cameras[0]_co_ new BABYLON.Vector3(0.1_co_ 0_co_ 0.1)_co_ 2_co_ [wb1_co_ wb2])_sm_\n    }\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tHere is playground_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#3CPL8T%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#3CPL8T#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI also implemented jumping_co_ croaching and free mouse-look just for fun. _eq_)_lt_br /_gt__lt_br /_gt_\n\tYeah_co_ there are still some issues. For example_co_ camera affected by the wind can flow through objects. It could be fixed by checking onCollide event.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnother issue_co_ this wind acts like constant force. It looks like spaceship depressurization than like actual wind. But you can try to add flurries using _lt_strong_gt_f(t) _eq_ |six(t)|_lt_/strong_gt_ function or something else.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFeel free to tune my approach for your needs or share your implementations.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you want to use this in your project_co_ the credits will be much appreciated but it_t_s not required.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_div style_eq__qt_background-color_dd_#fffffe_sm_color_dd_#000000_sm_font-size_dd_14px_sm__qt__gt_\n\t \n_lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2018-01-13T15:38:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tToo cool_co_ Splash!   _t_C_t_ for crouch_co_ space for jump_co_ _t_F_t_ to Flow the winds.  WASD and arrow keys active.  Don_t_t get _t_blown away_t_.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tFun idea/project! \n_lt_/p_gt_\n\n_lt_p_gt_\n\tTornadoes_co_ next?  Hard_co_ huh?  A vortex of invisible circular intersection zones_co_ and the direction of impulses is dependent-upon which _qt_ring of impulsing influence_qt_ that a mesh_t_s absolutePosition is located-within (and where within the ring_co_ degrees/radially_co_ too). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWow!  My brain hurts just thinking about it.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_  It makes me ponder... self-impulsing smart-mesh_co_ which monitor their _t_world_t_ and always know how to pulse themselves.  hmm.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]