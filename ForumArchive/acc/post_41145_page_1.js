[{"Owner":"tham_kathy","Date":"2018-11-09T06:25:31Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tQuestion is regarding example _lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#4GBWI5_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#4GBWI5_lt_/a_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t understand how outer walls and footprint is created. I_t_m confused with the below code and can anyone please explain the below code step by step? \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_for(var w _eq_ 0_sm_ w &lt_sm__eq_ nbWalls_sm_ w++) \n{\t\n\tangle _eq_ Math.acos(BABYLON.Vector3.Dot(line_co_ nextLine)/(line.length() * nextLine.length()))_sm_\n\tdirection _eq_ BABYLON.Vector3.Cross(nextLine_co_ line).normalize().y_sm_\n\tlineNormal _eq_ new BABYLON.Vector3(line.z_co_ 0_co_ -1 * line.x).normalize()_sm_\n\tline.normalize()_sm_\n\touterData[(w + 1) % nbWalls] _eq_ walls[(w + 1) % nbWalls].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply/Math.tan(angle/2)))_sm_\t\t\n\tline _eq_ nextLine.clone()_sm_\t\t\n\twalls[(w + 3) % nbWalls].corner.subtractToRef(walls[(w + 2) % nbWalls].corner_co_ nextLine)_sm_\t\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_div style_eq__qt_background-color_dd_#fffffe_sm_color_dd_#000000_sm_font-size_dd_14px_sm__qt__gt_\n\t \n_lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2018-11-09T12:43:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_img class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_20868_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_11/wall.jpg.d36534f906478b4523e7327ddcd77208.jpg_qt_ alt_eq__qt_wall.jpg.d36534f906478b4523e7327ddcd77208.jpg_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn this image the blue walls are the inner walls and the red ones the outer walls_co_ the position vectors ai_co_ bi_co_ ci are known and hence so will line L _eq_ bi - ai and next line N _eq_ ci - bi. We need to find the position vector of bo.  Knowing the distance between the inner and outer wall we can use the right angled triangles (as shown) to determine bo.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tUsing the _lt_a href_eq__qt_https_dd_//en.wikipedia.org/wiki/Dot_product_qt_ rel_eq__qt_external nofollow_qt__gt_vector dot product_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_angle _eq_ Math.acos(BABYLON.Vector3.Dot(line_co_ nextLine)/(line.length() * nextLine.length()))_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\twe can determine the angle between L and N. However that angle can be acute (left hand image)_co_ obtuse or reflex (right hand image) whereas the Math.acos returns an angle between 0 and PI.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tUsing the _lt_a href_eq__qt_https_dd_//en.wikipedia.org/wiki/Cross_product_qt_ rel_eq__qt_external nofollow_qt__gt_cross product _lt_/a_gt_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_direction _eq_ BABYLON.Vector3.Cross(nextLine_co_ line).normalize().y_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\twill give a vector perpendicular to L and N ie of the form (0_co_ y_co_ 0) and normalizing will give (0_co_ 1_co_ 0) or (0_co_ -1_co_ 0) depending whether the angle is reflex or not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWe need to find out the unit vector perpendicular to L (forms the right angle in the images).  Since taking the dot product of (x1_co_ y1_co_ z1) with (x2_co_ y2_co_ z2) gives x1x2 + y1y2 + z1z2 which will be zero when the two vectors are perpendicular then for L _eq_ (x_co_ 0_co_ z) the perpendicular (or normal line) to L in the plane LN will have the form (-z_co_ 0_co_ x) as these give a dot product of zero. Hence\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_lineNormal ﻿_eq_ new BABYLON.Vector3(line.z_co_ 0_co_ -1 * line.x).normalize()_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThe we need the unit vector in the direction of L\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_line.normalize()_sm_﻿﻿_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tCurrent ai tells us we are at wall w and bo is for wall w + 1. Since the walls are closed at the end wall w + 1 _eq_ 0. Hence the need to work _lt_a href_eq__qt_https_dd_//en.wikipedia.org/wiki/Modulo_operation_qt_ rel_eq__qt_external nofollow_qt__gt_modulo_lt_/a_gt_ the number of walls\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_(w + 1) % nbWalls_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tNow we can use the right angled triangle to determine the position vector of bo. Starting from bi (corner of wall w + 1 mod nbWalls) travel along base and along height to get to bo (vector addition is commutative so can add in opposite order) as below\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_Walls﻿] _eq_ walls[(w + 1) % nbWalls].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply/Math.tan(angle/2)))_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tremember ply is distance between inner and outer wall so vector along height is scaled by ply. Knowing ply and the angle we can use tan to get the base length. Multiplying by direction deals with when angle is reflex or not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\twe can then move on to the next line along\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_line _eq_ nextLine.clone()_sm_﻿\t_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tand find the next line. Note we are using subtractToRef\n_lt_/p_gt_\n\n_lt_p_gt_\n\tV.subtractToRef(W_co_ R) which takes W from V and puts the result into R\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_walls[(w + 3) % nbWalls].corner.subtractToRef(walls[(w + 2) % nbWalls].corner_co_ nextLine)_sm_\t_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tnote that as ai is wall w_co_ bi is wall w + 1 and ci is wall w + 2\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHope that helps\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"tham_kathy","Date":"2018-11-09T19:22:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOne last thing_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat is the purpose of using indices array? \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_for(var w _eq_ 0_sm_ w &lt_sm_nbWalls_sm_ w++) \n{\n\tindices.push(w_co_ (w + 1) % nbWalls_co_ nbWalls + (w + 1) % nbWalls_co_ w_co_ nbWalls + (w + 1) % nbWalls_co_ w + nbWalls)_sm_ // base indices\n}\n\ncurrentLength _eq_ indices.length_sm_\nfor(var i _eq_ 0_sm_ i &lt_sm_currentLength/3_sm_ i++) \n{\n\tindices.push(indices[3*i + 2] + 2*nbWalls_co_ indices[3*i + 1] + 2*nbWalls_co_ indices[3*i] + 2*nbWalls )_sm_ // top indices\n}\n\t\nfor(var w _eq_ 0_sm_ w &lt_sm_nbWalls_sm_ w++) \n{\n\tindices.push(w_co_ w + 2 *nbWalls_co_ (w + 1) % nbWalls + 2*nbWalls_co_ w_co_ (w + 1) % nbWalls + 2*nbWalls_co_ (w + 1) % nbWalls)_sm_ // inner wall indices\n\tindices.push((w + 1) % nbWalls + 3*nbWalls_co_ w + 3 *nbWalls_co_ w + nbWalls_co_ (w + 1) % nbWalls + nbWalls_co_ (w + 1) % nbWalls + 3*nbWalls_co_ w + nbWalls)_sm_ // outer wall indices\n}\t\t\n\t_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tAnd \n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tQuote\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\t_lt_span style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#000000_sm_font-size_dd_medium_sm__qt__gt_To form the mesh_co_ the base_co_ top_co_ inner wall and outer wall have to be split into triangular facets by grouping sets of three corners for each and pushing these into the indices array._lt_/span_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\twhat does this mean? \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2018-11-10T15:12:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIndices explained _lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/custom#positions-and-indices_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/how_to/custom#positions-and-indices_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"tham_kathy","Date":"2018-11-11T18:28:41Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_234243_qt_ data-ipsquote-contentid_eq__qt_41145_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1541767427_qt_ data-ipsquote-userid_eq__qt_14282_qt_ data-ipsquote-username_eq__qt_JohnK_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tOn 11/9/2018 at 6_dd_13 PM_co_ JohnK said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tCurrent ai tells us we are at wall w and bo is for wall w + 1. Since the walls are closed at the end wall w + 1 _eq_ 0. Hence the need to work _lt_a href_eq__qt_https_dd_//en.wikipedia.org/wiki/Modulo_operation_qt_ rel_eq__qt_external nofollow_qt__gt_modulo_lt_/a_gt_ the number of walls\n\t\t_lt_/p_gt_\n\n\t\t_lt_pre_gt_\n\n_lt_code_gt_(w + 1) % nbWalls_lt_/code_gt__lt_/pre_gt_\n\n\t\t_lt_p_gt_\n\t\t\tNow we can use the right angled triangle to determine the position vector of bo. Starting from bi (corner of wall w + 1 mod nbWalls) travel along base and along height to get to bo (vector addition is commutative so can add in opposite order) as below\n\t\t_lt_/p_gt_\n\n\t\t_lt_pre_gt_\n\n_lt_code_gt_Walls﻿] _eq_ walls[(w + _lt_span_gt_1_lt_/span_gt_) % nbWalls].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply/_lt_span_gt_Math_lt_/span_gt_.tan(angle/_lt_span_gt_2_lt_/span_gt_)))_sm__lt_/code_gt__lt_/pre_gt_\n\n\t\t_lt_p_gt_\n\t\t\tremember ply is distance between inner and outer wall so vector along height is scaled by ply. Knowing ply and the angle we can use tan to get the base length. Multiplying by direction deals with when angle is reflex or not.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/14282-johnk/?do_eq_hovercard_qt_ data-mentionid_eq__qt_14282_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/14282-johnk/_qt_ rel_eq__qt__qt__gt_@JohnK_lt_/a_gt_ Can you explain this bit more if you don_t_t mind ? \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2018-11-11T20:14:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHow much trigonometry and vectors do you know?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t6 walls 0_co_1_co_2_co_3_co_4_co_5\n_lt_/p_gt_\n\n_lt_p_gt_\n\tx % 6 means x modulo 6 ie remainder when x is divded by 6\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWalls join 0-1-2-3-4-5-0 get by adding 1 each time 5+1_eq_6\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDivide 6 by 6 remainder is 0 and  (5+1)%6_eq_0\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]