[{"Owner":"platane","Date":"2014-05-09T11:53:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi there_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have a question related to how the alpha is computed in default shader which use a texture._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What I am trying to achieve here is to display the length of an object in a dynamic texture._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//oi58.tinypic.com/if4e90.jpg_qt_ alt_eq__qt_if4e90.jpg_qt__gt_   _lt_img src_eq__qt_http_dd_//oi62.tinypic.com/x2nuib.jpg_qt_ alt_eq__qt_x2nuib.jpg_qt__gt__lt_/p_gt__lt_p_gt_ without transparent background                   with transparent background _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The shader algorithms only render pixels as opaque or full transparent ( discarded with alpha test ) which create this aliased aspect._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In order to make everything looks smoother_co_ I want to have pixel that have an alpha channel between 0 and 1. I understand that it_t_s more expensive in term of performance._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I found two ways to enable pixel blending_dd__lt_/p_gt__lt_p_gt_  * I can apply a global alpha to the whole material but that_t_s not what I want_lt_/p_gt__lt_p_gt_  * I can use an opacity texture. It works but I think it_t_s a bit overkill._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Indeed as the alpha information are already in the diffuse texture_co_ the information in the opacity texture are redundant in that case._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I am ok with this solution_co_ but is there currently a better way to achieve this? I guess we could use a flag to trigger a special behavior of the shader_co_ but it may not worth it if this usecase is no so common._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_UPDATE _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_modifications merged here  _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/pull/194_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/pull/194_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_thanks!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-05-09T16:12:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The way I can tell you is to use the opacity texture with the same file (in this case there is no overhead)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"platane","Date":"2014-05-09T23:28:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well if I am not mistaken_co_ In this case_co_ it will not produce the desired effect as the alpha computed with the opacity texture is a composition of the texture pixel _t_s luminosity ( based on rvb values ) and it_t_s actual alpha._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_#ifdef OPACITY\tvec4 opacityMap _eq_ texture2D(opacitySampler_co_ vOpacityUV)_sm_\topacityMap.rgb _eq_ opacityMap.rgb * vec3(0.3_co_ 0.59_co_ 0.11) * opacityMap.a_sm_\talpha *_eq_ (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y_sm_#endif_lt_/pre_gt__lt_p_gt_As the non transparent pixels are black_co_ the value is zero even if the alpha channel is 1._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Once again_co_ it_t_s fine by me to use two separate textures for this effect_co_ but I think this case could be treated in a simpler way_co_ and it may be a feature worth to discuss about._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_thanks !_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-05-09T23:34:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Oh yes you are absolutely right_dd_ I idid that to support both alpha and black and white opacity maps_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Crap! Sorry about that_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"platane","Date":"2014-05-12T15:21:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So do you think It is worthy to add another behavior ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_A flag could trigger a behavior where the diffuse texture_t_s alpha channel is implied in the alpha computation of the pixel._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you think it could be usefull_co_ I_t_ll made a pull request_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-05-12T17:55:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If we can have it without losing performance it is perfect_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]