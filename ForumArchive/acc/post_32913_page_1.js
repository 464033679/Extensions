[{"Owner":"focomoso","Date":"2017-09-13T23:10:17Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_ve searched the forums and found these threads_dd_\n_lt_/p_gt_\n_lt_iframe allowfullscreen_eq__qt__qt_ data-controller_eq__qt_core.front.core.autosizeiframe_qt_ data-embedcontent_eq__qt__qt_ data-embedid_eq__qt_embed6401058269_qt_ scrolling_eq__qt_no_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/26110-angle-of-mesh-intersection/?tab_eq_comments&amp_sm_do_eq_embed&amp_sm_comment_eq_155213&amp_sm_embedComment_eq_155213&amp_sm_embedDo_eq_findComment#comment-155213_qt_ style_eq__qt_height_dd_275px_sm_max-width_dd_500px_sm__qt__gt__lt_/iframe_gt__lt_iframe allowfullscreen_eq__qt__qt_ data-controller_eq__qt_core.front.core.autosizeiframe_qt_ data-embedcontent_eq__qt__qt_ data-embedid_eq__qt_embed279227925_qt_ scrolling_eq__qt_no_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/31256-image-gets-darkened-after-resizing-the-object/?tab_eq_comments&amp_sm_do_eq_embed&amp_sm_comment_eq_180890&amp_sm_embedComment_eq_180890&amp_sm_embedDo_eq_findComment#comment-180890_qt_ style_eq__qt_height_dd_244px_sm_max-width_dd_500px_sm__qt__gt__lt_/iframe_gt_\n\n_lt_p_gt_\n\tBut neither is helping me with my issue.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you take a look at the playground here_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%231_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m importing an stl. It looks great on import_co_ but when scaled_co_ the shading doesn_t_t seem to update.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs there a way to tell a mesh to update it_t_s shading?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-13T23:27:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThis is normal as the normals are pointing downwards _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tJust add a second light from the bottom_dd_ _lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%232_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#2_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-13T23:31:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHow do we get the normals to update_co_ then? That would solve this.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve implemented the updateFacetData() mentioned in a comment to one of the threads above_co_ but it doesn_t_t seem to take scaling into account. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-13T23:34:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tNormal are correct _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ just that your light is not pointing to the right direction \n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-14T00:04:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_m not sure that_t_s what_t_s going on. Take a look at this playground. A regular sphere vs an imported flat sphere that_t_s then scaled up to look regular_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%233_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#3_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe shading looks very different between the two despite them both having flat shading. \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tps - this one is a little more apples to apples_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%234_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#4_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-14T00:34:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAnd here_t_s one that_t_s even more _qt_apples to apples_qt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBoth spheres here were created in Tinkercad. They are identical except that sphere-flat.stl was scaled down to 25% in the y.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs you can see_co_ when the flattened sphere is scaled back up again_co_ its shading is very different from the non-scaled sphere.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%236_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#6_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI wonder if the stl import is doing something to the normals? I_t_m not sure what exactly is going on here.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-14T16:26:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk I get your point _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tHere is the fix_dd_ You need to actually recompute the normals_dd_ _lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%237_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#7_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-14T17:14:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThankyou_co_ thankyou_co_ thankyou...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI knew it had to be something relatively simple. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-14T20:54:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tIs there a way to recalculate the normals without baking the transform in? The baking process can be very slow on complex meshes (2 to 3 seconds) and it remakes the bounding box which is not ideal. \n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-14T22:06:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think I have a solution. You just need to transform the vertices by the mesh_t_s world matrix like so_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    var worldMatrix _eq_ mesh.computeWorldMatrix()_sm_\n\n    var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind_co_ false_co_ true)_sm_\n    for (var i _eq_ 0_sm_ i &lt_sm_ positions.length / 3_sm_ i++) {\n      var idx _eq_ i * 3_sm_\n      var vertex _eq_ BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.FromArray(positions_co_ idx)_co_ worldMatrix)_sm_\n      positions[idx] _eq_ vertex.x_sm_\n      positions[idx+1] _eq_ vertex.y_sm_\n      positions[idx+2] _eq_ vertex.z_sm_\n    }\n\n    var indices _eq_ mesh.getIndices()_sm_\n\n    var normals _eq_ []_sm_\n    BABYLON.VertexData.ComputeNormals(positions_co_ indices_co_ normals)_sm_\n\n    mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind_co_ normals_co_ true)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt might be good to add an _qt_updateNormals_qt_ to the Mesh class that does this so you don_t_t have to bake the transform every time.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-15T21:43:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tLike the idea _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ fancy doing a PR?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-09-16T05:18:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI would sugget you to NOT create intermediate vector3 during the process by using TransformCoordinatesToRef() instead and by using a single temp Vector3\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//doc.babylonjs.com/classes/3.0/vector3#static-transformcoordinatesfromfloatstoref-x-y-z-transformation-result-rarr-void_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/classes/3.0/vector3#static-transformcoordinatesfromfloatstoref-x-y-z-transformation-result-rarr-void_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tsomething like this _dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind_co_ false_co_ true)_sm_\n      var vertex _eq_ BABYLON.Vector3.Zero()_sm_\n      for (var i _eq_ 0_sm_ i &lt_sm_ positions.length / 3_sm_ i++) {\n      var idx _eq_ i * 3_sm_\n      BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(positions[idx]_co_positions[idx+1]_co_positions[idx+2] _co_ worldMatrix_co_ vertex)_sm_\n      positions[idx] _eq_ vertex.x_sm_\n      positions[idx+1] _eq_ vertex.y_sm_\n      positions[idx+2] _eq_ vertex.z_sm_\n\n    }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-18T21:49:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo_co_ it took me way too long to figure this out_co_ but there_t_s something strange going on with the way mesh.setVerticesData(...NormalKind...) works. It is exaggerating the normals along scaled axes. This is the root cause of the problem. The workaround is to calculate the normals by hand and then divide each component of the vector by the square of the scale in that direction (which is why it took me so long to figure out). This makes our normal updating function look like_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_export function updateNormals(mesh_co_ scene) {\n\n  const worldMatrix _eq_ mesh.computeWorldMatrix(true)_sm_\n\n  const scale _eq_ BABYLON.Vector3.Zero()_sm_\n  worldMatrix.decompose(scale_co_ new BABYLON.Quaternion()_co_ new BABYLON.Vector3())_sm_\n\n  var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind_co_ false_co_ true)_sm_\n  var normals _eq_ []_sm_\n\n  var v1 _eq_ BABYLON.Vector3.Zero()_sm_\n  var v2 _eq_ BABYLON.Vector3.Zero()_sm_\n  var v3 _eq_ BABYLON.Vector3.Zero()_sm_\n  var normal _eq_ BABYLON.Vector3.Zero()_sm_\n\n  for (var i _eq_ 0_sm_ i &lt_sm_ positions.length / 9_sm_ i++) {\n\n    v1 _eq_ BABYLON.Vector3.FromArray(positions_co_ i * 9)_sm_\n    v2 _eq_ BABYLON.Vector3.FromArray(positions_co_ i * 9 + 6)_sm_ // flipped\n    v3 _eq_ BABYLON.Vector3.FromArray(positions_co_ i * 9 + 3)_sm_\n\n    normal _eq_ BABYLON.Vector3.Cross(v1.subtract(v2)_co_ v1.subtract(v3))_sm_\n\n    normal.x /_eq_ scale.x**2_sm_\n    normal.y /_eq_ scale.y**2_sm_\n    normal.z /_eq_ scale.z**2_sm_\n\n    normal _eq_ normal.normalize()_sm_\n\n    //  each normal pushed 3 times_co_ once for each vert\n    normals.push(normal.x)_sm_normals.push(normal.y)_sm_normals.push(normal.z)_sm_\n    normals.push(normal.x)_sm_normals.push(normal.y)_sm_normals.push(normal.z)_sm_\n    normals.push(normal.x)_sm_normals.push(normal.y)_sm_normals.push(normal.z)_sm_\n  }\n  mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind_co_ normals_co_ true)_sm_\n}\n_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tI_t_m happy to do a pr_co_ but this probably isn_t_t the best way to handle this. To me_co_ this is a bug in the babylon code. Somewhere_co_ when it scales a mesh_co_ it_t_s multiplying the normals by the scale twice (or three times) which is what_t_s making scaled meshes look so strange.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-18T22:00:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tBy the way_co_ here_t_s a playground of it working_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%2315_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#15_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-18T23:35:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo getVerticesData does not change the data. It just returns the value of the required vertex buffer. The value is not affected by world matrix.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat you are doing is updating the normals before they will be moved to world with this line_dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/default.vertex.fx#L115_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/default.vertex.fx#L115_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhile it works in your case I_t_m not really convinced it is a general solution.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-19T00:27:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI_t_ll make the pr_co_ then. It just seems strange that we have to _qt_unscale_qt_ the normals before we move them to the mesh. \n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-09-19T15:30:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tMy point is_dd_ I_t_m not sure this is the good reasoning here. Will it work if you apply positioning_co_ rotation AND non uniform scaling?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2017-09-19T15:35:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tWhy are you scaling the normals?  I_t_ve always thought they should just be a 1 unit vector_co_ why all the extra calculations?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-19T15:37:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tYes - that_t_s the whole point. Without this_co_ the normals are not correct_co_ even if you explicitly call to recalculate the normals_co_ they are exaggerated in the in the direction of the scale. This solution is the only way I have come up with to get the normals to be correct. This is why I think this is actually an underlying bug. I_t_ll make a playground to show the problem.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-19T15:38:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_189236_qt_ data-ipsquote-contentid_eq__qt_32913_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1505835350_qt_ data-ipsquote-userid_eq__qt_19199_qt_ data-ipsquote-username_eq__qt_Pryme8_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t2 minutes ago_co_ Pryme8 said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tWhy are you scaling the normals?  I_t_ve always thought they should just be a 1 unit vector_co_ why all the extra calculations?\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tBecause if you don_t_t scale the normals_co_ they are scaled _qt_elsewhere_qt_ and are incorrect. This is the bug I_t_ve been dealing with for days now.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"SvenFrankson","Date":"2017-09-19T15:57:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIsn_t_t it due to the fact the mesh worldMatrix is applied to the normal vector in the shader ? \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSomething like vNormalW _eq_ world * vNormal _co_ but I don_t_t know where it happens when there_t_s not Material assigned. Here maybe ? _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/default.vertex.fx#L115_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/default.vertex.fx#L115_lt_/a_gt_ maybe ? \n_lt_/p_gt_\n\n_lt_table style_eq__qt_background-color_dd_#ffffff_sm_border-collapse_dd_collapse_sm_border-spacing_dd_0px_sm_color_dd_#24292e_sm_font-size_dd_14px_sm__qt__gt__lt_tbody_gt__lt_tr_gt__lt_td style_eq__qt_color_dd_rgba(27_co_31_co_35_co_.3)_sm_font-size_dd_12px_sm_padding_dd_0px 10px_sm_text-align_dd_right_sm_vertical-align_dd_top_sm__qt__gt_\n\t\t\t\t \n\t\t\t_lt_/td_gt_\n\t\t\t_lt_td style_eq__qt_color_dd_#24292e_sm_font-size_dd_12px_sm_padding_dd_0px 10px_sm_vertical-align_dd_top_sm__qt__gt_\n\t\t\t\t_lt_pre_gt_\n_lt_code_gt_#ifdef NORMAL\n\nvNormalW _eq_ normalize(vec3(finalWorld * vec4(normalUpdated_co_ 0.0)))_sm_\n\n#endif_lt_/code_gt__lt_/pre_gt_\n\t\t\t_lt_/td_gt_\n\t\t_lt_/tr_gt__lt_/tbody_gt__lt_/table_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2017-09-19T16:45:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#FDNU12_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#FDNU12_lt_/a_gt__lt_br /_gt__lt_br /_gt_\n\tthe normals do not get scaled...  maybe its in the shader?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-19T16:45:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHere_t_s the issue layed out as best I can. In this playground_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%2324_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#24_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThere are 4 spheres. The underlying geometry for the one on the left is a regular sphere_co_ so there is no scaling applied and it looks as expected.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe other three are flat and have been scaled up 4x in the y to become spherical.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSphere number 2 uses VertexData.ComputeNormals to explicitly calculate the normals. I would expect this method to produce a sphere with exactly the same normals as sphere 1_co_ but it doesn_t_t. The normals are scaled 2x more in the y than they should be (which is why the top and bottom of the sphere look darker). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWith sphere number 3 I calculate the normals explicitly_co_ but again_co_ they seem to be over scaled in the y_co_ this time by the square of the scale factor.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWith sphere number 4_co_ I calculate the normals by hand_co_ then apply the _qt_descaling_qt_ and it looks as expected. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe results are the same if you translate or rotate the spheres. It is only scaling that gives strange results.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt_t_s possible that there_t_s something wrong with my normal calculations_co_ but I_t_ve been banging my head against this for a while and it seems that the way the normals are applied to the mesh is the culprit. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2017-09-19T17:09:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%2325_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#25_lt_/a_gt__lt_br /_gt__lt_br /_gt_\n\tTake a look at the second sphere.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIts because your position calculations are off after the scaling._lt_br /_gt__lt_br /_gt__lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8%2326_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/indexstable#V3A6F8#26_lt_/a_gt__lt_br /_gt__lt_br /_gt__lt_a href_eq__qt_https_dd_//doc.babylonjs.com/overviews/how_rotations_and_translations_work_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/overviews/how_rotations_and_translations_work_lt_/a_gt__lt_br /_gt_\n\tread the section on _qt_Baking Transform_qt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"focomoso","Date":"2017-09-19T17:25:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tThanks Pryme8_co_ but the idea here is to find a solution that doesn_t_t require baking the transform because it takes too long and destroys the local bounding box.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]