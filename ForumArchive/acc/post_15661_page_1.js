[{"Owner":"primesoftware","Date":"2015-07-11T05:44:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello all! I am new around here_co_ but not new to game dev. I was using the Godot engine for a bit_co_ but wasn_t_t happy with it so I switched to Babylon. I need a little help with collisions and ray casting though. I_t_ve combed through all the tutorials and can_t_t seem to get this working. I am loading a scene imported from Blender. In Blender I made a simple Box where I want to cast a ray to when clicked on. Simple picking isn_t_t going to work for me because I only want to perform an action when a small area of larger model is clicked. The Box is not visible_co_ but is registered as a physics object. Clicking the invisible box does not work at all. I just end up hitting the visible model underneath the invisible box._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var canvas_co_ engine_co_ scene_co_ camera_sm_document.addEventListener(_qt_DOMContentLoaded_qt__co_ function () {    if (BABYLON.Engine.isSupported()) {        initScene()_sm_    }}_co_ false)_sm_function initScene() {    canvas _eq_ document.getElementById(_qt_webGLCanvas_qt_)_sm_    engine _eq_ new BABYLON.Engine(canvas_co_ true)_sm_        BABYLON.SceneLoader.Load(_qt_assets/models/_qt__co_ _qt_Gameboard.babylon_qt__co_ engine_co_ function (gameScene) {        gameScene.executeWhenReady(function () {            gameScene.enablePhysics(new BABYLON.Vector3(0_co_ -10_co_ 0)_co_ new BABYLON.OimoJSPlugin())_sm_            gameScene.collisionsEnabled _eq_ true_sm_                        var light _eq_ new BABYLON.PointLight(_qt_light_qt__co_ new BABYLON.Vector3(0_co_ 5_co_ -5)_co_ gameScene)_sm_                        camera _eq_ new BABYLON.FreeCamera(_qt_camera_qt__co_ new BABYLON.Vector3(0_co_ 4_co_ -10)_co_ gameScene)_sm_            camera.setTarget(new BABYLON.Vector3(0_co_ 0_co_ 10))_sm_            camera.attachControl(canvas)_sm_                        var counterHitBox _eq_ gameScene.getMeshByName(_qt_CounterHitBox_qt_)_sm_            counterHitBox.checkCollisions _eq_ true_sm_            counterHitBox.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor_co_ {mass_dd_ 0_co_ friction_dd_ 0.5_co_ restitution_dd_ 0.7})_sm_                        gameScene.onPointerDown _eq_ function (evt) {                var pickResult _eq_ gameScene.pick(gameScene.pointerX_co_ gameScene.pointerY)_sm_                                alert(pickResult.pickedMesh.name)_sm_            }_sm_                        engine.runRenderLoop(function() {                gameScene.render()_sm_            })_sm_        })_sm_    }_co_ function (progress) {        // To do_dd_ give progress feedback to user    })_sm_}_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-07-11T17:40:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello and welcome!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Physics and picking are not related as they do not use the same internal engine. The picking just need you to set mesh.isPickable _eq_ true_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Example here_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#UF7SS_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#UF7SS_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"primesoftware","Date":"2015-07-11T23:46:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_88868_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_15661_qt_ data-ipsquote-username_eq__qt_Deltakosh_qt_ data-cite_eq__qt_Deltakosh_qt_ data-ipsquote-timestamp_eq__qt_1436636420_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Hello and welcome!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Physics and picking are not related as they do not use the same internal engine. The picking just need you to set mesh.isPickable _eq_ true_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Example here_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#UF7SS_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#UF7SS_lt_/a_gt__lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thank you for the welcome! I gave this a try_co_ but it doesn_t_t pick my invisible mesh. The mesh is invisible_co_ but enabled. Does that make a difference? I saw someone else said use the pick function with a predicate. I gave that a try_co_ but it was picking every mesh on the screen even if I didn_t_t click on it._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Edit_dd_ So I figured it out using this thread (_lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/7709-scenepick-a-mesh-that-is-enabled-but-not-visible/_qt__gt_http_dd_//www.html5gamedevs.com/topic/7709-scenepick-a-mesh-that-is-enabled-but-not-visible/_lt_/a_gt_). The predicate function just says which meshes are valid_co_ not which ones were picked. That was why I was getting an alert with all the meshes in my scene. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This code now works_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_            gameScene.onPointerDown _eq_ function (evt) {                var pickResult _eq_ gameScene.pick(gameScene.pointerX_co_ gameScene.pointerY_co_ function(mesh) {                    return mesh.isPickable &amp_sm_&amp_sm_ mesh.isEnabled()_sm_                })_sm_                                alert(pickResult.pickedMesh.name)_sm_            }_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]