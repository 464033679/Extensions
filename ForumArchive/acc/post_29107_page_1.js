[{"Owner":"haestflod","Date":"2017-03-16T15:01:17Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi_co_ so I_t_ve converted Tomas Möller_t_s _lt_span style_eq__qt_font-size_dd_14px_sm__qt__gt__lt_font face_eq__qt_LUCIDA_co_ARIAL_co_HELVETICA_qt__gt_Triangle-Triangle Overlap Test_lt_/font_gt__lt_/span_gt_ code for babylonjs to do precise intersection for 2 meshes._lt_br /_gt__lt_br /_gt_\n\tCurrently the code I have looks like this which uses the triangles in world space. However I figured it_t_d be faster to convert mesh B into mesh As localspace instead.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_\nconst Av _eq_ getTriangles( a )_sm_\nconst Bv _eq_ getTriangles( b )_sm_\n\nfunction getTriangles ( mesh ) {\n\n  const vertices _eq_ mesh.getVerticesData( BABYLON.VertexBuffer.PositionKind )_sm_\n  const indices _eq_ mesh.getIndices()_sm_\n  const worldMatrix _eq_ mesh.getWorldMatrix()_sm_\n\n  let result _eq_ []_sm_\n  // Get all triangles\n  for ( let i _eq_ 0_sm_ i &lt_sm_ indices.length_sm_ ++i ) {\n    let index _eq_ indices[ i ] * 3_sm_\n    let vertex _eq_ new BABYLON.Vector3( vertices[ index ]_co_ vertices[ index + 1 ]_co_ vertices[ index + 2 ] )_sm_\n    BABYLON.Vector3.TransformCoordinatesToRef( vertex_co_ worldMatrix_co_ vertex )_sm_\n\n    result.push( vertex )_sm_\n  }\n\n  return result_sm_\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tWhich for A would skip the transformCoordinates step and for B I would calculate a matrix that looks like this to move B to A_t_s local space_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_matrix _eq_ bWorldMatrix * aInvertedWorldMatrix_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tIs that the way to convert B to A_t_s local space or is it some other way to do it? Or some other better way to get all the triangles for the tri to tri overlap test?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2017-03-16T16:33:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHave you had a look at _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_facetdata_qt_ rel_eq__qt_external nofollow_qt__gt_facetData_lt_/a_gt_? Each facet is a basic triangle that makes up a mesh. It allows you to get local position data\n_lt_/p_gt_\n\n_lt_p_gt_\n\tJerome started it _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/27822-facet-data/_qt_ rel_eq__qt__qt__gt_here_lt_/a_gt_ as a way of bouncing small particles off a mesh and it needs version 3.0-alpha_co_ which the playground uses or for external use you can get it _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/tree/master/dist/preview%20release_qt_ rel_eq__qt_external nofollow_qt__gt_here_lt_/a_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI did some work on using it to find where two meshes intersected but had never heard of Tomas Möller_t_s _lt_span style_eq__qt_font-size_dd_14px_sm__qt__gt__lt_font face_eq__qt_LUCIDA_co_ARIAL_co_HELVETICA_qt__gt_Triangle-Triangle Overlap Test_lt_/font_gt__lt_/span_gt_. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy playground for this is at _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#XEJLM_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#XEJLM_lt_/a_gt_ with words of warning in the posting.\n_lt_/p_gt_\n_lt_iframe data-embedcontent_eq__qt__qt_ frameborder_eq__qt_0_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/28188-intersecting-concave-meshes-and-their-physics/?do_eq_embed_qt__gt__lt_/iframe_gt_\n\n_lt_p_gt_\n\tYou will probably be better starting from scratch.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tGood luck in your project.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"haestflod","Date":"2017-03-16T17:27:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tInteresting_co_ I think in my case it_t_s better to use the current triangle getting logic because I only need the positions and nothing else._lt_br /_gt__lt_br /_gt_\n\tHere_t_s a link to the C or C++ implementation if you_t_re interested_dd__lt_br /_gt__lt_a href_eq__qt_http_dd_//fileadmin.cs.lth.se/cs/personal/tomas_akenine-moller/code/opttritri.txt_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//fileadmin.cs.lth.se/cs/personal/tomas_akenine-moller/code/opttritri.txt_lt_/a_gt__lt_br /_gt__lt_br /_gt_\n\tEdit_dd_ Ended up going with the original solution and not using facetdata._lt_br /_gt_\n\tAs for going from local B -&gt_sm_ local A_dd__lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_// Declared outside function as reusable matrix_dd_\nvar _tmpMatrix _eq_ BABYLON.Matrix.Identity()_sm_\n\n// To convert from localSpace B -&gt_sm_ localSpace B\nlet finalMatrix _eq_ _tmpMatrix_sm_\nconst aWorldMatrix _eq_ a.getWorldMatrix()_sm_\nconst bWorldMatrix _eq_ b.getWorldMatrix()_sm_\n\nlet tmpAInverseWorldMatrix _eq_ BABYLON.Tmp.Matrix[ 0 ]_sm_\n\naWorldMatrix.invertToRef( tmpAInverseWorldMatrix )_sm_\n\nbWorldMatrix.multiplyToRef( tmpAInverseWorldMatrix_co_ finalMatrix )_sm_\n\n\n// Later on when iterating each vertex for mesh b\nBABYLON.Vector3.TransformCoordinatesToRef( vertex_co_ finalMatrix_co_ resultVertex )_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]