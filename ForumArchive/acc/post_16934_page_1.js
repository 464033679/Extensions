[{"Owner":"KevinBLT","Date":"2015-09-04T12:06:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello folks_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_after nearly over an hour of debug action_co_ I found something strange._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I create an object out of some smaller objects using merge._lt_/p_gt__lt_p_gt_After that_co_ I keep one _qt_original_qt_ in background with _qt_isVisible _eq_ false_qt_._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Then_co_ if the settings change_co_ I throw everything away and copy this _qt_original_qt_._lt_/p_gt__lt_p_gt_Set material_co_ size_co_ etc..._lt_/p_gt__lt_p_gt_Then I create instances of this._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But I always had an error within babylon while copy. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The first time it works as expected._lt_/p_gt__lt_p_gt_But the second time I use copy with this _qt_original_qt_ object_co_ I have this error_dd__lt_/p_gt__lt_p_gt_(Line 27524_dd_ CANNOT SET .references OF UNDEFINED #ERROR)_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_for (var kind in this._vertexBuffers) {  if (numOfMeshes _eq__eq__eq_ 1) {    this._vertexBuffers[kind].create()_sm_  }  this._vertexBuffers[kind]._buffer.references _eq_ numOfMeshes_sm_ &lt_sm__eq__eq__eq__eq_ CANNOT SET .references OF UNDEFINED #ERROR  if (kind _eq__eq__eq_ BABYLON.VertexBuffer.PositionKind) {    mesh._resetPointsArrayCache()_sm_    var extend _eq_ BABYLON.Tools.ExtractMinAndMax(this._vertexBuffers[kind].getData()_co_ 0_co_ this._totalVertices)_sm_    mesh._boundingInfo _eq_ new BABYLON.BoundingInfo(extend.minimum_co_ extend.maximum)_sm_    mesh._createGlobalSubMesh()_sm_    //bounding info was just created again_co_ world matrix should be applied again.    mesh._updateBoundingInfo()_sm_  }}_lt_/pre_gt__lt_p_gt_I noticed_co_ that after copy_co_ in Mesh._geometry._meshes a mesh had been added._lt_/p_gt__lt_p_gt_This happend in the new copy as well as in the original one._lt_/p_gt__lt_p_gt_That_t_s the reason the second round it has _qt_numOfMeshes _eq_ 2_qt_ and runs into this error._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have no idea why this happens or why the orignial mesh is affected by copy function?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I ended up with this (ugly) workaround_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_function getBarType2() {  var Clone _eq_ window.BarType2.clone(_qt_Pfosten Typ 2_qt_)_sm_  window.BarType2._geometry._meshes.pop()_sm_  Clone.isVisible _eq_ true_sm_    return Clone_sm_}_lt_/pre_gt__lt_p_gt_With this_co_ it works as expected!_lt_/p_gt__lt_p_gt_Can anyone explain what happens here?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Have a nice day_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Kevin_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"RaananW","Date":"2015-09-04T15:13:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi_co_ _lt_/p_gt__lt_p_gt_To prevent terms confusion (for example_co_ I assume copy means clone?) could you create a playground that reproduces this error? It seems like_co_ for some reason_co_ merging causes it to malfunction._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]