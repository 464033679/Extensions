[{"Owner":"Pryme8","Date":"2018-07-27T18:49:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo_co_ my mind is kinda messed up from this.  It seems to be the opposite of what I was expecting._lt_br /_gt_\n\tSo when a normal map is generated from a black and white image and is set in tangent space does the _qt_raised_qt_ elements look like they are going in or out on the normal map.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo when I generated my normal map initially I just used the values that I used where not inverted and I noticed that the elements seemed to be concave not convex_co_ so I switched my x value to be inverted so on the Shader I output 1.0-x_co_ y_co_ 0.0_co_ 1.0 respectively and it fixed the lighting direction on the mesh_co_ but kept the look of the normal map as inverted like the example below on the left._lt_br /_gt_\n\t_lt_br /_gt_\n\tI then just for experimenting inverted the y as well_co_ and it output the normal map on the right._lt_br /_gt_\n\t_lt_br /_gt_\n\tSo now I am confused_co_ which one is correct?  Cause that_t_s confusing to me that the normal map on the left will look the same with 1.0-x_co_ y will look the same as x_co_y on the normal map image_co_ but when actually applied seems to invert the bump._lt_br /_gt_\n\tHere is a example_dd__lt_br /_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ data-fileid_eq__qt_19416_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_07/nMap.png.04f1311acb7e26c73a5360e995da6775.png_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_nMap.thumb.png.ba12dcdf5df699242d94f31378f5b8d3.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_19416_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_07/nMap.thumb.png.ba12dcdf5df699242d94f31378f5b8d3.png_qt_ /_gt__lt_/a_gt__lt_br /_gt_\n\t_lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_const NormalmapGenerator0 _eq_\n`varying vec2 vUV_sm_\n\nuniform vec2 textureSize_sm_\nuniform sampler2D textureSampler_sm_\n\nvoid main(){\n    vec2 unit _eq_ vec2(1.0)/textureSize_sm_\n    float x _eq_ ((texture2D(textureSampler_co_ vUV+(unit*vec2(-1._co_0.))).r\n    -texture2D(textureSampler_co_ vUV+(unit*vec2(1._co_0.))).r)+1.)*0.5_sm_\n    float y _eq_ ((texture2D(textureSampler_co_ vUV+(unit*vec2(0._co_1.))).r\n    -texture2D(textureSampler_co_ vUV+(unit*vec2(0._co_-1.))).r)+1.)*0.5_sm_\n#if defined(invertDepth)\n    \tgl_FragColor _eq_ vec4(x_co_ y_co_ 1.0_co_ 1.0)_sm_\n#else\n\tgl_FragColor _eq_ vec4(1.0-x_co_ 1.0-y_co_ 1.0_co_ 1.0)_sm_\n#endif\n\n}`_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThere is the shader. So the question comes up now_co_ which is the correct output_co_ if different once will produce the same results but seemly should not... *BRAIN EXPLODING* _lt_br /_gt_\n\t_lt_br /_gt_\n\tvec4(x_co_ y_co_ 1.0_co_ 1.0)_sm__lt_br /_gt_\n\tor _lt_br /_gt_\n\tvec4(1.0-x_co_ y_co_ 1.0_co_ 1.0)_sm__lt_br /_gt_\n\tor_lt_br /_gt_\n\tvec4(x_co_1.0- y_co_ 1.0_co_ 1.0)_sm__lt_br /_gt_\n\tor_lt_br /_gt_\n\tvec4(1.0-x_co_1.0- y_co_ 1.0_co_ 1.0)_sm_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2018-08-01T18:13:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t*UPDATE*\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe answer is _lt_span_gt__dd_ _lt_/span_gt__lt_span style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#353c41_sm_font-size_dd_14px_sm__qt__gt_vec4(1.0-x_co_ y_co_ 1.0_co_ 1.0)_sm__lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]