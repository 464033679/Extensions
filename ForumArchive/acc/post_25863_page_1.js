[{"Owner":"touslecoq","Date":"2016-10-19T23:09:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tFolks\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am not sure whether this is a mathematical limitation or a babylon/javscript limitation (or a touslecoq limitation!).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs part of the app I am developing I am comparing the normals of faces on 2 meshes in order to calculate the angle and axis of rotation required those faces.  This works fine in most cases - however I found in certain cases that the rotation was seemingly random.  Some investigation using the console and I determined that this occurs when the faces being compared are exactly 180 degrees apart.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have created a playground to recreate/illustrate the issue.  This basically\n_lt_/p_gt_\n\n_lt_ul_gt__lt_li_gt_\n\t\tcreates a mesh and rotates randomly in 3 dimensions_sm_\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tcreates a second mesh with exactly the same rotation.  \n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tcalls a function to calculate the normals of a given face (0-12) for each mesh and calculate the angle between those normals and the axis of rotation (ie a vector that is 90 degrees to those normals).  \n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tI call the function twice_dd_\n\t_lt_/li_gt_\n_lt_/ul_gt__lt_ol_gt__lt_li_gt_\n\t\tcomparing Mesh 1_co_ Face 0 with Mesh 2_co_ Face 2 - these faces are on opposite sides of the meshes.  The angle (180 degrees) is correctly determined but the axis is calculated as (0_co_0_co_0).  _lt_u_gt_This I believe is the cause of the strange behaviour I have seen in my app._lt_/u_gt_\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tcomparing Mesh 1_co_ Face 0 with Mesh 2_co_ Face 4 - these faces are on 2 perpendicular sides of the meshes and the angle (90 degrees) and axis are correctly determined\n\t_lt_/li_gt_\n_lt_/ol_gt__lt_p_gt_\n\tSee the console log for the outputs which include the vertices_co_ normals of each selected face and the calculated angle and axis.  Look out for axis _eq_ (0_co_0_co_0) for the second test.  Re-run several times and it gets it wrong consistently.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo ... million dollar (since pound is worthless now) question ... is there a workaround to calculate the normal to 2 vectors that are 180 degrees apart?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2312_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#12_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCheers\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRich\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-10-20T15:38:40Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHey Rich_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthis is expected as there can be an infinity of vectors perpendicular to 2 vectors tat are 180 degrees apart.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tLook at the code of the cross function_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t            Tmp.Vector3[0].x _eq_ left.y * right.z - left.z * right.y_sm__lt_br /_gt_\n\t            Tmp.Vector3[0].y _eq_ left.z * right.x - left.x * right.z_sm__lt_br /_gt_\n\t            Tmp.Vector3[0].z _eq_ left.x * right.y - left.y * right.x_sm_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-20T20:01:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi Deltakosh_co_ thanks.  What you say (with a clear head and a night_t_s sleep) makes perfect sense.  \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo there are 360 degrees worth (infinite as you said) of potential axis and actually any of them would do as what I want to do is to flip the mesh 180 degrees around an axis that is perpendicular to the normal of the selected face.  In which case I can choose either of the vectors that were already used to calculate the normal of that face as the axis.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have updated the playground_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- swapped the tests around so it does the 90 degree test function call first and then the 180 degree test_lt_br /_gt_\n\t- added a condition that if the returned rotation axis was 0_co_0_co_0 then use the m1Vector1 that was one of the vectors used to calculate normal to selected face of mesh 1_lt_br /_gt_\n\t- added a condition so that for the second test it now performs the rotation - should see the red and blue faces parallel if successful_lt_br /_gt_\n\t- added additional log trace to show where the alternative rotation axis has been used and to show the vectors used to calculate the face normals.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow for the weird bit.  If I comment out line 33 (the random rotation of the meshes) then it works fine.  Mesh 1 is rotated 180 degrees so that it faces opposite but parallel direction to mesh2.  The log trace shows that in the second test the faces were 180 degrees apart_co_ that a rotation axis of 0_co_0_co_0 was returned and that the alternative was used succesfully.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever if I uncomment that line so that the mesh1 is randomnly rotated and mesh 2 starts off with same rotation as mesh 1_co_ the rotation does not work and and the boxes do not end up parallel but opposite.  Quite perplexing - if anyone has time can you find my error please _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ - it could be a BABYLON.Space.LOCAL vs .WORLD issue although I have tried both and it didn_t_t work.  I also tried normalizing the vector without luck.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2329_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#29_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRich\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-20T20:26:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk .. so I just realised I had made a schoolboy error in previous version in the test for whether the returned axis was 0_co_0_co_0 - I used the assignment (_eq_) rather than equality (_eq__eq_) operator.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI fixed that and it was no longer matching axis 0_co_0_co_0 so for ease i have changed it to check for rotation angle _eq_ Math.PI.  I was trying to avoid this because a&gt_sm_ requires exact comparison of floating point numbers to many decimal places_sm_ and b&gt_sm_ in my own app the error occurs even at 179.999999... degrees.  However for purposes of this it is fine.T\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRather than the random initial rotation I have rotated both meshes only 90 degrees round x axis to make debugging easier.  Results are weird.  Although the trace identifies correctly that the angle is 180 degrees and chooses the alternative axis and states it is rotating Mesh 1 around that axis 180 degrees.  It only actually seems to rotate it 90 degrees.  Confused!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2339_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#39_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-22T11:33:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tNudge.  Still cannot fathom this ... _dd_/.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2016-10-22T13:26:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYesterday I was thinking about how to do this with the Mesh.lookAt function.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou could figure out the rotation to the face and then the rotation to the point (using Mesh.lookAt) and then get the difference of those to get the final rotation.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-23T22:42:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi Adam thanks for your reply - not 100% sure i understood your suggestion though.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI could use Mesh.lookAt to get the face to look at the other mesh but they wouldn_t_t necessary be pointing in the same/opposite (i.e. parallel) direction afterwards.  So for example if you had one cube at the world origin and another at 100_co_100_co_100 with both cubes in their default orientation.  I *think* using mesh.lookat on the second mesh would result in that mesh rotating to roughly PI/4_co_ PI/4_co_ PI/4 (i.e. diagonally back towards mesh 1) as opposed to 0_co_0_co_PI (i.e. i.e. 180 degree rotation around the z axis so it faces back along the x-axis).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPossibly creating submeshes (i.e. for each face) and using align mesh on those submeshes may work (not sure how mesh.lookAt works in relation to submeshes)?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI could have misunderstood how mesh.lookAt works so the above may not be true.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe reason for this desired behaviour is that I want to rotate the second mesh so that its specified face faces the specified face of the other mesh so that I can then translate the position and align or _qt_mate_qt_ the 2 faces.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe strange thing is - my existing solution seems to work for all other angles its just the exact 180 degree edge case that is the problem. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks_co_ Rich.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-24T22:46:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tUPDATE ...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo I found what to me looks like weird behaviour.  I created a really simple_co_ cut down_co_ version of the playground to demonstrate it.  Not sure if this is the cause of _lt_strong_gt_all_lt_/strong_gt_ of my woes but it does explain some of the odd behaviour seen in posts above...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo this playground 1) creates 2 boxes_co_ 2) sets them both to the same initial rotation (PI/3_co_ PI/3_co_ 0)_sm_ and 3) rotates the first box 180 degrees around its x axis.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI try 2 options for setting initial rotation.  To my eye these are simply 2 ways to write the same code (someone more proficient may disagree)_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOPTION1 (lines 38-41)_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_mesh1.rotation _eq_ new BABYLON.Vector3(Math.PI / 3_co_ Math.PI / 3_co_ 0)_sm_\nmesh2.rotation _eq_ new BABYLON.Vector3(Math.PI / 3_co_ Math.PI / 3_co_ 0)_sm_\nscene.render()_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tOPTION2 (lines 44-46)_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var initialRotation _eq_ new BABYLON.Vector3(Math.PI / 3_co_ Math.PI / 3_co_ 0)_sm_    \nmesh1.rotation _eq_ initialRotation_sm_\nmesh2.rotation _eq_ initialRotation_sm_\nscene.render()_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tWith line 51 (step 3_co_ the 180 degree rotation) commented out_co_ both OPTION1 and OPTION2 work fine and set the initial rotation as expected_dd__lt_br /_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2397_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#97_lt_/a_gt__lt_br /_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2398_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#98_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever with line 51 uncommented in order to perform the 180 degree rotation_co_ OPTION1 works fine (_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%23100_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#100_lt_/a_gt_) but OPTION2  seems to cause mesh1 to lose its initial rotation (_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VFKAZ%2399_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VFKAZ#99_lt_/a_gt_).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis issue is why my previous playgrounds above appeared to be only rotating by 90 degrees and not 180 as expected.  Because mesh 1 was actually losing its initial rotation of 90 degrees and then flipping 180 degrees it was still only 90 degree different to mesh2!!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat am I missing.  Why would the way the initial rotation is set impact the way subsequent rotates are handled?  I don_t_t even know how I would go about debugging this to be honest!?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2016-10-24T23:25:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_148750_qt_ data-ipsquote-contentid_eq__qt_25863_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1477349173_qt_ data-ipsquote-userid_eq__qt_19275_qt_ data-ipsquote-username_eq__qt_touslecoq_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t36 minutes ago_co_ touslecoq said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tTo my eye these are simply 2 ways to write the same code (someone more proficient may disagree)_dd_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tIt_t_s not the same.  You are sharing rotation vector between 2 meshes.  When the rotate function is used_co_ the mesh switches to using rotationQuaternion and zeros out the rotation vector.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-10-25T21:14:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tInteresting_co_ thanks Adam.  \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo when the Rotation attribute is used it doesn_t_t actually apply a rotation (ie doesn_t_t re-calculate and update the vertexData)?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRich\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]