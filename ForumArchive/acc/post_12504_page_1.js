[{"Owner":"fenomas","Date":"2015-02-15T07:07:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi. Are there any guides that comment on how to make Babylon.js perform well?_lt_/p_gt__lt_p_gt_I_t_m wondering about things like_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_What causes a model to require more/fewer draw calls?_lt_/li_gt__lt_li_gt_Does a multi-material mesh perform better than the same model split into several normal meshes?_lt_/li_gt__lt_li_gt_For a static model_co_ does the structure of the data affect performance? For example_co_ if I put all the solid stuff in one child mesh and all the transparent stuff in another_co_ would that be better than mixing them?_lt_/li_gt__lt_li_gt_Is it possible to combine the textures for a particular model into one texture_co_ and sample from it like a texture atlas? If so_co_ would that require fewer draw calls?_lt_/li_gt__lt_/ul_gt__lt_p_gt_Stuff like that. I couldn_t_t find any documents that comment on this._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If nothing else_co_ just an explanation of what causes BJS to separate draw calls would be really helpful._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"davrous","Date":"2015-02-15T10:08:54Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi_co__lt_/p_gt__lt_p_gt_ You can use our debug layer to better understand what cause slowdowns by enabling/disabling features_dd_ _lt_a href_eq__qt_http_dd_//babylondoc.azurewebsites.net/page.php?p_eq_22611_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//babylondoc.azurewebsites.net/page.php?p_eq_22611_lt_/a_gt__lt_/p_gt__lt_p_gt_ You can even go further by coupling it with user marks_dd_ _lt_a href_eq__qt_http_dd_//blogs.msdn.com/b/eternalcoding/archive/2015/02/02/using-user-mark-to-analyze-performance-of-your-javascript-code.aspx_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//blogs.msdn.com/b/eternalcoding/archive/2015/02/02/using-user-mark-to-analyze-performance-of-your-javascript-code.aspx_lt_/a_gt__lt_/p_gt__lt_p_gt_ To answer your question_co_ you should indeed group static geometries and use multimaterials. Michel_co_ our 3D artist_co_ has done a very interesting talk on how he optimized the Hill Valley scene_dd_ _lt_a href_eq__qt_https_dd_//m.youtube.com/watch?v_eq_ObZX541I-Tk_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//m.youtube.com/watch?v_eq_ObZX541I-Tk_lt_/a_gt__lt_/p_gt__lt_p_gt_Bye_co__lt_/p_gt__lt_p_gt_David_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-15T16:22:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks for the link! I found it a bit hard to follow_co_ since it was mainly about optimizing things in 3D modeling tools. I_t_m working with babylon APIs._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_There was a part in the middle where he went through an Autodesk process to collapse several materials into one. Is that what happens if I use submeshes in BJS? That is_co_ if I have a mesh with N child meshes_co_ each with its own material_co_ and that takes N draw calls_co_ should merging them into one multimaterial will reduce it to one draw?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-02-15T18:59:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Unfortunately no_co_ because each material requires a reset of the WebGL state. If many objects uses many materials there is no easy way to optimize because each object will need a reset hence a draw call_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-15T19:08:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I see_co_ thanks Delta. In that case_co_ what is the advantage for merging meshes and using multimaterials?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Wouldn_t_t it be preferable to split up the mesh_co_ and join together the parts that share a material?_lt_/p_gt__lt_p_gt_That is_co_ if each material causes a new draw call_co_ is it not best to consolidate all static parts of a scene that use the same material?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-02-15T19:24:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_To reduce draw calls_co_ ideally you should just have one big mesh with several submeshes (one per material)_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The minimum draw calls you can have is equal to the number of active materials_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-16T02:12:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I see_co_ thank you. So it sounds like using multi-materials doesn_t_t necessarily affect performance. _lt_/p_gt__lt_p_gt_In that case_co_ in the Hill Valley talk where Michel talked about merging complex models into one mesh_co_ can you tell me what was happening on the API side? Was it basically merging textures into an atlas and updating the model_t_s uvs? _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-16T05:21:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_And another follow-up_dd_ is there any case where two different meshes (with the same material) are drawn in one call?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Or is the minimum number of draws equal to (number of meshes) * (number of materials used per mesh)?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-17T09:19:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi.. Perhaps I my question could be clearer with a concrete example. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Suppose I_t_m rendering Minecraft terrain in BJS. The terrain is split into chunks_co_ and each chunk contains various different kinds of blocks_co_ with different textures. Supposing that 100 chunks are drawn_co_ and each has 10 different kinds of blocks_co_ is there any way to avoid needing 1000 draw calls to rendering this terrain?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-17T09:46:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well I guess you could easily go down to 10 draw calls by instancing these 10 base blocks._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I don_t_t know much about multi materials and submeshes_co_ but I know for sure that instancing is insanely useful when you need to render a lot of simple stuff on screen._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Edit_dd_ I just realized that you may have meant that each chunk has unique blocks to it... then yes simple instancing would in theory give 1000 draw calls. Hmm_co_ not sure then_co_ sorry _dd_/_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-17T10:10:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Also Minecraft uses one big texture atlas for all its blocks. So in theory your scene may contain only one material (if you can fit everything in it_co_ which may not be possible in a practical case)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_And if i_t_m understanding what Deltakosh said_co_ then if you set all the blocks of the scene as submeshes of one big mesh_co_ you may after all end up with only one big draw call... On the other hand_co_ doing this would not draw benefit from the mesh instancing system. That may be costly if you_t_re drawing thousands of cubes on screen._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Otherwise_co_ if you indeed have 1000 unique meshes _lt_u_gt_on screen_lt_/u_gt__co_ and you want to use instances_co_ I guess you_t_ll have to make those 1000 draw calls. Although it remains an extreme case in my opinion. Even Minecraft which is a pretty complex game has something like 150 unique block types_co_ and can probably get away with no more than 50 unique types rendered at a time._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-17T10:11:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_72238_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12504_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1424166382_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Well I guess you could easily go down to 10 draw calls by instancing these 10 base blocks._lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you draw a mesh for every block_co_ then I guess instancing would work_co_ but the number of polys would get pretty crazy. For this reason Minecraft-style engines usually reduce the polygon count by joining neighboring blocks of the same type. If you google image search on _qt_greedy meshing_qt_ you_t_ll see what I mean._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In _qt_real_qt_ voxel engines I assume they solve this problem by joining the (tiny) terrain textures into an atlas_co_ and drawing all terrain from that single texture. I don_t_t know if that_t_s possible in BJS? Alternately_co_ if there_t_s some fancy way to batch-draw several meshes that all use the same texture? Or some other approach.._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-17T18:49:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_72240_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12504_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1424167848_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Also Minecraft uses one big texture atlas for all its blocks. So in theory your scene may contain only one material (if you can fit everything in it_co_ which may not be possible in a practical case)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_And if i_t_m understanding what Deltakosh said_co_ then if you set all the blocks of the scene as submeshes of one big mesh_co_ you may after all end up with only one big draw call... On the other hand_co_ doing this would not draw benefit from the mesh instancing system. That may be costly if you_t_re drawing thousands of cubes on screen._lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Sorry_co_ I hadn_t_t seen your edit or other reply yet._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_To clarify_co_ I_t_m just talking about something equivalent to Minecraft_co_ so only a few dozen kinds of blocks. I know MC uses an atlas_co_ what I don_t_t know is whether that could be done programmatically in BJS._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As for making things submeshes of one big mesh_co_ the hierarchy of meshes doesn_t_t affect the number of draw calls_co_ does it? At least I couldn_t_t find a way to_co_ other than actually merging geometries._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-17T22:30:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well you can most definitely creates meshes for each block types you want_co_ use one material for all of them and set their UV coordinates according to their texture_t_s position on the atlas. If your question is_dd_ can I define meshes by code_co_ setting position and UV data for each vertex_co_ then the anwser is yes _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But as you point it out_co_ rendering vast amount of landmass based on voxels will probably need heavy meshing algorithms like the one you mentioned. So instancing won_t_t be that useful here._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As for submeshes_co_ I_t_m not familiar enough with this system_co_ so I won_t_t risk giving a false answer_co_ sorry!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-18T02:53:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_72346_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12504_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1424212223_qt__gt__lt_div_gt__lt_p_gt_If your question is_dd_ can I define meshes by code_co_ setting position and UV data for each vertex_co_ then the anwser is yes _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_No_co_ that_t_s the part I_t_ve already done. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_My question is_co_ how can I render a hundred chunks_co_ each with a dozen block types_co_ without needing a thousand draw calls? _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-18T08:16:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok then!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_How about_dd_ each time a new chunk is loaded_co_ its blocks are merged into a few large meshes with an algorithm like _lt_a href_eq__qt_http_dd_//0fps.net/2012/07/07/meshing-minecraft-part-2/_qt_ rel_eq__qt_external nofollow_qt__gt_greedy meshing_lt_/a_gt_. Hidden blocks are culled. All blocks of the same type are part of the same mesh._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Then_co_ all those big meshes are assigned the same material. They will also be assigned a _qt_texture index_qt__co_ which corresponds to the texture that will be used in the atlas._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The material used will have to use a custom shader that will repeat the selected part of the atlas along the whole mesh. This way_co_ you won_t_t have to stich together all the small textures into a big one used for rendering._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I found _lt_a href_eq__qt_http_dd_//0fps.net/2013/07/09/texture-atlases-wrapping-and-mip-mapping/_qt_ rel_eq__qt_external nofollow_qt__gt_this article_lt_/a_gt_ on the same site_co_ which is pretty interesting and has a very good example of what I mean._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also you_t_d have to handle the modification of chunks. Rebuilding the merged meshes each time might be too costly_co_ I_t_m not sure... Have you tried looking at how minecraft does it by activating wireframe in it?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-18T08:41:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi_co_ thanks for the reply. _lt_/p_gt__lt_p_gt_Apart from using a texture atlas_co_ I_t_m already doing everything you_t_ve described - greedy meshing_co_ managing chunks_co_ etc. _lt_/p_gt__lt_p_gt_Basically_co_ since I_t_m dynamically generating all the meshes and textures and uvs etc_co_ I thought there might be a best-practices way to structure the data so that it scaled better than the naive way. But it sounds like maybe not? _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-18T09:12:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Not that I know of... It seems you already did quite some work on optimization_co_ so I_t_m not sure I have any relevant advice to give you!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Do you have a specific performance problem or an identified bottleneck_co_ like too many draw calls ? or too many vertices ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ some more suggestions that come to my mind_dd__lt_/p_gt__lt_p_gt_- it seems you_t_re not using instanced meshes in your project. Although merging meshes might be useful for when many similar blocks are next to each other_co_ instanced meshes would definitely be better for isolated blocks. Also it will allow you to more easily modify your chunk topology. Instanced meshes are_lt_strong_gt_ VERY_lt_/strong_gt_ fast. Rendering hundreds of thousands of triangles is completely doable with it._lt_/p_gt__lt_p_gt_- in a minecraft-like game_co_ most of the rendering time will probably be spent on the background_co_ especially if you want nice &amp_sm_ far landscapes. I think rendering the background might need a different technique_co_ for example using vertex colors instead of textures for blocks_co_ maybe even sprites? Also_co_ simplifying chunks that are far away should be doable with the right algorithm._lt_/p_gt__lt_p_gt_- BJS offers an octree system to speed mesh culling operations_sm_ have you looked into that? _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/wiki/Optimizing-performances-with-octrees_qt_ rel_eq__qt_external nofollow_qt__gt_link_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m actually very interested in this whole topic (as you may have seen)_co_ since heavy optimization is an absolute necessity when creating a large-scale game._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-02-18T15:40:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I read most of this thread_co_ then did a search for the words GPU_co_ CPU_co_ &amp_sm_ latency.  None were found.  I think much of the key to merging meshes for the reduction GPU calls is_dd_ the latency of the CPU to GPU call.  The larger the amount of work done by an individual call_co_ the fewer calls that need to be made.  Each call has a latency which stalls all the shaders_co_ so it is advisable to make them count._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If by dynamic generation_co_ vertex data is changed often is meant_co_ e.g. morphing_co_ then more than a gl.DrawArrays is required.  CPU to GPU data transfer is expensive.  BABYLON.Mesh.MergeMeshes() is not possible for these. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I am not familiar with how hardware acceleration of Instances works_co_ but probably not want to merge them.  I wonder if clones are mergeable?  _lt_/p_gt__lt_p_gt_VertexData._ExtractFrom() does check isVerticesDataPresent()_co_ but not clear._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If I may rephrase your best-practices request_co_ I would like it spelled out all the instances where merging meshes WILL NOT work.  Is it has updateable vertice data_co_ instances_co_ clones_co_ has matricesWeights &amp_sm_ matricesIndices_co_ or changes (scale_co_ position_co_ or rotation)?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-18T16:41:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_72411_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12504_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1424250729_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Do you have a specific performance problem or an identified bottleneck_co_ like too many draw calls ? or too many vertices ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ some more suggestions that come to my mind_dd__lt_/p_gt__lt_p_gt_- it seems you_t_re not using instanced meshes in your project..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m actually very interested in this whole topic (as you may have seen)_co_ since heavy optimization is an absolute necessity when creating a large-scale game._lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have not stress tested yet_co_ but I noticed that naively producing a Minecraft-sized world would conservatively need tens of thousands of draw calls just for terrain_co_ so I wanted to look for better ways. Regarding instances_co_ I don_t_t know if it might work in some cases_co_ but in my case I have implemented AO. So I couldn_t_t just have an instance for every _qt_grass_qt_ blockface_co_ I_t_d need a set. I imagine lighting would be a problem as well (I mean MC-style where lighting is part of the vertex colors or material. I assume instances don_t_t have those_co_ right?)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As for scaling_co_ I guess maybe texture atlas is the only real solution for something like this. Not that I_t_m eager to write shaders.._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-18T22:02:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_72489_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12504_qt_ data-ipsquote-username_eq__qt_fenomas_qt_ data-cite_eq__qt_fenomas_qt_ data-ipsquote-timestamp_eq__qt_1424277673_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Regarding instances_co_ I don_t_t know if it might work in some cases_co_ but in my case I have implemented AO. So I couldn_t_t just have an instance for every _qt_grass_qt_ blockface_co_ I_t_d need a set. I imagine lighting would be a problem as well (I mean MC-style where lighting is part of the vertex colors or material. I assume instances don_t_t have those_co_ right?)_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Ha! Hadn_t_t thought of that. Seriously though_co_ all these issues have been tackled in Minecraft so I think a very good thing to do (if not already done) would be to try and figure out how that works._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Instances all share the same material_co_ and I haven_t_t find a way to define custom properties on them that may be used in the material_t_s shader program. So changing vertex color will be an issue with them. I guess it kind of rules this solution out._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Ok so let_t_s keep greedy meshing as the first step of the optimization. This is basically a simple way of reducing the number of vertices. Then_co_ you will have to take that draw call count down_co_ as well as reducing the amount of CPU to GPU calls_co_ like JCPalmer said. To do that_co_ I guess you will have to merge geometry at some point_dd_ this way_co_ each GPU buffer will contain as many blocks as possible_co_ and all these will be rendered in one draw call._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As a first approach_co_ I_t_d say_dd_ merge each chunk as one big mesh. Using submeshes will improve the culling of its blocks_co_ but that can come later. Then_co_ I can think of 2 methods_dd__lt_/p_gt__lt_p_gt_1. allow some chunks to become _t_active_t__co_ meaning that they_t_re not just one big mesh but several smaller_co_ separate meshes. Chunks can for example be marked as active when a player or NPC capable of modifying blocks is into them._lt_/p_gt__lt_p_gt_2. keep the _t_one chunk _eq_ one mesh_t_ system all the time. When a block is modified in a chunk_co_ go and update only the specific part of the GPU buffers to reflect that change in the chunk geometry. Even better_dd_ batch modifications so you don_t_t do 10 CPU to GPU calls each frame_co_ but wait for a frame or two to gather as much geometry change as possible_co_ and then inject them in the GPU buffers in one quick move._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As to _t_how to do it in BJS_t__co_ here is _lt_a href_eq__qt_http_dd_//www.pixelcodr.com/tutos/trees/trees.html_qt_ rel_eq__qt_external nofollow_qt__gt_a link to a great article_lt_/a_gt_ by Temechon in case you need it._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What do you think? Is that giving you any lead?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-19T03:48:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Jahow_co_ thank you for the reply but what you_t_re describing amounts to using larger chunks_co_ or variable sized chunks. And certainly that might help_co_ but it_t_s orthogonal to BJS._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Basically my goal here was to find out whether I_t_m overlooking any _lt_em_gt_BJS features_lt_/em_gt_ that allow minecraft-style rendering to scale better. Such as_co_ a way to speed up rendering when lots of meshes share a material_co_ or a way to preprocess multiple textures into one material (which is what minecraft does_co_ and voxel.js_co_ and I assume other engines)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If there aren_t_t_co_ then naturally when I hit a bottleneck I will have to simplify the data or use fewer materials. (Or implement my own texture atlases...)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-19T06:42:54Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Actually_co_ look back over this I_t_m still confused on one point._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Can anyone confirm why it_t_s beneficial to use submeshes and multi-materials?_lt_/p_gt__lt_p_gt_In my testing the number of draw calls is the same either way_co_ but is there some other benefit?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-02-19T09:41:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hey_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Using submeshes will improve partial mesh culling and collision detection_dd_ by using an octree_co_ BJS will be able to speed up these computations._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Other tools BJS provides that may help you improve performance_co_ that I know of_dd__lt_/p_gt__lt_p_gt_- scene octree_lt_/p_gt__lt_p_gt_- instancing_lt_/p_gt__lt_p_gt_- _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/page.php?p_eq_22581_qt_ rel_eq__qt_external nofollow_qt__gt_scene optimizer_lt_/a_gt__lt_/p_gt__lt_p_gt_- _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/page.php?p_eq_22581_qt_ rel_eq__qt_external nofollow_qt__gt_level-of-detail_lt_/a_gt_ &amp_sm_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/page.php?p_eq_24841_qt_ rel_eq__qt_external nofollow_qt__gt_in-browser mesh simplification_lt_/a_gt__lt_/p_gt__lt_p_gt_- mesh merging_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Hope that finally answers your question _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-02-19T12:56:31Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hm. Well_co_ I don_t_t think any of those apply_co_ so I guess that would depend on whether your list is exhaustive. I think probably my initial question here was too vague. Now that we have narrowed down the problem_co_ maybe I_t_d better post a follow-up. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks for helping refine the problem!  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]