[{"Owner":"touslecoq","Date":"2016-03-04T14:27:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHey guys I am trying to figure something out.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have a scene with a handful of identically sized boxes that can be moved around and rotated independently.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen I move a box I can check which other box is closest to it and whether it is _qt_in range_qt_ (ie distance is less than a set value) by checking distance between currentBox.position and each boxes.position.  If they are in range then I can highlight it somehow (currently I set .visibility on both boxes to 0.5).  This works quite well.  When boxes are moved out of range again they become unhighlighted (ie .visibility_eq_1 is set to 1)_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever I want to make it more specific and highlight the specific face on each box that are closest.  Context_dd_ this is a first step to creating a kind of _qt_snap-to_qt_ function that will allow boxes to be snapped together without needing user to accurately rotate and align the boxes.  So user moves box A within range of box B_co_ the closest faces are highlighted and then when mouse button is released they snap together with Box A translating automatically to align with Box B.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI started by adapting the boxes at point of creation to contain subMeshes for each side.  The intention here was to use the method above but instead of iterating through each box in my boxes array_co_ was to iterate through each subMesh in each box in my array and apply the same logic to determine their distance.  However the snag ... subMesh has no _qt_.position_qt_ member so comparing currentBox.subMesh.position with boxes[j].subMesh[k].position does not work.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have a sinking feeling I am going to have to compare the sets of vertices that make up each face/side of each  box.  Not only is this more comparisons to perform on each move of the mouse and therefore a potential performance hit_co_ but it also leads to some pretty complicated logic.  In other words what is the criteria for nearest face .. I can_t_t say _qt_if the four vertices outlining a box side are all closes to the four vertices on a particular side of my currentBox_qt_ as if the box faces are not parallel you could find that the _qt_nearest face_qt_ actually has some of its vertices that are further away from currentBox face than some other faces.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ll try and work up a quick playground to demonstrate what I mean but while I do_co_ has anyone done this before?  I cannot find anything on search her or google but it seems that it must have been thought about before?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks in advance_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRichard\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-03-04T14:54:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tExample to highlight nearest whole box to the box being moved_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#2ILHWS%233_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#2ILHWS#3_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNote that contrary to my original post_co_ the selected box (ie the one that is being moved around) is _qt_highlighted_qt_ until mouse up rather than just when in range.  The other box is only highlighted whilst in range.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2016-03-04T14:58:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tMy first thought is to cast a ray between each of the objects.  If there is a hit_co_ I believe you can easily get the face from the hit info.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2016-03-04T15:05:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHere is a PG that uses BABYLON.Ray_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#QM57B_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#QM57B_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-03-04T15:08:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAdam_co_ thanks for quick response.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThat could work although would need to work out where to cast the ray from/to.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you cast from currentBox.position (ie centre of selected box) and it intersects another box and find the shortest distance to point of intersection (and choose that face) would that always be the _qt_nearest face_qt_ from a snap-to perspective. For example if 2 boxes were aligned on 2 axis but offset on the third.  The 2 parallel axis would be the obvious ones to snap to from the users point of view yet the ray could cast through the perpendicular face instead.  It needs to be intuitive to the user_co_ but I will play with that idea though.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy other thought was to write a function to calculate the centre position of each face/submesh based on its vertices and do the comparisons that way.  Compare distance between each face on currentBox (or cast the ray from that centre point).  Its just in the interest of the app remaining fluid I want to limit the number of calculations its performing on mouse move as much as possible.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"touslecoq","Date":"2016-03-04T15:10:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThanks again - that will save me some hunting!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"NasimiAsl","Date":"2016-03-07T20:08:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\ti think you can find that with other way(no picking)\n_lt_/p_gt_\n\n_lt_p_gt_\n\twith render target and depth material this is possible and i think it faster than picking _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt_true_qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt__gt__lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]