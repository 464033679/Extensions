[{"Owner":"JCPalmer","Date":"2016-01-04T19:30:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I do not see where AnimationRanges can be placed in a .babylon file.  Just thinking out loud_co_ but this might a method of implementing the export of Actions in Blender_co_ which are also named.  I got 90% down the Mocap path using a .bvh_co_ and am just making sure I am really going the right way.  (Questioning myself usually happens when I stopping on something for a while_co_ holidays)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The really big reason I went the mocap route is to try to reduce say a 2 second walk @ 120 fps to maybe 5 poses_co_ where the frame number indicates the relative amount of time to interpolate to each pose.  I have code which is starting to do that analysis.  Frame based animation is not scalable_co_ because it _qt_performs_qt_ the animation externally (pose&gt_sm_&gt_sm_Animation&gt_sm_&gt_sm_Bake Action) &amp_sm_ the file size just explodes. I have no intention of using it._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I know Blender had a way of actually posing skeletons on just the key frames_co_ but until I actually started playing with inverse kinematics_co_ posing was impossible._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have performed tests in python &amp_sm_ can determine which frames the poses occur in an action.  I think I can @ the skeleton level_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_iterate through the actions_lt_/li_gt__lt_li_gt_get the key frames of an action_lt_/li_gt__lt_li_gt_iterate through those frames_lt_/li_gt__lt_li_gt_get the bone matrix of each bone_lt_/li_gt__lt_/ul_gt__lt_p_gt_If going to a .babylon / BJS_co_ just make sure every action was baked.  If going to .js / QueuedInterpolation_co_ skip the bake.  Either way_co_ both should able to get multiple animations via AnimationRanges if they can be put in a .babylon.  Also_co_ right now the animation is captured by iterating through every frame in the scene for _lt_strong_gt_EVERY_lt_/strong_gt_ bone.  Blends with skeletal animation export very slowing.  One with a 32 bone skeleton should get a 32x speed up when exporting_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you have a skeleton you are going to use in a .blend all by itself_co_ then you could add your actions to it.  You can then add those actions to any other .blend using File&gt_sm_&gt_sm_append.  This separates the animation from the character._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What am I thinking that is wrong?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-01-04T19:55:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If we want animation ranges we need to add a new placeholder for them alongside animations (like at the end_co_ after the keys for instance) I see no problem with this idea_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2016-01-04T20:17:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co_ the range info would need to stored in skeleton during pass 1.  It would then need to be passed to each bone_t_s to_script_file() / to_scene_file() method.  Not a big deal_co_ since these are called within the skeleton_t_s writing method.  What is 2.3 production timeframe?  Will add lines to Skeleton.Parse untested if close.  The .babylon format is usually developed after the .js works_co_ not concurrent._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2016-01-06T22:04:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I implement the deletion of frames of a range in Animation_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_public deleteRange(name_dd_ string_co_ deleteFrames?_dd_ boolean)_dd_ void {    for (var index _eq_ 0_sm_ index &lt_sm_ this._ranges.length_sm_ index++) {        if (this._ranges[index].name _eq__eq__eq_ name) {            if (deleteFrames) {                var from _eq_ this._ranges[index].from_sm_                var to _eq_ this._ranges[index].to_sm_                 // this loop MUST go high to low for multiple splices to work                for (var key _eq_ this._keys.length - 1_sm_ key &gt_sm__eq_ 0_sm_ key--) {                    if (this._keys[key].frame &gt_sm__eq_ from  &amp_sm_&amp_sm_ this._keys[key].frame &lt_sm__eq_ to) {                       this._keys.splice(key_co_ 1)_sm_                     }                }            }            this._ranges.splice(index_co_ 1)_sm_            return_sm_        }    }}_lt_/pre_gt__lt_p_gt_For a whole skeleton_co_ I added this in Skeleton_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_public removeAnimationRange(rangeName _dd_ string)_dd_ void {    for (var i _eq_ 0_co_ nBones _eq_ this.bones.length_sm_ i &lt_sm_ nBones_sm_ i++) {        this.bones[i].animations[0].deleteRange(rangeName_co_ true)_sm_    }}_lt_/pre_gt__lt_p_gt_I implemented copyAnimationRange in both bone &amp_sm_ skeleton.  Skeleton_t_s call each bones as they were matched up between skeletons._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I added range parsing / serializing to Animation &amp_sm_ hand edited a .babylon to add one._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_When I went to change the html_co_ it is started in skeleton.  I looked both skeleton &amp_sm_ animation have _ranges.  In order for this to work I need to also parse / serialize at skeleton and change my removeAnimationRange_co_ and put the code inside skeleton.deleteRange.  Right???_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-01-07T16:11:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Correct_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2016-01-07T17:02:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_As you know_co_ I never wait for answers.  Over night_co_ I cam to the same conclusion.  Done_co_ now in test._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I made it so that skeleton.createAnimationRange()_co_ skeleton.deleteAnimationRange()_co_ also did the same to each bone_t_s animations[0].  The skeleton.Parse calls createAnimationRange()_co_ so the range need only be at the skeleton level in the JSON._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This is a new feature for 2.3_co_ so I made a couple of minor changes before they get locked in._lt_/p_gt__lt_ul_gt__lt_li_gt_deleteFrames arg of deleteRange() is now default true.  Seems to only keep when explicitly requested._lt_/li_gt__lt_li_gt_changed implementation of ranges- _ranges _dd_ { [name_dd_ string] _dd_ AnimationRange_sm_ } _eq_ {}_sm__lt_/li_gt__lt_/ul_gt__lt_p_gt_Since a name was always being passed to calls_co_ you can easily access without looping.  Avoids writing loops to validate a range does not already exist in Parse from JSON.  This can occur if a scene serialized_co_ then reloaded._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_A little more testing_co_ then PR._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-01-08T15:49:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_And do not forget to credit yourself in what_t_s new _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2016-01-08T22:12:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yeah_co_ I have a few todo_co_ mostly all related to skeletons_dd_ this_co_ variableBoneInfluencer_co_ Blender exporter.  Will do all at the same time._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Making good progress in Actions support in Blender.  Made this python class_co_ AnimationRange_co_ which has a static actionPrep method which makes the passed in action the current action.  It figures the frames based on _t_includeAllFrames_t_ returns an AnimationRange instance._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_class AnimationRange_dd_    # constructor called by the static actionPrep method    def __init__(self_co_ name_co_ frames_co_ frameOffset)_dd_        self.name _eq_ name        self.highest_frame _eq_ frames[len(frames) - 1]        self.frame_start _eq_ frameOffset + frames[0]        self.frame_end   _eq_ frameOffset + self.highest_frame        self.frames _eq_ frames# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    # assume the following JS variables have already been declared_dd_ skeleton. animation    def to_script_file(self_co_ file_handler_co_ indent_co_ isSkeleton)_dd_        func _eq_ _t_skeleton.createAnimationRange_t_ if isSkeleton else _t_animation.createRange_t_        file_handler.write(indent + func + _t_(_qt__t_ + self.name + _t__qt__co_ _t_ + format_int(self.frame_start) + _t__co_ _t_ + format_int(self.frame_start) + _t_)_sm_\\n_t_)# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    @staticmethod    def actionPrep(object_co_ action_co_ includeAllFrames_co_ frameOffset_co_ attrInBlender _eq_ None)_dd_        # assign the action &amp_sm_ test if there is any data for that action for this object        object.animation_data.action _eq_ action        if len(object.animation_data.action.fcurves) _eq__eq_ 0_dd_            return None                if includeAllFrames_dd_            frame_start_co_ frame_end _eq_ [int(x) for x in action.frame_range]            frames _eq_ range(frame_start_co_ frame_end        else_dd_            # capture built up from fcurves            frames _eq_ dict()            for fcurve in object.animation_data.action.fcurves_dd_                if attrInBlender !_eq_ None and fcurve.data_path !_eq_ attrInBlender_dd_                    continue                                for key in fcurve.keyframe_points_dd_                    frame _eq_ key.co.x                    frames[frame] _eq_ True                                # check that there were frames for this attribute            if (len(frames) _eq__eq_ 0)_dd_                return None                               frames _eq_ sorted(frames)                    return AnimationRange(action.name_co_ frames_co_ frameOffset)_lt_/pre_gt__lt_p_gt_This worked with my preminary test.  The really good thing is you do not have to bake your skeleton poses_co_ in fact you _lt_strong_gt_NEVER SHOULD_lt_/strong_gt__co_ even when going to a .babylon.  This will simply _t_run_t_ the animation and snap the matrices at that point.  If you bake the poses &amp_sm_ save the .blend then you cannot edit the key frames_co_ or copy the action as easily._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I also pulled iterating through the scene animation at the skeleton level_co_ not bone_co_ and did speed up._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Finally_co_ The Mesh_co_ Camera_co_ Light animations will have ranges.  I am wondering if node.ts should convenience AnimationRanges like Skeleton?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]