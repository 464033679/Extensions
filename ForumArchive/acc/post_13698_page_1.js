[{"Owner":"JCPalmer","Date":"2015-04-07T20:38:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I am trying to implement a modal stack of dialogs.  The 2nd dialog pushed on the stack works (layermask of 0 hides 1st dialog).  When the _qt_OK_qt_ button is clicked_co_ the assigned callback makes a call which_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_pops the dialog (mesh) off the stack_lt_/li_gt__lt_li_gt_var ret _eq_ popped.modalReturnedValue // for return_lt_/li_gt__lt_li_gt_calls popped._lt_strong_gt_dispose()_lt_/strong_gt__lt_/li_gt__lt_li_gt_makes the current top visible again_lt_/li_gt__lt_li_gt_current.modalReturnedValue _eq_ ret_lt_/li_gt__lt_li_gt_calls current.modalReturnCallBack_co_ if set_lt_/li_gt__lt_/ul_gt__lt_p_gt_Was getting _qt__lt_strong_gt_TypeError_dd_  this._geometry is null_lt_/strong_gt__qt_ in mesh._bind.  The scene is then frozen.  The 2nd dialog is still there_co_ no first dialog re-appearance._lt_/p_gt__lt_p_gt_Thought I might have code doing stuff with disposed meshes_co_ so I just set a var to only queue disposal.  These _qt_top level_qt_ dialogs have a before renderer_co_ so it checks for the var next call &amp_sm_ does it there.  Same result._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Modified _bind to write to console the effect &amp_sm_ mesh name when geometry is null.  Got the _qt_top level_qt_ mesh that has the beforerenderer &amp_sm_ the effect was _qt_default_qt_. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The closest I can do is to call a method I have_co_ called removeAll(). It does not dispose() the caller itself.  Then hide it.  Anything I could differently?_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_private _beforeRender() _dd_ void {    if (this._queueDispose){        this.removeAll()_sm_        this.setLayerMask(0)_sm_                    }else if (this._dirty){          this.layout()_sm_    }}_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-08T03:38:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Just a wild guess_co_ but mesh.beforeRender takes place during the scene_t_s render operation_co_ right? And I_t_d think that disposing stuff halfway through a render would be generally unsafe. Did you try disposing stuff in the scene_t_s beforeRender_co_ or a tick function outside the render loop?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-04-08T14:00:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks_co_ that was enough for me to figure it out.  This topic also answers the Jeopardy question_dd_  Why are there _lt_strong_gt_after_lt_/strong_gt_ render entry points?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Disposal is back in the button callback itself.  Button callbacks _lt_strong_gt_were_lt_/strong_gt_ actually happening in a before renderer.  This was for look and feel.  The pick callback would change the border material to orange &amp_sm_ start the wait clock.  After at least 1000 / 60 milli the before renderer would actual run the application callback_co_ then change the material back.  Moving disposal to the top level_t_s before renderer just moved the problem._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As an after render_co_ no timing required_co_ a single frame occurred with the border orange._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]