[{"Owner":"jerome","Date":"2015-12-29T16:13:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_et voilà _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%230_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#0_lt_/a_gt_    60 fps on my fast laptop_lt_/p_gt__lt_p_gt_[EDIT _dd_ 60 fps also on my old laptop !]_lt_/p_gt__lt_p_gt_the same with the legacy method _lt_em_gt_getHeightAtCoordinates()_lt_/em_gt_ _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#1_lt_/a_gt_ less than 1 fps !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Here there are 400 balls in a SPS. You can change this number at the line 131_lt_/p_gt__lt_p_gt_You can also change the size and the number of map subdivisions at the line 108-110. This shouldn_t_t alter the speed of altitude computation_co_ only the the time needed to precompute the array._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Under the hood_co_ an array of quads (sized subdivisions * subdivisions) is created._lt_/p_gt__lt_p_gt_It is populated with  some quad elements._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Remember this schema _dd__lt_/p_gt__lt_p_gt_a quad is two triangular facets._lt_/p_gt__lt_p_gt_We know the 2d coordinates (x_co_z) of the point P(x_co_z) and we want to know its y_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_V1 ----- V2_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|  \\          |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|   \\         |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|    \\        |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|     \\       |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|      \\      |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|       \\     |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_|        \\    |_lt_/p_gt__lt_p style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_V3----- V4_lt_/p_gt__lt_p_gt_So a quad element of the array is _dd__lt_/p_gt__lt_p_gt_- a vector2 (c_co_ h) _dd_ the slope (V1V4) 2D line equation cx + h _eq_ z_co_ used to check if P(x_co_z) in the facet 1 or in the facet 2_co_ or_co_ in other words_co_ if P is under or above the line V1V4 in the plane xOz._lt_/p_gt__lt_p_gt_- two vector4 (a_co_b_co_c_co_d) defining the two facet 3D plane equations _dd_ ax + by + cz + d _eq_ 0_co_ simply computed from their respective normal vectors._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So when you pass the (x_co_z) coordinates_co_ the algo retrieves directly by its index the related quad in the array_co_ checks what facet the point P(x_co_z) belongs to and then just apply the facet plane equation to (x_co_ z) to compute y._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_No iteration at all once the array is populated. Just a comparison and an operation... very very fast ! _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ex _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#2_lt_/a_gt__lt_/p_gt__lt_p_gt_600 balls still run at 60 fps on my recent laptop (50 fps on the old one)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%233_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#3_lt_/a_gt__lt_/p_gt__lt_p_gt_800 balls_co_ 200 subdivisions _eq_&gt_sm_ 60 fps _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ (33 fps on the old one)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Actually_co_ I guess the limitation is more due to the big sps rendering than to the altitude computation_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-29T19:30:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Note _dd_ there_t_s no physics engine in the former example._lt_/p_gt__lt_p_gt_The balls just roll until the map bounds and go in the other way (bounce ?) when they reach them._lt_/p_gt__lt_p_gt_Obviously they follow the map relief also... what was the goal of the exercice  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_[EDIT] can_t_t stop playing_lt_/p_gt__lt_p_gt_2000 balls_lt_/p_gt__lt_p_gt_60 fps_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%234_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#4_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"RaananW","Date":"2015-12-29T20:50:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yo! Math-meister J! this is totally awesome _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-12-29T21:21:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_SPS is REALLY powerful!!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-29T21:27:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Actually_co_ the SPS does nothing more than usually _dd_ animating solid particles._lt_/p_gt__lt_p_gt_The new stuff here is the way the altitude from the map is computed without using any ray intersection_co_ but just the facet plane equations instead._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-12-29T22:02:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_You are too modest_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"MarianG","Date":"2015-12-29T22:20:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Wonderfull  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-30T08:55:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt__qt_modesty_qt_ ? I don_t_t even know the word  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_No_co_ what I meant is that the gain was got in this example by both local methods_lt_em_gt_ computeHeightMapQuads() / getAltitudeAt() _lt_/em_gt_used instead the legacy _lt_em_gt_getHeightAtCoordinates()._lt_/em_gt__lt_/p_gt__lt_p_gt_Under the hood _dd_ knowledge of the map geometry + plane equation precomputation vs 3D ray intersection_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You would have got the same gain by using standard meshes_co_ instances or clones instead of the SPS._lt_/p_gt__lt_p_gt_I used the SPS only to deal with a big amount of balls in order to stress the altitude computation._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_same with just a little big balls on a big map to understand better how they roll _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%235_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#5_lt_/a_gt__lt_/p_gt__lt_p_gt_[edit] more didactic example with wireframe and only 20 subdivisions so the facets are well visible _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1QC4YQ%236_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1QC4YQ#6_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-12-30T15:44:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_It could be interesting to add these functions to GroundMesh_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-30T17:08:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I_t_m thinking about it._lt_/p_gt__lt_p_gt_The method _lt_em_gt_getAltitudeAt()_lt_/em_gt_ has to know about the ground geometry because it links the quad array indexes to the x_co_z coordinates to be ultra-fast and do no iteration at all._lt_/p_gt__lt_p_gt_All the magic is here _dd__lt_/p_gt__lt_p_gt_BJS groundMap (x_co_ z) geometry _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L1316_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L1316_lt_/a_gt__lt_/p_gt__lt_p_gt_quad retriever _dd_ _lt_/p_gt__lt_div_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_    var col _eq_ Math.floor((x + options.width / 2) * options.subdivisions / options.width)_sm_    var row _eq_ Math.floor(-(z + options.height / 2) * options.subdivisions / options.height + options.subdivisions)_sm_    var quad _eq_ quads[row * options.subdivisions + col]_sm__lt_/pre_gt__lt_p_gt_As you can see_co_ it_t_s just the inverse computation _dd_ (row_co_ col) _eq_&gt_sm_ (x_co_ z) vs (x_co_z) _eq_&gt_sm_ (row_co_ col)_lt_/p_gt__lt_/div_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I need to check if all the ground types in the GroundMesh (in particular_co_ tiledGround) share the same way to build their geometries or else if there_t_s a way to generalize this kind of access._lt_/p_gt__lt_p_gt_If not_co_ this method would work only for heightmap-like ground _dd_ heightmap_co_ ground_co_ ribbon ... successive quads with vertex reuse._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As a side note_co_ this feature creates an array sized subdivisions * subdivisions. So it can be a big array and I want the user to explicitly ask for this creation when creating the ground because of the RAM used._lt_/p_gt__lt_p_gt_This could be an option _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_createGroundHeightMap(name_co_ url_co_ {withAltitudeArray_dd_ true}_co_ scene)_sm__lt_/pre_gt__lt_p_gt_In brief_co_ if the user needs to get the height only for one mesh or only sometimes and wants to spare memory_co_ he would use the legagy method _lt_em_gt_getHeightAtCoordinates()_lt_/em_gt_ emitting a ray._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But if he needs a permanent usage of the map altitudes (many meshes_co_ many access or performance) but with the related spent memory_co_ he would then use _lt_em_gt_getAltitudeAt() _lt_/em_gt_ using the quad array._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-30T19:29:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Like Raanan suggested_co_ another lead would be _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_- to keep a reference to the image buffer with the height map ground object_lt_/p_gt__lt_p_gt_- to convert the coordinates (x_co_ z) of the point P to 2d coordinates into the canvas image and to get the pixel color values_lt_/p_gt__lt_p_gt_- to reconvert these pixel values to y value_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_pro _dd_ no need for an extra array_co_ not that much computation so maybe barely slower than the former process_lt_/p_gt__lt_p_gt_con _dd_ works only for image based grounds_co_ need for keeping the buffer (to be compared in term of memory used by the array) that won_t_t be garbage collected_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_note _dd_ I can_t_t see that the 2d canvas is deleted in the current code_co_ so I guess the buffer memory stays allocated anyway after the 3d ground is created_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_note2 _dd_ The array of the former process is sized _lt_em_gt_subdivisions_lt_/em_gt_ * _lt_em_gt_subdivisions_lt_/em_gt__lt_/p_gt__lt_p_gt_So the memory used is directly a function of the number of subdivisions _eq_ _lt_em_gt_subdivisions_lt_/em_gt_ * _lt_em_gt_subdivisions * (sizeof_Vector2 + _lt_/em_gt__lt_em_gt_sizeof_Vector4 + _lt_/em_gt__lt_em_gt_sizeof_Vector4)_lt_/em_gt__lt_/p_gt__lt_p_gt_Then_co_ if the size of a js float is 4 bytes_co_ the array memory should be _eq__lt_/p_gt__lt_p_gt__lt_em_gt_sub_lt_/em_gt_ * _lt_em_gt_sub_lt_/em_gt_ * (2 * 4 + 2 * 4 * 4) _eq_ _lt_em_gt_sub_lt_/em_gt_ * _lt_em_gt_sub_lt_/em_gt_ * 40 bytes_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The size of the buffer is_co_ I guess_co_ its number of pixels times four _eq_ 4 * width * height bytes_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So in term of memory_co_ the array process is always worth it roughly as soon as width * height &gt_sm_ 10 * subdivisions *subdivisions_lt_/p_gt__lt_p_gt_If the image is squared _dd_ width _eq_ height _eq_ side pixels_lt_/p_gt__lt_p_gt_this means that we need subdivisions _eq_&lt_sm_  side / 10  to ever get a smaller array than the image memory._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_example _dd_ if the image is a square of 300 pixels per side_co_ and if you set 30 subdivisions_co_ the array size is smaller than the image size._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Just to understand what quantities we are talking about _dd__lt_/p_gt__lt_p_gt_If you set 100 subdivisions_co_ the array will be sized _dd_ 100 * 100 * 40 _eq_ 400 000 bytes_co_ so 390 Kb_lt_/p_gt__lt_p_gt_If you set 50 subdivisions_co_ the array is _dd_ 50 * 50 * 40 _eq_ 100 000 bytes_co_ so 97 Kb_lt_/p_gt__lt_p_gt_It_t_s easy to compare to the image size then._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-31T08:32:31Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Just a question _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_is the current method _lt_em_gt_getHeightAtCoordinates()_lt_/em_gt_ pertinent for the other mesh types than height map grounds ?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-12-31T11:08:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_After reading the code of the different ground types_co_ it seems that _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_the height map ground and the standard ground share exactly the same geometry so the method getAltitude should work out of the box for both_lt_/p_gt__lt_p_gt_the tiled ground has a different geometry (more internal subdivisions)_lt_/p_gt__lt_p_gt_only the heightmap ground has a height_co_ it is to say y values different from zero_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So_co_ as far as I understand_co_ the current method _lt_em_gt_getHeightAtCoordinates()_lt_/em_gt_ makes sense only for the height map ground. _lt_/p_gt__lt_p_gt_Then I could add the method _lt_em_gt_getAltitudeAt()_lt_/em_gt_ in the class GroundMesh at the same level and usage than _lt_em_gt_getHeightAtCoordinates()_co_ _lt_/em_gt_knowing that the results could be weird for a tiled map because they aren_t_t that pertinent._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As a side note_co_ the method _lt_em_gt_getAltitudeAt() _lt_/em_gt_should work also for a ribbon out of the box_co_ if this ribbon is built like a map (stripes along x and z with an altitude along y)._lt_/p_gt__lt_p_gt_But as it is a only for a specific case of ribbon_co_ I don_t_t guess it_t_s worth it to implement it at the Ribbon level. _lt_/p_gt__lt_p_gt_Instead_co_ I think I will provide also the function in vanilla js as it is in the _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/UserFunctions_qt_ rel_eq__qt_external nofollow_qt__gt_Userfunctions extension_lt_/a_gt_ so people will be able to use it for their own needs on something else than a heightmap._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-01-01T15:58:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_@DK _dd_ unless you prefer that I change the current _lt_em_gt_getHeightAtCoordinates()_lt_/em_gt_ directly by this algo ? knowing it won_t_t be pertinent for tiled grounds ..._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-01-03T13:39:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_continued here _dd_ _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/19615-getaltitudeat/?p_eq_111174_qt__gt_http_dd_//www.html5gamedevs.com/topic/19615-getaltitudeat/?p_eq_111174_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]