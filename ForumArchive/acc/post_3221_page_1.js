[{"Owner":"lethe","Date":"2014-01-20T15:44:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have two scenes that need to be combined using a non-trivial filter - currently I have set it up such that the first scene is rendered into a RenderTargetTexture_co_ whilst the second is applied to the canvas object to render normally_co_ but with a PostProcess effect applied_co_ which takes in the first scenes texture as one of its samplers. Problem is_co_ I can find no way to arrange for the first scene be rendered ready for the filter (or indeed_co_ be rendered at all) - the only example I can find (the water tutorial) demonstrates how to have an offscreen buffer rendered before a material is used_co_ but not before a post processing effect is used. Anyone know how to do this?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks in advance _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Folowup_dd__lt_/p_gt__lt_p_gt_I have found one approach that almost works - put a PassPostProcess on the first scene_co_ then call render twice in the engine.runRenderLoop function - for the first scene and then the second scene. Using the setTextureFromPostProcess method in the post processor of the second scene makes the output of both scenes avaliable... unfortunatly the alpha for both appears to be set to 1_co_ which is an issue_co_ as I need that to merge the two scenes!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-01-20T22:51:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_This is an interesting request _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I think you are almost done_dd__lt_/p_gt__lt_p_gt_Set a passPostProcess on first scene and render it_lt_/p_gt__lt_p_gt_Set a custom postprocess for the scene scene_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Should look like that for 2nd scene_dd__lt_/p_gt__lt_div_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var postProcess1 _eq_ new BABYLON.PostProcess(_qt_Final compose_qt__co_ _qt_./compose_qt__co_ []_co_ [_qt_sceneSampler0_qt_]_co_ 1_co_ camera)_sm_postProcess1.onApply _eq_ function (effect) {        effect.setTextureFromPostProcess(_qt_sceneSampler0_qt__co_ postProcess0ForScene0)_sm_    }_sm__lt_/pre_gt__lt_/div_gt__lt_p_gt_The custom shader is quite simple_dd__lt_/p_gt__lt_div_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_#ifdef GL_ESprecision mediump float_sm_#endif// Samplersvarying vec2 vUV_sm_uniform sampler2D textureSampler_sm_uniform sampler2D sceneSampler0_sm_// Parametersuniform vec2 screenSize_sm_void main(void) {vec4 orig _eq_ texture2D(sceneSampler0_co_ vUV)_sm_vec4 dest _eq_ texture2D(textureSampler_co_ vUV)_sm_vec4 final _eq_ orig * 0.5 + dest * 0.5_sm_final.a _eq_ 1.0_sm_gl_FragColor _eq_ final_sm_}_lt_/pre_gt__lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"lethe","Date":"2014-01-21T10:53:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks_co_ though I had got that far (few subtle differences_co_ but basically the same). Problem is I really need the alpha from the first scene to do the merge (Scene 1 is rendered additively_co_ then only copied into scene 2 when above a threshold - I am in effect doing a visual intersection operation. I can think of other approaches_co_ but this seemed to be the simplest_co_ at least when I started!)_co_ and its not available for some reason - it appears to be fixed at 1_co_ even though I have explicitly set it otherwise. Any ideas? Its quite hard to follow all the state changes involved by reading the engine_t_s code!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Edit_dd_ Ok_co_ it appears that calling_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_scene.clearColor _eq_ new BABYLON.Color4(0_co_ 0_co_ 0_co_ 0)_sm__lt_/pre_gt__lt_p_gt_does not in fact result in the alpha buffer being set to zero_co_ but leaves it at one_co_ hence my above problem. No idea why - I have traced through the engine and the call sequence looks correct. All I know is that if I set it to 0 using a shader that works_co_ and my code does what I want it to! So_co_ problem solved for me_co_ but I expect this is indicative of a bug somewhere._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Further edit_dd__lt_/p_gt__lt_p_gt_Bug was staring me in the face - you use the line_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_this._gl.clearColor(color.r_co_ color.g_co_ color.b_co_ color.a || 1.0)_sm__lt_/pre_gt__lt_p_gt_in babylon.engine.js. (0.0 || 1.0)  evaluates to 1.0_co_ whilst (1e-12 || 1.0) evaluates to 1e-12_co_ hence I can fix my problem with_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_scene.clearColor _eq_ new BABYLON.Color4(0_co_ 0_co_ 0_co_ 1e-12)_sm__lt_/pre_gt__lt_p_gt_(1e-12 rounds down to 0 when dumped in an 8 bit uint)_lt_/p_gt__lt_p_gt_This is a bug that needs fixing_co_ but then that is easy enough - just check if color.a is a number or not_co_ rather than relying on the weird behaviour of || !_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-01-22T00:00:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Will do the fix right now_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]