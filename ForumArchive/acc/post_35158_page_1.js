[{"Owner":"r3dwolf","Date":"2018-01-18T13:27:41Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_Hello_co__lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_I have to load a file composed of several concatenated mesh file._lt_/span_gt__lt_/span_gt__lt_br /_gt__lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_I need the meshes to be progressively displayed as soon as they are available_lt_/span_gt__lt_/span_gt_ _lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt__co_ how can I do?_lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-01-18T18:04:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHave you tried\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBABYLON.SceneLoader.ShowLoadingScreen _eq_ False_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tEdit_dd_ Also make sure you start your renderloop_co_ before starting the SceneLoader.Append()\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2018-01-18T18:13:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHave you had a look at the  _lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/how_to_use_assetsmanager#how-to-load-files-with-assests-manager_qt_ rel_eq__qt_external nofollow_qt__gt_assetsManager_lt_/a_gt_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/classes/3.1/assetsmanager_qt_ rel_eq__qt_external nofollow_qt__gt_API_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tProvided the meshes are named you can load each mesh from the same file with separate tasks.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou might also be interested in this _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/32480-loading-asynchronous-objects-into-array-for-later-use/?do_eq_findComment&amp_sm_comment_eq_187590_qt_ rel_eq__qt__qt__gt_topic_lt_/a_gt_ where imported meshes are stored in an array.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"r3dwolf","Date":"2018-01-23T15:44:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThanks @JCPalmer and @JonhK\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_Obviously I disabled the loading screen and started the rendering cycle_co_ but the meshes were still displayed only once the whole file had been processed._lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_Unfortunately it is not a .babylon file but a custom file_lt_/span_gt__lt_/span_gt_ _lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_that must be read sequentially_lt_/span_gt__lt_/span_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_I solved the problem by using an async function with a wait function (Promise) of 1ms each cycle(mesh)_lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-01-23T17:52:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThis might also have to do with textures which are done after geometry.  One other way to create the effect is to not start the render loop till ready_co_ disable all meshes (in Blender you can disable in the .babylon file).  When everything is ready_co_ start the render loop which enables one mesh disabled per render.  When none still disabled found_co_ stop checking.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var allLoaded _eq_ false_sm_\nengine.runRenderLoop(function () {\n     if (!allLoaded){\n         var foundDisabled _eq_ true_sm_\n         for (var i _eq_ 0_co_ n _eq_ scene.meshes.length_sm_ i &lt_sm_ n_sm_ i++){\n             if (!scene.meshes[i].isEnabled) {\n                 scene.meshes[i].setEnabled _eq_ true_sm_\n                 foundDisabled  _eq_ true_sm_\n                 break_sm_\n             }\n         }\n         allLoaded _eq_ !foundDisabled_sm_\n     }\n     scene.render()_sm_\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Boz","Date":"2018-01-23T19:12:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDon_t_t you want to initialize foundDisabled to false ? Nice answer anyway\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"r3dwolf","Date":"2018-01-24T10:32:16Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_Thanks_co_ @JCPalmer_co_ that solution may be good in some cases but it is an aesthetic solution._lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt_With the async function the meshes are loaded as soon as they are processed and therefore there is a perception of higher loading speed_lt_/span_gt__lt_/span_gt_ _lt_span lang_eq__qt_en_qt_ xml_dd_lang_eq__qt_en_qt__gt__lt_span_gt__co_ which was my goal_lt_/span_gt__lt_/span_gt_.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_function sleep(ms) {\n        return new Promise(resolve _eq_&gt_sm_ setTimeout(resolve_co_ ms))_sm_\n    }\n\n    async function MeshManagerLoadMeshes(binaryBuffer) {\n        while (binaryBuffer.offset &lt_sm_ binaryBuffer.buffer.length) {\n            &lt_sm_read and parse mesh&gt_sm_\n            await sleep(1)_sm_\n        }\n    }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]