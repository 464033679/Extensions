[{"Owner":"JCPalmer","Date":"2015-03-12T15:00:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_As of BJS 2.0_co_ cloning was moved up into the constructor.  This enabled cloning of Mesh sub-classes.  I found still another issue trying implement a MeshFactory though_dd__lt_/p_gt__lt_p_gt_    If the first instance_co_ used as a reference for cloning_co_ is disposed of_co_ then _lt_strong_gt__lt_span style_eq__qt_font-family_dd_arial_co_ helvetica_co_ sans-serif_sm__qt__gt__geometry _eq_ null_sm__lt_/span_gt__lt_/strong_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This instance can no-longer be used for cloning_co_ even though there could be other instances still using the geometry.  I would like to add a reference var_co_ _lt_span style_eq__qt_font-family_dd_arial_co_ helvetica_co_ sans-serif_sm__qt__gt__lt_strong_gt__geoRefForCloning_lt_/strong_gt__lt_/span_gt__co_ assigned the same value as _lt_span style_eq__qt_font-family_dd_arial_co_ helvetica_co_ sans-serif_sm__qt__gt__lt_strong_gt__geometry_lt_/strong_gt__lt_/span_gt_.  This would be the variable used for cloning_co_ and not set to null in dispose._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have a work around for Tower of Babel_co_ which I mocked up below_co_ that puts _lt_span style_eq__qt_font-family_dd_arial_co_ helvetica_co_ sans-serif_sm__qt__gt__lt_strong_gt__geoRefForCloning_lt_/strong_gt__lt_/span_gt_ in the sub-class_co_ but thought it seemed a bit forced._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_// File generated with Tower of Babel version_dd_ 2.0.0 on 03/12/15module CheckBoxFont{    var meshLib _eq_ new Array&lt_sm_BABYLON.Mesh&gt_sm_(4)_sm_    var cloneCount _eq_ 1_sm_    export class MeshFactory implements TOWER_OF_BABEL.FactoryModule {        constructor(private _scene _dd_ BABYLON.Scene_co_ materialsRootDir_dd_ string _eq_ _qt_./_qt_) {            CheckBoxFont.defineMaterials(_scene_co_ materialsRootDir)_sm_ //embedded version check        }        public getModuleName() _dd_ string { return _qt_CheckBoxFont_qt__sm_}        public instance(meshName _dd_ string_co_ cloneSkeleton? _dd_ boolean) _dd_ BABYLON.Mesh {            var ret_dd_BABYLON.Mesh _eq_ null_sm_            var src_dd_BABYLON.Mesh_sm_            switch (meshName){                case _qt_unchecked2D_qt__dd_                    src _eq_ meshLib[0]_sm_                    if (!src || src _eq__eq__eq_ null){                        ret _eq_ new unchecked2D(_qt_unchecked2D_qt__co_ this._scene)_sm_                        meshLib[0] _eq_ ret_sm_                    }else ret _eq_ new unchecked2D(_qt_unchecked2D_qt_ + _qt___qt_ + cloneCount++_co_ this._scene_co_ null_co_ &lt_sm_unchecked2D&gt_sm_ src)_sm_                    break_sm_                    ...            }            if (ret !_eq__eq_ null){                if (cloneSkeleton &amp_sm_&amp_sm_ src &amp_sm_&amp_sm_ src.skeleton){                    var skelName _eq_ src.skeleton.name + cloneCount_sm_                    ret.skeleton _eq_ src.skeleton.clone(skelName_co_ skelName)_sm_                }            }            else BABYLON.Tools.Error(_qt_Mesh not found_dd_ _qt_ + meshName)_sm_            return ret_sm_        }    }    export class unchecked2D extends DIALOG.Letter {        public _geoRefForCloning _dd_ any_sm_                constructor(name_dd_ string_co_ scene_dd_ BABYLON.Scene_co_ materialsRootDir_dd_ string _eq_ _qt_./_qt__co_ source? _dd_ unchecked2D) {            super(name_co_ scene_co_ null_co_ source_co_ true)_sm_            CheckBoxFont.defineMaterials(scene_co_ materialsRootDir)_sm_ //embedded version check                        var cloning _eq_ source &amp_sm_&amp_sm_ source !_eq__eq_ null_sm_            if (cloning){                if (!this.geometry){                    source._geoRefForCloning.applyToMesh(this)_sm_                }            } else {                this._geoRefForCloning _eq_ this.geometry_sm_            }            ...        }        public dispose(doNotRecurse?_dd_ boolean)_dd_ void {            super.dispose(doNotRecurse)_sm_            if (this._geoRefForCloning.isDisposed() ) meshLib[0] _eq_ null_sm_        }    }    ...}_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-03-13T15:11:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well_co_ have found a better solution_co_ but still without modifying BJS.  Output can still work with BJS 2.0.  FYI_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Changed module internal array of references to clone to an array of arrays.  Object references are cheap_co_ but now can draw on any still living mesh for geometry_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var meshLib _eq_ new Array&lt_sm_Array&lt_sm_BABYLON.Mesh&gt_sm_&gt_sm_(number_of_clonable_meshes)_sm__lt_/pre_gt__lt_p_gt_Added 2 module internal functions to get a mesh for cloning &amp_sm_ cleaning up_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_function getViable(libIdx _dd_ number) _dd_ BABYLON.Mesh {    var meshes _eq_ meshLib[libIdx]_sm_    if (!meshes  || meshes _eq__eq__eq_ null){        if (!meshes) meshLib[libIdx] _eq_ new Array&lt_sm_BABYLON.Mesh&gt_sm_()_sm_        return null_sm_    }            for (var i _eq_ meshes.length - 1_sm_ i &gt_sm__eq_ 0_sm_ i--){        if (meshes[i].geometry) return meshes[i]_sm_    }    return null_sm_}function clean(libIdx _dd_ number) _dd_ void {    var meshes _eq_ meshLib[libIdx]_sm_    if (!meshes  || meshes _eq__eq__eq_ null) return_sm_           var stillViable _eq_ false_sm_    for (var i _eq_ meshes.length - 1_sm_ i &gt_sm__eq_ 0_sm_ i--){        if (!meshes[i].geometry) meshes[i] _eq_ null_sm_        else stillViable _eq_ true_sm_    }    if (!stillViable) meshLib[libIdx] _eq_ null_sm_}_lt_/pre_gt__lt_p_gt_The case for getting an instance of each class was changed slightly to_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_case _qt_unchecked2D_qt__dd_    src _eq_ getViable(0)_sm_    if (src _eq__eq__eq_ null){        ret _eq_ new unchecked2D(_qt_unchecked2D_qt__co_ this._scene)_sm_        meshLib[0].push(ret)_sm_    }else ret _eq_ new unchecked2D(_qt_unchecked2D_qt_ + _qt___qt_ + cloneCount++_co_ this._scene_co_ null_co_ &lt_sm_unchecked2D&gt_sm_ src)_sm_    break_sm__lt_/pre_gt__lt_p_gt_Finally_co_ overridden dispose() in each class now_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_public dispose(doNotRecurse?_dd_ boolean)_dd_ void {    super.dispose(doNotRecurse)_sm_    clean(0)_sm_}_lt_/pre_gt__lt_p_gt_These changes were done manually to a previously generated source file.  Think Tower of Babel 2.0 will finally be done once this is implemented in python._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-03-13T22:00:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Oh smart_dd_)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]