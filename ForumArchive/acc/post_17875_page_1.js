[{"Owner":"JCPalmer","Date":"2015-10-14T22:05:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Carnegie Mellon has a whole library of motion capture files for their 31 bone skeleton _lt_a href_eq__qt_http_dd_//mocap.cs.cmu.edu_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//mocap.cs.cmu.edu_lt_/a_gt_.  The acm zip file is over 1gb.  It is output in a number of formats.  acm is the only non-binary format_co_ so it should be easiest to work with._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I am thinking about a class which will process one of these files into the animation for each bone_co_ after removing as many frames as possible.  What I have so far_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_module MORPH{    export class Mocap{        private _boneNames _eq_ {}_sm_ // format  is _qt_rclavicle_qt__dd_ 1        private _animation _dd_ Array&lt_sm_BABYLON.Animation&gt_sm__sm_                constructor(acmFile _dd_ string_co_ frameRate _eq_ 120_co_ toleranceToStripFrame _eq_ 0){            // Todo_dd_ read the acm file and parse to members            // remove as many frames as possible_co_ working backwards_sm_ final frame must be provided        }                /** Memory efficient reference copying of a Mocap animation to a skeleton.          */        public transferAnimations(destSkeleton_dd_ BABYLON.Skeleton_co_ animationIdx _eq_ 0){               var destBones _eq_ destSkeleton.bones_sm_            var nBones _eq_ destBones.length_sm_            for (var i _eq_ 0_sm_ i &lt_sm_ nBones_sm_ i++){                var boneIdx _eq_ this._boneNames[destBones[i].name]_sm_                if (typeof boneIdx _eq__eq__eq_ _qt_undefined_qt_){                    BABYLON.Tools.Error(_qt_Mocap_dd_ not same rig_qt_)_sm_                    return_sm_                }                destBones[i].animations.splice(animationIdx_co_ 0_co_ this._animation[boneIdx])_sm_            }        }    }}_lt_/pre_gt__lt_p_gt_Make Human can rig using this_co_ so seems to be worth looking into.  One problem is a small # of vertices need more than 4 influencers.  This is not a problem as long as I use software skinning (probably going to have to for mobile anyway)_co_ and do not compress my mesh weights.  Tower of Babel does not do this_co_ so still good._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Would have to put in a subclass_co_ so applySkeleton could be over ridden (thinking about variable length influencers).  Still Good._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Not sure how to take the root element &amp_sm_ combine with each bone to make a frame.  Any ideas? Here is the first frame of a file_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_#!OML_dd_ASF H_dd_\\Terrain\\Patient Classification 1\\Walking\\liu\\liu.ASF_dd_FULLY-SPECIFIED_dd_DEGREES1root 8.87208 15.7511 -31.7081 5.5217 4.9122 3.70117lowerback -6.36782 -4.70696 -6.683upperback -0.643012 -5.87124 2.06862thorax 3.78681 -3.04691 5.29674lowerneck -24.0759 -2.27082 -11.0665upperneck 24.0856 -2.48175 11.8592head 12.2401 -0.563692 6.00894rclavicle -2.43511e-015 -1.90833e-014rhumerus -44.9636 -1.75199 -74.7834rradius 18.5852rwrist -1.70884rhand -28.8562 -18.8005rfingers 7.12502rthumb -2.21279 -48.7688lclavicle -2.43511e-015 -1.90833e-014lhumerus -1.92727 -17.3217 82.8203lradius 47.7499lwrist 17.0419lhand -19.6688 -28.7993lfingers 7.12502lthumb 6.65951 1.07601rfemur -38.858 0.527314 17.3997rtibia 30.0014rfoot -4.01149 0.174858rtoes -20.7668lfemur 24.5842 9.53209 -22.1071ltibia -1.90833e-014lfoot -3.73452 -5.77693ltoes -22.05172..._lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-14T22:28:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Woot..there are 6 values for root...position and rotation?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-15T15:04:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Nice guess.  Seems there is also a .asf file that goes with the .amc files.  Here is s stripped down version describing only 2 of the bones _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_# AST/ASF file generated using VICON BodyLanguage# -----------------------------------------------_dd_version 1.10_dd_name VICON_dd_units  mass 1.0  length 0.45  angle deg_dd_documentation   .ast/.asf automatically generated from VICON data using   VICON BodyBuilder and BodyLanguage model FoxedUp or BRILLIANT.MOD_dd_root   order TX TY TZ RX RY RZ   axis XYZ   position 0 0 0     orientation 0 0 0 _dd_bonedata  begin     id 1      name lhipjoint     direction 0.692024 -0.648617 0.316857      length 2.68184      axis 0 0 0  XYZ  end  begin     id 2      name lfemur     direction 0.34202 -0.939693 0       length 6.92462       axis 0 0 20  XYZ    dof rx ry rz    limits (-160.0 20.0)           (-70.0 70.0)           (-60.0 70.0)  end  ..._dd_hierarchy  begin    root lhipjoint rhipjoint lowerback    lhipjoint lfemur    lfemur ltibia    ltibia lfoot    lfoot ltoes    rhipjoint rfemur    rfemur rtibia    rtibia rfoot    rfoot rtoes    lowerback upperback    upperback thorax    thorax lowerneck lclavicle rclavicle    lowerneck upperneck    upperneck head    lclavicle lhumerus    lhumerus lradius    lradius lwrist    lwrist lhand lthumb    lhand lfingers    rclavicle rhumerus    rhumerus rradius    rradius rwrist    rwrist rhand rthumb_lt_/pre_gt__lt_p_gt_I am hoping that at least 1 of the formats from this DB can be loaded into Blender.  Then I could generate an export.  This could be compared to my processing to know If I am doing it right._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ I now think compressed matricesIndices is not really a problem for variable influencers_co_ so long as they are padded out to be an even multiple of 4.  TOB is still not doing to do it though_co_ since I do not want replicate the code to undo it as in line source._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I never really like this format difference TOB &amp_sm_ JSON variants being handled in pass 1 of  python script.  Going to make pass 1 store all influencers in variable length format (a 0 weight being the delimiter).  Provide 2 functions in both variants which get called in pass 2_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_toFixedInfluencers(nFixed)_lt_/li_gt__lt_li_gt_compressMatrixIndices()_lt_/li_gt__lt_/ul_gt__lt_p_gt_No one probably knows what I am talking about.  Just talking to myself._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-15T17:19:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Update_dd_  I am not working on the Mocap class yet.  I have ran a Make Human mesh though the exporter with the CMU rig_co_ writing of variable # of influencers. I captured some really interesting statistics in the log file_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_Avg # of influencers per vertex_dd_  2.361660439260002Highest # of influencers_dd_  7_lt_/pre_gt__lt_p_gt_If this is representative at all_co_ sounds like variable # of influencers would _lt_strong_gt_crush_lt_/strong_gt_ fixed length_co_ when computeBonesUsingShaders _eq_ false._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_DK_co_ although TOB always subclasses Mesh to begin with_co_ I would either have to in-line the override the applySkeleton which did variable_co_ or inherit from MORPH.Mesh.  Inheriting when you actually had shapekeys is going to happen anyway_co_ but kind of weird otherwise.  I do not like inlining at all._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_How about allowing BABYLON.Mesh do either?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-15T17:39:17Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Wait the fixed method checks that each weight is &gt_sm_ 0 before doing a matrix operation with it_co_ so there is no other advantage to variable than it will actually do things fixed cannot._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-15T18:40:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_have not run this yet_co_ but this subset of applySkeleton was changed to this_co_ then if skinUsingVariableNumInfluencers was read by FileLoader_co_ then any exporter that supported writing variable could use this_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var maxInfluencers _eq_ this.skinUsingVariableNumInfluencers ? Number.MAX_VALUE _dd_ 4_sm_var matWeightIdx  _eq_ 0_sm_var totalInfluencers _eq_ 0_sm_var inf _dd_ number_sm_for (var index _eq_ 0_sm_ index &lt_sm_ positionsData.length_sm_ index +_eq_ 3) {    for (inf _eq_ 0_sm_ inf &lt_sm_ maxInfluencers_sm_ inf++){        var weight _eq_ matricesWeightsData[matWeightIdx + inf]_sm_        if (weight &gt_sm_ 0) {            totalInfluencers++_sm_            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices_co_ matricesIndicesData[matWeightIdx + inf] * 16_co_ weight_co_ tempMatrix)_sm_            finalMatrix.addToSelf(tempMatrix)_sm_                                }else break_sm_               }    matWeightIdx +_eq_ this.skinUsingVariableNumInfluencers ? inf + 1 _dd_ 4_sm_    Vector3.TransformCoordinatesFromFloatsToRef(this._sourcePositions[index]_co_ this._sourcePositions[index + 1]_co_ this._sourcePositions[index + 2]_co_ finalMatrix_co_ tempVector3)_sm_    tempVector3.toArray(positionsData_co_ index)_sm_    Vector3.TransformNormalFromFloatsToRef(this._sourceNormals[index]_co_ this._sourceNormals[index + 1]_co_ this._sourceNormals[index + 2]_co_ finalMatrix_co_ tempVector3)_sm_    tempVector3.toArray(normalsData_co_ index)_sm_    finalMatrix.reset()_sm_}_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-15T19:16:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_But with more than 4 influencers per vertex_co_ you have to change the file format_co_ and all shaders supporting bones as well. This is not a simple task._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_or you just want to do it for CPU skinning?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-15T19:30:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thought the .babylon format could stay the same except that matriceIndices would have up to 3 0_t_s at the end.  Changing shaders seems like a high hurtle. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Think setting _lt_span_gt_skinUsingVariableNumInfluencers _eq_ true could just force the CPU route.  In a perfect world_co_ they should be separate choices.  Since many people do not build their own rigs though_co_ at least they have some vehicle other than build your own rig.  Maybe do GPU route at a later date._lt_/span_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span_gt_FYI_co_ that code above not perfect. Starting testing._lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-20T14:37:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Note to self &amp_sm_ anyone stumbling into this thread in the future_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The .acm &amp_sm_ .asf file collection is a format called _qt_Acclaim_qt_.  The format is documented here_dd_  _lt_a href_eq__qt_http_dd_//research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/ASF-AMC.html_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/ASF-AMC.html_lt_/a_gt_ and here _lt_a href_eq__qt_http_dd_//www.darwin3d.com/gamedev/acclaim.zip_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.darwin3d.com/gamedev/acclaim.zip_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-20T16:21:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Anyone know what do you specify as an Animation object for a bone that does not participate in a particular animation? Null?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The first link says in the bonedata section of the ASF file_co_ if a bone has no Degrees of Freedom_co_ or DOF_co_ that it will have no motion data in the ACM file.  I have observed this in the one animation I pulled out of the zip file.  Some of the bones are missing from the ACM file.  In the ASF file_co_ they have no DOF.  See the _t__lt_span_gt_lhipjoint_t_ bone in the ASF above._lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-28T19:04:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well_co_ I got the variable # of influencers for CPU running all the way from Blender to the code above_co_ edited slightly.  I now realize that I am varying the number by vertex.  Looking at the vertex shaders &amp_sm_ my opengl books_co_ this is simply not possible._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Varying by mesh should be possible though.  DK_co_ how does this sound as a template to modifying the shaders to do vary by mesh?_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_#if N_BONE_INFLUENCERS &gt_sm_ 0    // having bone influencers implies you have bones    uniform mat4 mBones[BonesPerMesh]_sm_    #if N_BONE_INFLUENCERS &lt_sm_ 5        attribute vec4 matricesIndices_sm_        attribute vec4 matricesWeights_sm_    #else        attribute mat2 matricesIndices_sm_        attribute mat2 matricesWeights_sm_    #endif#endif...void main(void){#ifdef INSTANCES    mat4 finalWorld _eq_ mat4(world0_co_ world1_co_ world2_co_ world3)_sm_#else    mat4 finalWorld _eq_ world_sm_#endif#if N_BONE_INFLUENCERS &gt_sm_ 0    mat4 influence _eq_ mBones[int(matricesIndices[0])] * matricesWeights[0]_sm_        #if N_BONE_INFLUENCERS &gt_sm_ 1            influence +_eq_ mBones[int(matricesIndices[1])] * matricesWeights[1]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 2            influence +_eq_ mBones[int(matricesIndices[2])] * matricesWeights[2]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 3            influence +_eq_ mBones[int(matricesIndices[3])] * matricesWeights[3]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 4            influence +_eq_ mBones[int(matricesIndices[4])] * matricesWeights[4]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 5            influence +_eq_ mBones[int(matricesIndices[5])] * matricesWeights[5]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 6            influence +_eq_ mBones[int(matricesIndices[6])] * matricesWeights[6]_sm_        #endif            #if N_BONE_INFLUENCERS &gt_sm_ 7            influence +_eq_ mBones[int(matricesIndices[7])] * matricesWeights[7]_sm_        #endif        finalWorld _eq_ finalWorld * (influence)_sm_#endif    gl_Position _eq_ viewProjection * finalWorld * vec4(position_co_ 1.0)_sm_    ..._lt_/pre_gt__lt_p_gt_It would mean that numBoneInfluencers be added to mesh_co_ default 4.  I did not want to start modifying all the files_co_ without your input.  Will just move the CPU skinning to my subclass_co_ if that was the case._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-28T20:18:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I see no problem with this. Actually this will be even better when num influences &lt_sm_ 4_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-28T20:27:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co_ one question_co_ what about this BONE4 _eq_ false fallback on a couple?  Seems like this is never going to work right_co_ except in the case when 3 or less is in use.  This way handles that._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Couldn_t_t cpu skinning be the fallback?  Sorry that_t_s 2 questions._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-28T20:48:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_With your system we do not need BONE4 at all actually_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-29T21:44:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Comedy of errors_co_  (I should do standup). _lt_/p_gt__lt_ul_gt__lt_li_gt_First mat2 is not 2 rows of four.  I switched to mat3_co_ which is a 3 by 3_lt_/li_gt__lt_li_gt_If you access a mat by only 1 value_co_ you get a vector not a scalar.  Switched to 2d access_co_ matricesWeights[1][0]_lt_/li_gt__lt_li_gt_Made all other changes_co_ but hit a wall with gl.vertexAttribPointer().  Even though you can specify up to a mat4 for a vertex attribute_co_ the max size you can specify is only 4._lt_/li_gt__lt_/ul_gt__lt_p_gt_I am done for today_co_ but tomorrow think I will do this_co_ unless stopped_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_Add 2 more vertex buffer types (do not think you would like to attributes per buffer)_lt_/li_gt__lt_li_gt_Re-do cpu skinning slightly._lt_/li_gt__lt_/ul_gt__lt_p_gt_This is what the shader would not be_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_#if NUM_BONE_INFLUENCERS &gt_sm_ 0\t// having bone influencers implies you have bones\tuniform mat4 mBones[BonesPerMesh]_sm_\tattribute vec4 matricesIndices_sm_\tattribute vec4 matricesWeights_sm_\t#if NUM_BONE_INFLUENCERS &gt_sm_ 4\t\tattribute vec4 matricesIndicesExtra_sm_\t\tattribute vec4 matricesWeightsExtra_sm_\t#endif#endif...#if NUM_BONE_INFLUENCERS &gt_sm_ 0\tmat4 influence_sm_\tinfluence _eq_ mBones[int(matricesIndices[0])] * matricesWeights[0]_sm_\t#if NUM_BONE_INFLUENCERS &gt_sm_ 1\t\tinfluence +_eq_ mBones[int(matricesIndices[1])] * matricesWeights[1]_sm_\t#endif\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 2\t\tinfluence +_eq_ mBones[int(matricesIndices[2])] * matricesWeights[2]_sm_\t#endif\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 3\t\tinfluence +_eq_ mBones[int(matricesIndices[3])] * matricesWeights[3]_sm_\t#endif\t\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 4\t\tinfluence +_eq_ mBones[int(matricesIndicesExtra[0])] * matricesWeightsExtra[0]_sm_\t#endif\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 5\t\tinfluence +_eq_ mBones[int(matricesIndicesExtra[1])] * matricesWeightsExtra[1]_sm_\t#endif\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 6\t\tinfluence +_eq_ mBones[int(matricesIndicesExtra[2])] * matricesWeightsExtra[2]_sm_\t#endif\t\t#if NUM_BONE_INFLUENCERS &gt_sm_ 7\t\tinfluence +_eq_ mBones[int(matricesIndicesExtra[3])] * matricesWeightsExtra[3]_sm_\t#endif\t\tfinalWorld _eq_ finalWorld * influence_sm_#endif_lt_/pre_gt__lt_p_gt_Overall_co_ things went pretty well._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-29T21:54:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I rahter prefer this way actually_dd_) Keep up the good work!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-10-30T18:16:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co_ works both CPU &amp_sm_ GPU for StandardMaterials.  I have modified all 6 vertex shaders which use bones.  I have been forcing a 4 influencer mesh to say it was 6.  So in addition to testing which something that actually needs more than 4_co_ for the next commit need to add the extra attributes for the other shaders when more than 4._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I also changed EffectFallbacks class as follows_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_private _mesh _dd_ AbstractMesh_sm_private _meshRank _dd_ number_sm_...public addCPUSkinningFallback(rank_dd_ number_co_ mesh _dd_ AbstractMesh){    this._meshRank _eq_ rank_sm_    this._mesh _eq_ mesh_sm_    if (rank &gt_sm_ this._maxRank) {        this._maxRank _eq_ rank_sm_    }}...public reduce(currentDefines_dd_ string)_dd_ string {    ...    if (this._mesh &amp_sm_&amp_sm_ this._currentRank _eq__eq__eq_ this._meshRank){        this._mesh.computeBonesUsingShaders _eq_ false_sm_        currentDefines _eq_ currentDefines.replace(_qt_#define NUM_BONE_INFLUENCERS _qt_ + this._mesh.numBoneInfluencers_co_ _qt_#define NUM_BONE_INFLUENCERS 0_qt_)_sm_    }    ...}_lt_/pre_gt__lt_p_gt_I was going to call it in the places BONES4 fallback was added.  Do you think this is going to work?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-10-30T21:54:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_It should!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]