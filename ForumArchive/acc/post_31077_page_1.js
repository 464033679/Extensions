[{"Owner":"AussieKSU","Date":"2017-06-14T21:30:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI would like to add many (10k-100k) instances of a particular geometry into the scene. For simplicity sake_co_ we can consider the geometry a cylinder. I have used (Jerome_t_s excellent) Solid Particle System to solve this problem. We will see very good performance with respect to FPS simply using add shape ie. addShape(cylinderMesh_co_ 100000). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHOWEVER\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSolid Particle Systems will still duplicate the geometry needed for the cylinder. We will see the geometry duplicated x100000 in the resulting mesh_co_ causing the brower to store all the (transformed) vertexes. Is there a solution which can _qt_reuse_qt_ the geometry_co_ and keep the memory footprint low for my scene (shaders perhaps)? Is there Something that will set the vertex attributes to the GPU once_co_ and then provide a set of transformations? I know display lists are not supported in OpenGL ES_co_ and maybe this is the killer for my desired behavior?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-15T01:22:31Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tSeems like you need to use instances_dd_ They share the geometry and provide a set of transform _dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_instances_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_instances_lt_/a_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-15T08:33:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYep you_t_re right _dd_ in the SPS the geometry of each particle is stored in the global SPS mesh geometry (don_t_t forget you can change each particle geometry on the fly though .. and that each particle can be built from a different shape/geometry).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis means a float triplet per particle vertex + a float triplet per vertex normal. You can easily deduce the required memory.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf I_t_m not wrong_co_ as the instances share the same geometry_co_ a single set of vertices/normals is enough for all. In the other side_co_ each instance needs its own world matrix_co_ so an array of 16 floats per instance_co_ whereas the SPS manages only one global world matrix.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tJust measure and compare both for your real concrete case to check what fits the best to your need.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2017-06-15T17:29:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI had a notion that instances may be recommended. I have two observations about instances (happy to provide playgrounds if desired)_lt_br /_gt__lt_br /_gt_\n\t1. The memory footprint of instances is not trivial. Even creating 20_co_000 instances of a very simply geometry_co_ I see the memory of the browser climb to ~150Mb (Chrome). It seems that instances still need some memory in their backbone to exist. Each instance_co_ of course is allowed its own matrix_co_ but this should account for 1.22Mb (if my math is correct).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t2) The FPS of many instances seems to decline sharply. Perhaps this has to do with the draw calls involved with instances (a separate call for each_co_ perhaps?). Instances may be a great solution in other cases (perhaps with meshes with very complex geometry)_co_ but it seems the quantity of instances with respect to FPS performance seems to be a limiting factor for me.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2017-06-15T18:14:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThere is not currently any free lunch.  I cannot speak to #1_co_ could be a leak.  Not many people have pushed instances to such levels.  Also in addition to the 16 float32_t_s_co_ there are 3 vectors (location_co_ rotation_co_ scale) each that have 3 number64-bit.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t#2 is not a matter of draw calls but of the javascript overhead of calculating 20_co_000 matrices_co_ or at least checking it needs to be done .  Scenes with this many meshes are DOA in my opinion_co_ due to overhead.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-15T20:23:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI agree.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t100K objects visible in the same time are really a huge number... only to display them on the screen considering the number of pixels. Do you really need 100K visible objects simultaneously ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2017-06-15T20:48:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tIn my application_co_ it is very possible for 100k objects to be in the frustum at a given time. I have it in mind to implement some fixed frame rate logic which will order the meshes based on their projected size on the screen (done via a web worker_co_ similar to Ranaan_t_s collision solution)_co_ and render only as many as time permits each Render loop (while the camera is not moving_co_ this time constraint is relaxed). This addressees the FPS constraint of any of the above solutions (instances_co_ SPS or simply merged meshes). This solution is a bit lower priority since SPS performs very well indeed. However_co_ this does not address the memory pressure - hence my thermo nuclear solution below_dd__lt_br /_gt__lt_br /_gt_\n\tI have in mind to implement some frustum logic that will dispose_co_ as needed_co_ meshes that fall outside the view frustum. Furthermore_co_ for objects in the view frustum which are not yet loaded (or have been disposed) a server call will be made to (re)acquire the data. This is a complex but doable solution. However_co_ before I use the thermo nuclear option_co_ since many of the 100k objects use identical geometry_co_ I want to make sure I am not missing some good fps AND memory solution. Vertex shaders or something along those lines?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-16T03:55:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI understand your approach and probably some dedicated vertex shader would help in your case.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat I initially meant with my question about the 100K visible objects was _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- 100K objects can be in the frustum_co_ok ...but 100K is big number of things to be drawn on the actual screen area. Even if they are all in the frustum_co_ plenty of them won_t_t finally be visible to the user_co_ because they are hidden by others unless they are all very little (or very far in the distance_co_ so projected as little). Perhaps you might not really need to manage 100K visible objects and you might recycle the invisible/hidden ones. \n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Moreover the user eyes/brain can hardly makes the difference between huge numbers_co_ especially when there_t_s no mean to compare (another scene besides with another amount of objects to compare to). But the CPU/GPU (especially the CPU with the js monothread) can really feel the difference between 20K and 100K iterations !\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo here again_co_ maybe is there a way to fake the real number of visible objects ... pretend it_t_s 100K whereas it_t_s only 30K in your array and  you actually draw only 15K in the frustum. _lt_img alt_eq__qt__dd_P_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_tongue.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/tongue@2x.png 2x_qt_ title_eq__qt__dd_P_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tJust as a side idea_co_ maybe a dynamic texture depicting very simply plenty of little _qt_things_qt_ in the distance (blurred shapes_co_ points_co_ etc) and displayed in the background could fake at reduced cost the thousands of distant not computed instances meanwhile. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]