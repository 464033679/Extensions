[{"Owner":"timetocode","Date":"2018-05-05T10:11:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWhat are some options for creating terrain from heightmaps via NullEngine? I_t_m trying to create a serverside terrain for collision checks in a multiplayer game.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe main issue is that Mesh.CreateGroundFromHeightMap involves loading an image and going through pixel data via canvas_co_ none of which exists in node.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSome ideas_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tExpose canvas + image api on the server_dd_ _lt_a href_eq__qt_https_dd_//github.com/Automattic/node-canvas_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/Automattic/node-canvas_lt_/a_gt_ can provide Image and Canvas to NullEngine_co_ though I_t_ve written a server side image processor recently that uses this tech and while it does work it isn_t_t entirely straight forward because quite a few extra things need installed before it all works. I_t_m not sure how many babylon nullengine features use canvas/image_co_ if its just this one then I doubt this route is worth it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tJust loading the image in node_dd_ a small patch function that detects if we_t_re in node and loads an image and gets its pixels using regular node fs. I_t_m not 100% sure how to do this but it sounds possible. This would kinda fork the logic inside of Mesh.CreateGroundFromHeightMap unless it was exposed in a new way.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tGo straight to the heightmap data and skip the images_dd_ _lt_a href_eq__qt_https_dd_//doc.babylonjs.com/api/classes/babylon.vertexdata#creategroundfromheightmap_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/api/classes/babylon.vertexdata#creategroundfromheightmap_lt_/a_gt_ - this does assume pixel data (UInt8 array of RGB? RGBA?) but has no dependency on canvas as far as I can tell. I don_t_t understand the colorFilter (0.3_co_ 0.59_co_ 0.11) though_co_ so someone would have to explain it to me.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn my case I actually generated my heightmaps in node to begin with_co_ and then saved them as images purely as a visual tool to see how the maps would look. I happen to be using these debug images and loading them into babylon because it works automagically! I could certain just skip all this and save them in some other format_co_ like a 1D array of UInt8s (though in this scenario it would be ideal to skip RGBA and just have raw height data). I could probably add this to babylon by following the existing example if this is a feature people want.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOnce again I_t_m a total 3D noob_co_ so if there is a much more trivial solution please let me know _dd_D. I_t_m also willing to contribute_co_ but I just don_t_t want to make the wrong contribution.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-06T02:18:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI tried the option of creating vertex data from a simple height map (as opposed to creating it from pixel data). I then used this code on both client and server and passed it a heightmap generated via a seed. It seems to work pretty well. For anyone interested the code is below.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe code is almost exactly the existing BJS height map code_co_ except this one uses a 1D array of heights instead of pixels_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_function vertexDataFromHeightMap(options) {\n    let indices _eq_ []\n    let positions _eq_ []\n    let normals _eq_ []\n    let uvs _eq_ []\n    let row\n    let col\n\n    for (row _eq_ 0_sm_ row &lt_sm__eq_ options.subdivisions_sm_ row++) {\n        for (col _eq_ 0_sm_ col &lt_sm__eq_ options.subdivisions_sm_ col++) {\n            let position _eq_ new BABYLON.Vector3(\n                (col * options.width) / options.subdivisions - (options.width / 2.0)_co_ \n                0_co_\n                ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)\n            )\n\n            let heightMapX _eq_ (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0\n            let heightMapY _eq_ ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0\n            let pos _eq_ (heightMapX + heightMapY * options.bufferWidth)\n            let height _eq_ options.buffer[pos] / 255\n            position.y _eq_ options.minHeight + (options.maxHeight - options.minHeight) * height\n            positions.push(position.x_co_ position.y_co_ position.z)\n            normals.push(0_co_ 0_co_ 0)\n            uvs.push(col / options.subdivisions_co_ 1.0 - row / options.subdivisions)\n        }\n    }\n\n    for (row _eq_ 0_sm_ row &lt_sm_ options.subdivisions_sm_ row++) {\n        for (col _eq_ 0_sm_ col &lt_sm_ options.subdivisions_sm_ col++) {\n            indices.push(col + 1 + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + 1 + row * (options.subdivisions + 1))\n            indices.push(col + row * (options.subdivisions + 1))\n            indices.push(col + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + 1 + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + row * (options.subdivisions + 1))\n        }\n    }\n\n    BABYLON.VertexData.ComputeNormals(positions_co_ indices_co_ normals)\n\n    let vertexData _eq_ new BABYLON.VertexData()\n    vertexData.indices _eq_ indices\n    vertexData.positions _eq_ positions\n    vertexData.normals _eq_ normals\n    vertexData.uvs _eq_ uvs\n    return vertexData\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tHere is a deterministic generator that can be used to create a map. The key here is to use the same seed on all the machines (clients_co_ servers_co_ etc) that need this terrain.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_const SimplexNoise _eq_ require(_t_simplex-noise_t_)\n\n// produces the basic cloud/organic noise pattern\nmodule.exports _eq_ (seed_co_ width_co_ height) _eq_&gt_sm_ {\n    const simplex _eq_ new SimplexNoise(seed)\n    const arr _eq_ []\n    for (let x _eq_ 0_sm_ x &lt_sm_ width_sm_ x++) {\n        for (let y _eq_ 0_sm_ y &lt_sm_ height_sm_ y++) {\n            // 8 octaves_co_ range is -1.0 to 1.0 (though very average overall)\n            let value _eq_ simplex.noise2D(x_co_ y) * 1 / 128\n            value +_eq_ simplex.noise2D(x / 2_co_ y / 2) * 1 / 128\n            value +_eq_ simplex.noise2D(x / 4_co_ y / 4) * 1 / 64\n            value +_eq_ simplex.noise2D(x / 8_co_ y / 8) * 1 / 32\n            value +_eq_ simplex.noise2D(x / 16_co_ y / 16) * 1 / 16\n            value +_eq_ simplex.noise2D(x / 32_co_ y / 32) * 1 / 8\n            value +_eq_ simplex.noise2D(x / 64_co_ y / 64) * 1 / 4\n            value +_eq_ simplex.noise2D(x / 128_co_ y / 128) * 1 / 2\n            arr.push((value+1) * 127.5) // convert range from [-1...1] to [0...255]\n        }\n    }\n    return { width_dd_ width_co_ height_dd_ height_co_ values_dd_ arr}\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThere_t_s one extra step which is to get the vertex data and make an actual mesh out of it. I suppose this could_t_ve just been added to the other function and called _t_meshFromHeightMap_t_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let heightmap _eq_ generate(_t_this string is a seed_t__co_ 256_co_ 256)\n\nlet heightMapVertexData _eq_ vertexDataFromHeightMap({ \n    width_dd_ heightmap.width_co_\n    height_dd_ heightmap.height_co_\n    subdivisions_dd_ 256_co_\n    minHeight_dd_ 0_co_ \n    maxHeight_dd_ 30_co_ \n    buffer_dd_ new Uint8Array(heightmap.values)_co_\n    bufferWidth_dd_ heightmap.width_co_\n    bufferHeight_dd_ heightmap.height \n})\n\nlet mesh _eq_ new BABYLON.Mesh(_t_blank_t__co_ this.scene)\nheightMapVertexData.applyToMesh(mesh_co_ 1)_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tMost of those values can be changed as desired... the only ones that cannot be changed are the buffer_co_ bufferWidth_co_ and bufferHeight which much correspond to the actual data created.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe attached image is the result.\n_lt_/p_gt_\n\n_lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/in-engine-height-map.PNG.aafaf2e5a280c45eba46b79a6c094f5c.PNG_qt_ class_eq__qt_ipsAttachLink ipsAttachLink_image_qt__gt__lt_img data-fileid_eq__qt_18136_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/in-engine-height-map.thumb.PNG.a31f9f4513b49da3c10ed092117f6901.PNG_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ alt_eq__qt_in-engine-height-map.PNG_qt__gt__lt_/a_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-06T08:17:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_ve just learned that the code pasted above will make a terrain mesh but is missing babylon features because I did not properly set the mesh up to be a GroundMesh. A GroundMesh has addition properties on it related to the subdivisions_co_ and when working correctly exposes additional functions such as getHeightAtCoordinates and getNormalAtCoordinates. These are important functions for implementing collisions against terrain.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve updated the code below. Just to clarify_co_ the only special things about this compared to the original implementation are_dd_\n_lt_/p_gt_\n\n_lt_ul_gt_\n\t_lt_li_gt_\n\t\tsource height map is a 1D array of bytes (UInt8 0-255) instead of rgba pixel data_co_ so the map data can be a fair amount smaller (though lossy image compression might fight that notion..not sure)\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tworks in node.js_co_ because it does not use a canvas or a DOM image\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tdoes not use a color filter to get height map data_co_ height is purely a number from 0-255 (if this were an image_co_ it would be grayscale)\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tprobably sync instead of async (maybe?_co_ it skips the async image load step)\n\t_lt_/li_gt_\n_lt_/ul_gt_\n\n_lt_pre_gt_\n_lt_code_gt_function groundMeshFromHeightMap(name_co_ options_co_ scene) {\n    let width _eq_ options.width || 10.0\n    let height _eq_ options.height || 10.0\n    let subdivisions _eq_ options.subdivisions || 1 | 0\n    let minHeight _eq_ options.minHeight || 0.0\n    let maxHeight _eq_ options.maxHeight || 1.0\n    let updatable _eq_ options.updatable\n    let onReady _eq_ options.onReady\n    let ground _eq_ new BABYLON.GroundMesh(name_co_ scene)\n    ground._subdivisionsX _eq_ subdivisions\n    ground._subdivisionsY _eq_ subdivisions\n    ground._width _eq_ width\n    ground._height _eq_ height\n    ground._maxX _eq_ ground._width / 2.0\n    ground._maxZ _eq_ ground._height / 2.0\n    ground._minX _eq_ -ground._maxX\n    ground._minZ _eq_ -ground._maxZ\n    ground._setReady(false)\n\n    let indices _eq_ []\n    let positions _eq_ []\n    let normals _eq_ []\n    let uvs _eq_ []\n    let row\n    let col\n\n    for (row _eq_ 0_sm_ row &lt_sm__eq_ options.subdivisions_sm_ row++) {\n        for (col _eq_ 0_sm_ col &lt_sm__eq_ options.subdivisions_sm_ col++) {\n            let position _eq_ new BABYLON.Vector3(\n                (col * options.width) / options.subdivisions - (options.width / 2.0)_co_\n                0_co_\n                ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)\n            )\n\n            let heightMapX _eq_ (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0\n            let heightMapY _eq_ ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0\n            let pos _eq_ (heightMapX + heightMapY * options.bufferWidth)\n            let height _eq_ options.buffer[pos] / 255\n            position.y _eq_ options.minHeight + (options.maxHeight - options.minHeight) * height\n            positions.push(position.x_co_ position.y_co_ position.z)\n            normals.push(0_co_ 0_co_ 0)\n            uvs.push(col / options.subdivisions_co_ 1.0 - row / options.subdivisions)\n        }\n    }\n\n    for (row _eq_ 0_sm_ row &lt_sm_ options.subdivisions_sm_ row++) {\n        for (col _eq_ 0_sm_ col &lt_sm_ options.subdivisions_sm_ col++) {\n            indices.push(col + 1 + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + 1 + row * (options.subdivisions + 1))\n            indices.push(col + row * (options.subdivisions + 1))\n            indices.push(col + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + 1 + (row + 1) * (options.subdivisions + 1))\n            indices.push(col + row * (options.subdivisions + 1))\n        }\n    }\n\n    BABYLON.VertexData.ComputeNormals(positions_co_ indices_co_ normals)\n\n    let vertexData _eq_ new BABYLON.VertexData()\n    vertexData.indices _eq_ indices\n    vertexData.positions _eq_ positions\n    vertexData.normals _eq_ normals\n    vertexData.uvs _eq_ uvs\n\n    vertexData.applyToMesh(ground_co_ updatable)\n\n    if (onReady) {\n        onReady(ground)\n    }\n    ground._setReady(true)\n    return ground\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m making this whole thing as solved because this seems to work well. I didn_t_t explore the other options with much depth_co_ but now that I_t_ve learned more I can say I think they would all work. For those who want to store a heightmap as an image (instead of an array of bytes) but still load it in node.js_co_ it would probably be easiest to just copy pasta the original code and then get a node-based png or jpeg lib to open the image and turn its data into the format needed to populate the heightmap. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-05-10T18:14:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAuto solved problem! My favorites _lt_span_gt__lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt_true_qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt__gt__lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]