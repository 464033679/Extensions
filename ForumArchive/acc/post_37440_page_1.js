[{"Owner":"timetocode","Date":"2018-05-06T02:58:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHow do we improve performance for collisions versus a heightmap or mesh or just large numbers of floors+walls?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m not looking for true physics (or at least_co_ I don_t_t think that I am). I_t_m looking to be able to support a few hundred entities all of whom are in contact with a large terrain mesh. Somewhere in the realm of 30-120 players_co_ and 50-1000 npcs or items that had been dropped on the ground would be the ballpark performance goal.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is a demo that shows the desired behavior more or less_dd_ _lt_a href_eq__qt_http_dd_//www.babylon.actifgames.com/moveCharacter/_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylon.actifgames.com/moveCharacter/_lt_/a_gt_  (use mouse look and and Z to walk around). Both this demo and my own attempts at something very similar use `moveWithCollisions` which seems to eat quite a bit of CPU. One to three players is enough to max out the cpu. I presume it results in a collision check between the moving meshes and every triangle of the terrain mesh (just guessing though_co_ not sure how it actually works).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLeft to my own devices I_t_d probably compare the entity positions against the heightmap value at their x_co_z and just always make sure the y of their feet never slips under the heightmap -- I imagine this optimization could scale to several hundreds or thousands of entities and wouldn_t_t involve a true mesh collision. It also wouldn_t_t work for overhangs or caves_co_ but I don_t_t have any of those yet.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs for collisions with walls or floors or large numbers of other objects that aren_t_t part of the heightmap.. I_t_m not sure what I_t_d do. Maybe I_t_d partition the world up into large cubes and then dice up the existing collision code such that objects were only checked against their nearer spatial neighbors...(the other meshes that occupy the same cube as them)?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut before I go reinventing wheels_co_ I_t_d figure I_t_d ask here.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"NasimiAsl","Date":"2018-05-06T06:16:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\thi\n_lt_/p_gt_\n\n_lt_p_gt_\n\tif you have a height number  per  camera point (x_co_y) you can control that full optimized\n_lt_/p_gt_\n\n_lt_p_gt_\n\tyou need  have 3 point height and calculate normal of current state and calculate next step ( or move direction state) different\n_lt_/p_gt_\n\n_lt_p_gt_\n\tand choose be move or locked ( in good algorithm you don_t_t locked just you correct last move state )\n_lt_/p_gt_\n\n_lt_p_gt_\n\ti think _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5453_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/_qt_ rel_eq__qt__qt__gt_@jerome_lt_/a_gt_ do it in terrain if you use that it is optimized \n_lt_/p_gt_\n\n_lt_p_gt_\n\ta wired solution is available too you make scan full scene and make multi stage and calculate all in one time and keep it in array and just read that \n_lt_/p_gt_\n\n_lt_p_gt_\n\tthat is not so specific but worked for large scene as i see \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-05-06T06:48:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//doc.babylonjs.com/api/classes/babylon.groundmesh#getnormalatcoordinates_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/api/classes/babylon.groundmesh#getnormalatcoordinates_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//doc.babylonjs.com/api/classes/babylon.groundmesh#getheightatcoordinates_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/api/classes/babylon.groundmesh#getheightatcoordinates_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-06T07:59:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThank you NasimiAsl and jerome.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tgetHeightAtCoordinates is perfect. It can easily do many many objects on the terrain now.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI just had to turn my height map into a GroundMesh with the correct properties on it.. I was missing some things because I was using  custom vertexData.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m not too sure how to do movement_co_ but the following seems to be working nicely_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_// skipped_dd_ rotate mesh to where player camera is aimed\n// unit vector of our movement\nlet unit _eq_ BABYLON.Vector3.Zero()\nif (command.forward) { unit.z +_eq_ 1 }\nif (command.backward) { unit.z -_eq_ 1 }\nif (command.left) { unit.x -_eq_ 1 }\nif (command.right) { unit.x +_eq_ 1 }\n\n// rotating the unit vector to the context of this entity\nlet heading _eq_ this.mesh.getDirection(unit)\n\n// full vector_co_ movement and magnitude\nlet velocityCoef _eq_ this.speed * command.delta\nlet velocity _eq_ heading.multiplyByFloats(velocityCoef_co_ velocityCoef_co_ velocityCoef)\n\n// try to move\n//this.mesh.moveWithCollisions(velocity) // no more!\nthis.mesh.position.x +_eq_ velocity.x\nthis.mesh.position.y +_eq_ velocity.y\nthis.mesh.position.z +_eq_ velocity.z\n\nlet y _eq_ this.scene.ground.getHeightAtCoordinates(this.mesh.position.x_co_ this.mesh.position.z)    \n\n// added a little padding to keep the mesh slightly off of the ground\nif (this.mesh.position.y &lt_sm_ y + 1) {\n    this.mesh.position.y _eq_ y + 1\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThis is for a multiplayer game that I_t_m porting from 2D.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t understand how/when to use getNormalAtCoordinates. Is this for making the mesh to appear at the same slope as the terrain? Currently all I have are cubes that always face towards wherever the player controlling them has their camera aimed (like a first person shooter_co_ but if everyone was just a magical cube that floats near the ground).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/bots-colliding-with-ground.PNG.7dabd95790f126e0037c1111ca16f28e.PNG_qt_ data-fileid_eq__qt_18141_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_bots-colliding-with-ground.PNG_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18141_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/bots-colliding-with-ground.thumb.PNG.aeddb97ddc8d65514e003193ce14a959.PNG_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Raggar","Date":"2018-05-06T13:07:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYou will need getNormalAtCoordinates in case you want your object to be rotated according to the normal it sits above. This normally isn_t_t necessary with player and NPC meshes_co_ but could be used for dropped items_co_ pickups etc. It does add a bit of realism_co_ in case you have uneven terrain.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tUnfortunately I can_t_t find my own benchmark project. I did some testing with CannonJS vs. moveWithCollisions vs. getXAt vs. my own simple physics implementation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tEdit_dd_ Quick test_dd_ _lt_a href_eq__qt_http_dd_//playground.babylonjs.com/#BLAJPA_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//playground.babylonjs.com/#BLAJPA_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWithout rendering the instances it can easily calculate the height of 8000 objects. Didn_t_t try higher than that_co_ but with 60 fps it shouldn_t_t become an issue.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe real issue is if those objects have to collide with each other + walls_co_ props etc. If they do_co_ I guess you_t_ll have to divide your world into a grid as you already mentioned_co_ and only test every individual grid_co_ to prevent massive calculations.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]