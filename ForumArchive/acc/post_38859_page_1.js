[{"Owner":"The Leftover","Date":"2018-07-16T04:15:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI should not being doing this . . . but I have been experimenting with Web Assembly.Â  With so many hexagons and so many crime incidents_co_ Illuminated City has come computationally intensive tasks.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy question is_co_ have y_t_all tried to use it for some functions (e.g. ComputeNormals)?Â  Did it perform well?Â  Did it seem worthwhile?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"brianzinn","Date":"2018-07-16T06:08:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYes_co_ you should be doing that!! _lt_span_gt__lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/span_gt_Â  And it_t_s a good question.Â  Especially now with essentially full compatibility.Â  Check this issue for extra details_dd__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/issues/3248_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/issues/3248_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI think it_t_s a matter of time really_co_ but it_t_s I think hard to split the work/communication from wasm andÂ webGL and keep fast render.Â Â I don_t_t think it_t_s a question about performance - the math is going to be faster - it_t_s getting it all working together.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI haven_t_t done any wasm experiments except playing withÂ OpenJPEG.Â  I need to find more time somewhere..._lt_br /_gt_\n\tÂ \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-07-16T07:33:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThe answer might come (before the end of year_co_ I hope) from AssemblyScript _dd_Â _lt_a href_eq__qt_https_dd_//github.com/AssemblyScript/assemblyscript_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/AssemblyScript/assemblyscript_lt_/a_gt_Â  that allows to compile a subset of TypeScript directly to WebAssembly_co_Â  aka WASM_co_ or to Javascript.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCheck out this online tool _dd_Â _lt_a href_eq__qt_https_dd_//webassembly.studio/_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//webassembly.studio/_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tKnowing that BJS is already coded in TypeScript_co_ the effort to port some parts of the code to the AssemblyScript required subset would probably be worth a try instead of rewritting thousands of lines in C/C++ just in order to compile them to WASM.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tA subset of TypeScript is just some legal TS... this just means that AssemblyScript can_t_t understandÂ _lt_em_gt_all_lt_/em_gt_Â TypeScript_co_ but just a subpart of it because the compiling process imposes some explicit definitions.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tExample _dd_ whereas TS can understand the statement _qt_var a _eq_ 10_qt_ or _qt_var a_dd_number _eq_ 10_qt__co_ AssemblyScript needs to know if the variable a is an integer_co_ a float and what memory size to use _dd_ i16_co_ i32_co_ f32_co_ f64 before compiling. The same thing we would have to do if the same part of code were ported to C actually.Â \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWell_co_ if you already contribute to BJS in TS_co_ or if you simply code in TS on your side_co_ you don_t_t really need to learn more to start to code with AssemblyScript in order to get your first working WASM. Never tried so far though _lt_span_gt__lt_span class_eq__qt_ipsEmoji_qt__gt_ðŸ˜„_lt_/span_gt__lt_/span_gt_Â \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-07-16T14:47:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tGentlemen_co_ thank you for the links.Â  Let me some opinions base onÂ three days of work.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI started writing in straight WAT.Â Â  Because I have a genetic defect that causes me to do things the hard way.Â  However_co_ it has caused me to learn a lot of things.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWebAssembly is at the _qt_MVP_qt_ stage as they call it.Â  One can only create a module with functions below that -Â two levels.Â  One can create a list of which functions may be exported.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe MVP status shows_dd_Â  I couldn_t_t figure out how to make a module-global variable that was mutable_sm_ so I did a work-around.Â  One can share a typed array between JS and WA.Â  In WA_co_ it is called _qt_memory_qt_ but there may only be one of them.Â  I redesigned things a bit so all processing was applied against one array.Â  This could put a crimp in my style.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs it possible the _qt_C_qt_ converter bypasses these functionality bottlenecks?Â  It seems a little unlikely_sm_ I think wat is the textual representation of wasm and they go hand-in-hand.Â  They do appear to be beavering away at this much as we are here.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe integration makes it *NOT* an all or nothing kind of thing.Â  When the module is built_co_ it can receive JS functions_co_ notably console.log.Â  So I can log things to the console.Â  I could make other JS calls if I wanted.Â  Exported functions are just a function.Â  You can call it from JS.Â  (If you print them it says _qt_native code_qt__co_ which gave me a kick.)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn light of this_co_ I am pushing forward with creating limited functions for the three or four places where Illuminated City sits for more than a second.Â  It requires some re-organization but I have the substantial advantage of being the only author.Â  I can also write these functions in JS.Â  That part is really neat_sm_ the array is one array and looks the same whether the manipulation was done by JS or WA.Â  This will be helpful for testing.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-07-17T07:37:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tReally nice feedback and interesting try.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have done some investigations about asm/wasm some time ago and I know this way of sharing data between JS and WASM (typedArrays / buffers).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe approach you made_co_ and I didn_t_t mention_co_ to build dedicated code in wasn is obviously one of the best _dd_ why only thinking about porting the 3D engine in wasm and not the user code (theÂ logic) that may often be the slow part of the final software ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPlease have a read about how they choose smartly to share the memory between JS and the compiled wasm module in AS _dd_Â _lt_a href_eq__qt_https_dd_//github.com/AssemblyScript/assemblyscript/wiki/Memory-Layout-&amp_sm_-Management_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/AssemblyScript/assemblyscript/wiki/Memory-Layout-&amp_sm_amp_sm_-Management_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis could be inspiring to organize the data transfers to/from JS and the module.Â \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-08-04T00:51:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co_ thanks.Â  I usually do something like this.Â  I create a module config object_co_ and attach the memory there.Â  This hands in whatever settings are needed and the memory.Â  Now both JavaScript and WebAssembly can access the same typed array using _t_hexlatticeMemoryView_t_ and _t_i32.load_t_/_t_i32.store_t_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI treat the WebAssembly module as a persistent _qt_closure_qt_.Â  Some of them have four or five function entry points.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_ JAVASCRIPT  JAVASCRIPT  JAVASCRIPT  JAVASCRIPT  JAVASCRIPT \n            hexlatticeImportObject _eq_ {\n              settings             _dd_ {\n                weekbreaksLength   _dd_ weekbreaks.length*4_co_\n                weekbreaksStart    _dd_ 16_co_\n                monthBreaksLength  _dd_ 0_co_\n                monthBreaksStart   _dd_ 16+weekbreaks.length \n              }_co_\n              imports              _dd_ {\n                log                _dd_ console.log\n              }\n            }_sm_ \n          hexlatticeMemory       _eq_ new WebAssembly.Memory({initial_dd_1})_sm_\n          hexlatticeMemoryView   _eq_ new Uint32Array(hexlatticeMemory.buffer)_sm_\n          hexlatticeImportObject.imports.mem _eq_ hexlatticeMemory_sm_\n JAVASCRIPT  JAVASCRIPT  JAVASCRIPT  JAVASCRIPT  JAVASCRIPT _lt_/code_gt__lt_/pre_gt_\n\n_lt_pre_gt_\n_lt_code_gt_ WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY \n(module\n  (import _qt_imports_qt_ _qt_log_qt_      (func $log     (param i32)))\n  (memory                      (import _qt_imports_qt_    _qt_mem_qt_) 1)\n  (global $weekbreaksstart     (import _qt_settings_qt_   _qt_weekbreaksStart_qt_)     i32)\n  (global $weekbreakslength    (import _qt_settings_qt_   _qt_weekbreaksLength_qt_)    i32)\n\n WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY  WEBASSEMBLY _lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tÂ \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-08-04T00:54:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThe heartbreak of today was that the module I snipped this from runs faster in JavaScript.Â  In other areas_co_ I have reaped a 3x speedup with WebAssembly.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI believe that issue is that there is substantial overhead in entering and exiting WebAssembly.Â  You want the work it does while there to be large enough to make up the overhead and still give you a win.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tGonna go soak my head . . .Â \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-08-04T08:22:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI agree _dd_ calling small wasm functions could be slower than using the same algo inside the JS process_co_ because of the memory accessÂ and the entering/existing.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI think that the gain and the power of wasm could be real when dealing with few calls of wasm functions treating large amounts of data at once (some kind of batch computations) _lt_span_gt__dd_ big loop with huge iteration numbers_co_ big float arrays (meaning over 10K elements to treat)_co_ etc_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_Example _dd_ CPU particles_co_ culling (if it were batched _dd_ one process for all meshes at once)_co_ SPS_co_Â WM computations of instances (idem_co_ if it were batched)_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_Most of the BJS functions are already very fast and quite short_co_ they won_t_t probably get no gain at allÂ  to be translated to wasm as is._lt_/span_gt_Â \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-08-30T14:35:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tjust starting some little tests on my poor free time to evaluate the gain provided by wasm with _lt_a href_eq__qt_https_dd_//github.com/AssemblyScript/assemblyscript_qt_ rel_eq__qt_external nofollow_qt__gt_AssemblyScript_lt_/a_gt_ and _lt_a href_eq__qt_https_dd_//github.com/demille/wasm-ffi_qt_ rel_eq__qt_external nofollow_qt__gt_wasm-ffi_lt_/a_gt_ in order to focus only on the perfs and to not loose time to implement array passing nor to waste time on the C compilation toolchain _dd_ TS only and a library to manage out-of-the-box the data exchange between JS and WASM\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ll let you know if something good raises from this\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-07T18:56:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tQuick feedback about some first tests _dd_ a big loop computing all the vertices (rotations_co_ translations_co_ scalings) of a modified SPS in a WASM module.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor now_co_ the results are quite ... disappointing _lt_span_gt__dd__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_1) even by using a cool language_co_ AssemblyScript_co_ to emit WASM bytecode at quite no porting cost from TS_co_ the way to manage the exchanges between the JS code and the WASM module is painful. Not even speaking about the lack of a garbage collector WASM sideÂ what forces to give a particular attention to every object creation._lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_2) WASM_co_ although being a bytecode usable in the browser (we could expect some features like other bytecode based languages like Java can provide) doesn_t_t provide any math functions ! This means we have to implement by ourselves_co_ say_co_ all the trigonometry (sine_co_ cosine_co_ etc). How can we compute any 3D rotation withoutÂ sine or cosine ?_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_3) the first global execution on the same basis than the _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/32817-sps-experiments/?tab_eq_comments#comment-188167_qt_ rel_eq__qt__qt__gt_SPS experiments_lt_/a_gt_ is ... slower than the full stack legacy SPS !_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_I_t_ll profile and tweak the WASM code soon in the hope to get something faster. But for now_co_ it_t_s not worth it at all... unless I_t_m missing something._lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-08T06:46:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThat said_co_ don_t_t trust me either.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhy ? well_co_ in _t_98_co_ I tested Java for the first time and it was sooooo slow. I made a definitive opinion _dd_ this stuff isn_t_t worth it and has probably no future.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo please_co_ don_t_t trust me.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBy nature (statically typed_co_ low level_co_ bytcode_co_ aot compilation)_co_ WASM is way faster than JS in theory.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve probably done plenty of conception/usage errors in my test_co_ maybe also the AssemblyScript emiter isn_t_t mature yet_co_ and perhaps the browser compilers/runtime executer will get better and better (or the 3 reasons together). The theory seems to tell us this is the way to go to improve by far the performances. Now_co_ it_t_s just a question of time for the theory to get into practice.Â _lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-09-09T15:19:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co_ delighted to read your report.Â  This FYI_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI had done some profiling of Illuminated City and determined that speeding _t_VertexData.ComputeNormals_t_ would be a win for my application.Â  It is a good candidate in other ways_co_ being about 200 lines of vector arithmetic (with two calls to Math.sqrt).Â  I had considered rewriting it in native WASM but quickly realized that I did not understand application well enough.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAlso_co_ there were a bunch of boundary issues_dd_Â  it deals with multiple arrays that - I think - were not typed.Â  Converting typed &lt_sm_--&gt_sm_ untyped is gonna add a lot of overhead.Â  Also_co_ the only way I know how to process multiple arrays in a single WebAssembly module is to put them in one array and use indexed addressing.Â  I do this for my own application but it is a hefty bunch of work.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAt the end_co_ I did not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_t_VertexData.ComputeNormals_t_ is an example of a function that I would optimize the hell out of in JavaScript first.Â  Good chance that is a win.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is my only actual concrete suggestion_co_ respectfully placed from someone who doesn_t_t really understand your code_dd_Â  Migrate to typed arrays for the obvious suspects_co_ like uvs and normals and so on.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"brianzinn","Date":"2018-09-09T15:59:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think those arrays are not typed_co_ as they are built for speed to interop with WebGL array buffers...\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-09-09T18:03:18Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tbrianzinn_co_ not sure I understand why that would be.Â  (I am not doubting it_co_ though.Â  And please don_t_t explain it to me.)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI ran into a problem where I had to choose between WebAssembly and Web Workers unless I was willing to do large array copying.Â  They both have data sharing for large vectors but they wouldn_t_t work together.Â  I chose to use WebAssembly and skip Web Workers for now.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLife on the bleeding edge . . .Â \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-09T18:22:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAbout ComputeNormals()_co_ I agree it_t_s a good candidate.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst note _dd_ usually_co_ unless you_t_re dealing with an updatable_co_ then morphed_co_ mesh_co_ you don_t_t need to recompute the normals each frame.Â  But it_t_s still a good candidate for a WASM computation_co_ especially whenÂ the mesh needs to be morphed.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe current implementation of ComputeNormals() has been optimized many times over its life (check old forum posts about this topic)... and I_t_m the culprit _lt_span class_eq__qt_ipsEmoji_qt__gt_ðŸ˜„_lt_/span_gt_Â . Actually there are parts of the ComputeNormals() code that are conditional and used only for the feature FacetData_co_ because they use the very same algo on the same data. So it_t_s faster to compute the normals and the facetData in the same time than to do this big loop twice. But you can just ignore the facetData part if you want to focus on the normal computation only.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tÂ \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAbout my first test with WASM_co_ I did like you _dd_ I used only TypedArray. Actually one big TypedArray in to pass the data to the WASM module and a big TypedArray out to get the results back from the module.Â \n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut_co_ in order to focus only in my own logic_co_ I also used the library wasm-ffi _dd_Â _lt_a href_eq__qt_https_dd_//github.com/DeMille/wasm-ffi_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/DeMille/wasm-ffi_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis library handles for you all the TypedArray/ArrayBuffer exchanges between the AssemblyScript code and the WASM module. I should probably get rid of it and manage the data passing/sharing by hand to be sure it happens like I really want.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAt last_co_ WASM and workers are compatible AFAIK because modules are objects that can be passed to a worker_co_ then be instanciated in the worker itself. So_co_ although it_t_s probably hell in terms of data exchanges and memory sharing (main thread sync/to/from/ the workers_co_ each exchanging with their own WASM module)_co_ it_t_s also maybe (theorically) what could bring a huge performance gain.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"brianzinn","Date":"2018-09-09T21:46:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_227607_qt_ data-ipsquote-contentid_eq__qt_38859_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1536516198_qt_ data-ipsquote-userid_eq__qt_29406_qt_ data-ipsquote-username_eq__qt_The Leftover_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t3 hours ago_co_ The Leftover said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tbrianzinn_co_ not sure I understand why that would be.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI should probably not have said anything as I am not an expert_co_ so my comment can safely be ignored.Â  My thoughts were that ifÂ BabylonJS were to use TypedArray on UVs/normalsÂ - I imagineÂ there would be lots of overhead to ArrayBuffer back to WebGL_co_ but as I have found it would serve best to not assume and see some real numbers.Â  I think even if it were close would be worth the effort with the tooling and further browser improvements.Â  I am curious now how much time overhead is involved in the exchanges JeromeÂ just mentioned!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tedit_dd_ I want to add also that non-standard browsers like Samsung Internet_co_ Oculus_co_ etc. likely have poor support.Â  Not sure if that means that aÂ fallback mechanism is needed.Â  Yikes!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-10T10:09:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_s_gt_mmmh... first investigation _dd_ the execution time is maybe not lost in the WASM module but rather in the copy of the returned array buffer into the typed array required by updateVerticesData()_lt_/s_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_s_gt_in brief_co_ in the massive returned data parsing_co_ JS side. Still investigating_co_ stay tuned._lt_/s_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNote sure either ...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tÂ \n_lt_/p_gt_\n\n_lt_p_gt_\n\t[EDITED] _dd_ wrong log_co_ the time is really lost in the wasm module call\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-09-10T16:38:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJust to make it clear_co_ WebGL WANTS Typed Arrays_co_Â  See _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L28_qt_ rel_eq__qt_external nofollow_qt__gt_here_lt_/a_gt_.Â  Typed Arrays are _lt_a href_eq__qt_https_dd_//developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays_qt_ rel_eq__qt_external nofollow_qt__gt_backed by ArrayBuffers_lt_/a_gt_.Â  If you can pass the addresses of ArrayBuffers to to this thing_co_Â  you can just modify the memory going to the GPU directly.Â  Nothing to either way.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_const normals32F _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind)_sm_\nconst buf _eq_ normals32F.buffer_sm_\n\nmagic(&amp_sm_buf)_sm_ // clearly BS syntax\n\nmesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind_co_ normals32F)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tIf this is already being done_co_ my bad.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-11T14:29:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tFor now_co_ it seems that passing big bunches of data to WASM is still the bottleneck _lt_a href_eq__qt_https_dd_//blog.sqreen.io/webassembly-performance/_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//blog.sqreen.io/webassembly-performance/_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThat_t_s what I_t_ve just experimented. This is sad because the benefit of WASM would precisely be to compute fast millions floats for our needs in 3D _dd_ vector coordinates_co_ normals_co_ quaternions_co_ etc\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-09-11T14:41:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think I remember back when I still received github issues / PR_t_s via email_co_ that someone was trying to make a web assembly version to math.ts.Â  They gave up_co_ as I remember due to lack of improvement.Â  One might fish through the repo communications for what they found out.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-09-11T16:58:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_227769_qt_ data-ipsquote-contentid_eq__qt_38859_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1536676151_qt_ data-ipsquote-userid_eq__qt_5453_qt_ data-ipsquote-username_eq__qt_jerome_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t1 hour ago_co_ jerome said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tFor now_co_ it seems that passing big bunches of data to WASM is still the bottleneck\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tJerome_co_ if I am belaboring the obvious_co_ sorry.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI only have one copy of the data structures.Â  It is shared between WebAssembly and Javascript.Â  If you look at the code (from my August 3 post above) you will see that I create the array as WebAssembly memory.Â  Then I create a view into that memory.Â  Javascript or WebAssembly both may address the array at that point.Â  As far as JavaScript is concerned_co_ it is just a typed array.Â  This array is sized/created early in the session and tends to persist for quite a while.Â  In fact_co_ sometimes I clear the array and start over_sm_ as opposed to allocating a new one.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo drive the point home_dd_Â  Sometimes I write the same function in JavaScript and WebAssembly.Â  More specifically_co_ I have already written it in JavaScript and it is working.Â  When I develop the WebAssembly_co_ I set it up so that I can call either _qt_flavor_qt_ of the same function.Â  Given that I don_t_t have a battery of test suites_co_ this helps me spot unintended changes of behavior.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOnce I get things settled_co_ smaller interactions with the array are usually done through JavaScript.Â  Larger ones are done with WebAssembly.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAfter all of this_co_ I am happy with the effort.Â  I did hit many dead ends but I also got several large tasks to run 3X faster.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI hope this is useful.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-09-11T17:02:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t@JCPalmer Â  The _t_.buffer_t_ approach you show in your example with WebGL looks the same as the one for WeAssembly_co_ per my example further above.Â  I think there is a good chance that we can have one buffer with minimal recopying.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSays Pollyanna.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-11T18:26:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tthank you _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/29406-the-leftover/?do_eq_hovercard_qt_ data-mentionid_eq__qt_29406_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/29406-the-leftover/_qt_ rel_eq__qt__qt__gt_@The Leftover_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ll have a last attempt in your way _dd_ allocating and sharing the memory first from JS. Something that the FFI library probably didn_t_t do (I guess it allocates and deallocates everything each call)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-09-12T16:34:40Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI just started a topic in the AssemblyScript Github repo about how to manage shared arrays JS/AS . My test onesÂ were not shared and I guess the data copy (million floats) is the bottleneck.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOne of the guy made a port of earcut to AssemblyScript and this might be a good start to get inspired from.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/AssemblyScript/assemblyscript/issues/263_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/AssemblyScript/assemblyscript/issues/263_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"The Leftover","Date":"2018-09-12T19:28:16Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co_ I see that.Â  I will watch with anticipation.Â  Good luck!!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]