[{"Owner":"splash27","Date":"2017-11-19T12:16:54Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi everyone!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am trying to implement a simple thing. I want the player (FreeCamera) be able to push other objects on scene when he collides with it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe approach I found before is creating of the box and attaching camera to it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLike this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_camera.parent _eq_ playerBox_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tand then attach Impostors to playerBox and other pushable objects.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut I completely don_t_t like this._lt_br /_gt__lt_br /_gt_\n\tBecause_dd_ _lt_br /_gt_\n\t1) Camera falls if playerBox falls after collision. I want the player to be stable while colliding.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\t2) I need to reimplement controls for playerBox_co_ including mouse look. Well_co_ it_t_s easy to make playerBox move along axis (X_co_Y_co_Z). But what about diagonal movement? What about mouse look? I need to reimplement everything that FreeCamera already can do.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo be honest_co_ I just want FreeCamera to have some mass while it collides. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs there an easy way to do this?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2017-11-19T14:31:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHiya splash27_co_ welcome to the forum.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t     I_t_m no pro at these things... but I might have found a solution.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#WWCK0%2371_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#WWCK0#71_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSorry for messy playground.  Test by using up-arrow to drive camera into barrel2_co_ which is straight ahead.  When camera hits barrel2_co_ barrel2 will move away from camera (a small and adjustable amount).  It could use BJS animation or other linear interpolation (lerp)... to move _qt_smoothly_qt_ with ease-to-stop_co_ too_co_ perhaps. That would probably work best IF you want a further-distance mesh-move.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tInteresting places_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tline 68 ... I set a rather fat-belly .ellipsoid on the camera.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_br /_gt_\n\tlines 177-187 ... a mesh backAwayFromCamera function that... does what it says _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_br /_gt_\n\tlines 189-197 ... a camera onCollide func_co_ which calls backAwayFromCamera(meshThatCameraHit)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI did a little sneaky and dangerous thing.  Sometimes_co_ users have a difficult time knowing when a vector3 is a position_co_ and knowing when a vector3 is a direction.  Line 186... uses a direction as a position.  But_co_ what the heck.  The direction [which could be direction.nomalize() as wanted] was a nice little vector3_co_ and I needed a nice little vector3 amount of movement_co_ so I used a direction as an added position.  Not normally a wise thing to do.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tThe subtraction that happens in line 181... is a direction_co_ as its name implies.  The size of _lt_em_gt_direction_t_s_lt_/em_gt_ values is somewhat determined by the distance between the camera center and collidedMesh center WHEN COLLISION HAPPENS.  So_co_ _lt_em_gt_direction_lt_/em_gt_ values vary_co_ depending upon fatness of camera.ellipsoid and mesh.ellipsoid/mesh-size.  Lines 178 and 184 use the _lt_em_gt_mult_lt_/em_gt_ variable as a _qt_how-much-to-move-mesh_qt_ sensitivity setting... which you may need to tweak.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt all seems to work pretty well.  Barrel2 has an actionManager on it_co_ but you can ignore that  (such things would require camera be parented to a mesh_co_ and we both know that sucks). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tUnfortunately_co_ there are no camera-based triggers for actionManagers_co_ and no camera-based observables.  What were they thinking?  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tHope this helps.  At least it might give you some more toys to play-with.  Holler back_co_ as wanted.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"splash27","Date":"2017-11-19T17:23:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThank you _lt_strong_gt__lt_a data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5733-wingnut/?do_eq_hovercard&amp_sm_referrer_eq_http%253A%252F%252Fwww.html5gamedevs.com%252Ftopic%252F34103-how-to-make-freecamera-push-objects%252F_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5733-wingnut/_qt_ style_eq__qt_background-color_dd_transparent_sm_color_dd_inherit_sm__qt_ title_eq__qt_Go to Wingnut_t_s profile_qt_ rel_eq__qt__qt__gt_Wingnut_lt_/a_gt__co_ _lt_/strong_gt_for quick responce!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYeah_co_ it_t_s pretty interesting idea. But what about _qt_physical_qt_ collisions? Like cannonJS impostors do. I want to see barrels falling and bouncing_co_ when I hit them.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs it possible without reinventing controls and mouse look for a playerBox?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2017-11-19T17:50:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tMy pleasure... hi again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tUmm... no... the physics engines need a mesh/gizmo to assign their impostors-to.  And then... yep... gotta use applyImpulse or setLinearVelocity funcs to move the (invisible) camera parent.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd_co_ friction between camGiz and ground... determine _qt_inertia_qt_ of camera (skid-on after thrust shut-off).  Braking can also be used... force-setting linearVelocity quickly to 0_co_0_co_0.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd_co_ the camGiz might need fixedRotation (available) to avoid turning upon impact... but that might fight-with using setAngularVelocity needed to turn player or look-around.  But keep in mind that camera can be turned and tilted even when it has a parent.  Orienting the parent is _lt_strong_gt_not_lt_/strong_gt_ a requirement... to orient camera.  But_co_ it might be wise to _qt_snap_qt_ camera back to forward and level view_co_ when player mesh starts moving... just for user sanity.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tFew have tried it.  Perhaps build a playground with a single physics-active box on a grid/textured ground (textured ground so we can _qt_sense_qt_ how fast/slow we can set camgizmo linearVelocity to GO and STOP with some keypresses).   Interesting issue.  If you make a nice _qt_physics player controller_qt_... you_t_d be a local hero.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t have a handy playground for ya_co_ but perhaps others can help with that_co_ and will have better ideas_co_ or differing opinions.  Stay tuned.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"splash27","Date":"2017-11-20T09:29:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo_co_ I started to implement pushing camera. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSeems like _lt_span style_eq__qt_color_dd_#000000_sm__qt__gt_setLinearVelocity might really work. CannonJS physics already has dissipation. So the mesh will stop after it will pass some distance (depends on velocity given)._lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span style_eq__qt_color_dd_#000000_sm__qt__gt_Another trick is that we could set player_t_s impulse as constant that we will be comfortable with. It_t_s possible_co_ because player_t_s mass and velocity is constant in most cases._lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow it_t_s a really hard thing. I don_t_t know how to get player movement direction. Important to remember that player can collide with meshes when he doesn_t_t even look at. He might look to the sky or go left_co_ right_co_ back before the collision.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI prepared playground with comments. \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#12VV1R_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#12VV1R_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt_t_s not done yet. T_lt_span style_eq__qt_color_dd_#000000_sm__qt__gt_he movementDirectionVector is needed to be calculated._lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-11-20T11:02:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tfunny _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2017-11-20T13:56:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAahh_co_ you decided NOT to use a gizmo-mesh/impostor on the camera itself.  Interesting.  Very creative! \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI was assuming that you would_co_ and MOST of my previous post was talking about how to move/stop the camera gizmo.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAn impostor on the camera would give your impacts... direction angles and restitution power... that the physics engine calculated.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut_co_ as we know... camera nav would be more of a challenge_co_ if the camera parent/gizmo had physics.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnyway_co_ direction.  If you do... _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_var dir _eq_ camera.position.subtract(collidedMesh.getAbsolutePosition())_lt_/span_gt_... you will get a direction... which _lt_strong_gt_might_lt_/strong_gt_ need a _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_.negate()_lt_/span_gt_ to turn it the correct direction.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOr_co_ instead of _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_negate()_lt_/span_gt__co_ you can reverse the subtraction... _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_var dir _eq_ collidedMesh.getAbsolutePosition().subtract(camera.position)_sm__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou would do this direction-deriving... inside of your onCollide func.  (You probably knew that already_co_ but future readers might not.)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd_co_ you already know about scaling a vector3_co_ so you know how to amplify or reduce the magnitude of that direction vector.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOur lights have a _lt_span style_eq__qt_color_dd_#27ae60_sm__qt__gt_.setDirectionToTarget()_lt_/span_gt__co_ useful for directional and spot lights.  It uses the same positional subtraction method. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHope this helps.  Hope I didn_t_t tell you anything incorrect.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_  Congrats on the successful PG tests... well done.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"splash27","Date":"2017-11-20T16:16:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWell_co_ so far it looks like this_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#12VV1R%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#12VV1R#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI also attached WASD controls and free mouse look (without holding left mouse button).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI also made an actor (camera.ellipsoid) taller for the better view.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAlso I decided to divide a player_t_s impulse by mesh_t_s mass. It_t_s more correct way according to conservation of momentum law.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks for help!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_EDIT_dd__lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRealized_co_ that this still is no good_co_ it flies to wrong direction when I go left_co_ right or back before collide it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"splash27","Date":"2017-11-23T11:29:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tGlad to say_co_ that I improved my demo.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI just introduced a so-called kick-height. It_t_s a height between foot and ground when an actor kicks mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt made interactions more realistic and correct. It also fixed some bugs in vectors computations.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is current example_dd_ http_dd_//www.babylonjs-playground.com/#12VV1R#2\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOne last thing that distubs me a little bit is jolting when I continously push the mesh in one direction. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever_co_ maybe it can be fixed by adding throttling for onCollide handling on every particular mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ll try to find out what else I can do.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2017-11-23T13:50:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi again Splash.  Congrats on the improvements... well done!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLet_t_s go back to our no-physics _qt_barrels test scene_qt_...\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#WWCK0%2374_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#WWCK0#74_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAfter load_co_ _lt_u_gt_hold_lt_/u_gt_ the up-arrow... keep pushing against that somewhat-buried-in-ground barrel2.  See the jiggling after collide?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt is MY theory... that these camera _lt_strong_gt_climb-over_lt_/strong_gt_ attempts happen... because the center of the camera.ellipsoid... is _lt_em_gt_some_lt_/em_gt_ _lt_em_gt_amount_lt_/em_gt_ higher (more +Y) than the barrel2.ellipsoid.  The camera.ellipsoid is trying to _lt_strong_gt_climb-over_lt_/strong_gt_ the barrel2.ellipsoid.  The camera.applyGravity is fighting-with those attempts.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLet_t_s run a test.  Look carefully at lines 251-254.  That code waits about 16 _lt_u_gt_minutes_lt_/u_gt_ and then disables camera.applyGravity.  CHANGE that 1000000 to be 1000_co_ and run again.  Then it will disable camera.applyGravity after ONE second.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTry your held up-arrow test again.  See how the camera.ellipsoid _lt_strong_gt_climbs-over_lt_/strong_gt_ the barrel2.ellipsoid?  Camera does not return to ground after _lt_strong_gt_climb-over_lt_/strong_gt_ because camera.applyGravity is disabled.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Climb-overs_lt_/strong_gt__co_ dive-unders_co_ and sideways scrub-offs... happen when two .ellipsoids get pushed-together... when their .ellipsoid center positions don_t_t match.  For example_dd_  IF the camera.ellipsoid center is higher than barrel2.ellipsoid center_co_ then the camera will try to _lt_strong_gt_climb-over_lt_/strong_gt_.  HOW MUCH mis-alignment is needed before a climb-over_co_ dive-under_co_ or side scrub-off happens_co_ you ask?  Good question.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThere is a property called _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/classes/3.1/engine#static-collisionsepsilon-number_qt_ rel_eq__qt_external nofollow_qt__gt_engine.collisionsEpsilon_lt_/a_gt_.  I_t_m quite sure... THAT value... determines the _lt_em_gt_amount_lt_/em_gt_ of ellipsoid mis-alignment that is needed... before any _qt_scrub-off_qt_ happens.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSO_co_ what causes the jiggling/jumping?  You have probably already deduced the answer.  The camera is TRYING to climb-over our low-positioned barrel2_co_ but camera.applyGravity is _lt_em_gt_pulling_lt_/em_gt_ the camera back to the ground.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSolves_dd_  Good question.  Certainly play-with the value of engine.collisionsEpsilon.  Also think about possibilities of disabling camera.applyGravity inside-of onCollide_co_ but re-enable after collision condition is cleared  (IS THERE an onCollideClear()?  Not sure.  Maybe there is an .isColliding or similar on the collider?)   Lastly_co_ think about force-aligning the ellipsoids inside-of onCollide (by temporarily setting barrel2.ellipsoidOffset or camera.ellipsoidOffset... but that is probably not the best way).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Warning_dd__lt_/strong_gt_  I_t_m not sure if .ellipsoidOffset is working at all.  In _lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#WWCK0%2376_qt_ rel_eq__qt_external nofollow_qt__gt_another test_lt_/a_gt__co_ I use the renderLoop to gently increase barrel2.ellipsoidOffset.x value (line 238).  You can see the ellipsoid move right_co_ and the text read-out showing the collider_t_s offset values.  As you can see with up-arrow tests_co_ the collision is still happening AT barrel2 position.  This could be a bug in the framework.  Not sure.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m scared to report it as a bug... without others agreeing that it is broken.  I make many coding mistakes_co_ and this could be another.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tAnyway_co_ perhaps you have a bit more information_co_ now.  If you do some tests involving someMesh.ellipsoidOffset_co_ and learn good/bad things about it_co_ please report them here_co_ okay?  Thanks!  Be well.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]