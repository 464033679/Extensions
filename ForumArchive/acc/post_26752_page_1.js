[{"Owner":"yuccai","Date":"2016-12-01T16:23:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI would like to pick a mesh and moving it around a room which is a simple cube with backside orientation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBasically_co_ it consists on 3 functions called on 3 distinct events\n_lt_/p_gt_\n\n_lt_ol_gt__lt_li_gt_\n\t\tonPointerDown _dd_ I select the mesh I want to move (main mesh) when I click on the mouse\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tonPointerMove _dd_ I select a different mesh in order to move the main mesh when I drag the mouse\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tonPointerUp _dd_ I deselect the main mesh when I release the click of the mouse\n\t_lt_/li_gt_\n_lt_/ol_gt__lt_p_gt_\n\tThe behavior I want to produce is to dragndrop the main mesh on visible faces only and keeping each face belonging to the same mesh (I don_t_t want to create as many meshes as faces).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor instance_co_ when my camera is above the room_co_ the ceiling is transparent and we can see the floor due to the backside orientation of the room. But on step 2_co_ I can_t_t figure out how to pick the face which corresponds to the floor. I only succeed to pick the ceiling. I tried to build a predicate (pickInfo _eq_ scene.pick(x_co_y_co_predicate)) based on faces normales but once a mesh has been evicted from the predicate_co_ it is not recalled_co_ even if more than one face which is intersected.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo I would like to know if there is a way to do what I_t_m expecting to do. When a mesh has succeed the predicate_co_ how the returned pickInfo is built ? The selected face (pickInfo.pickedPoint) is always the nearest from the camera ? Is is possible the return an array of valid meshes with an another array containing its corresponding faces intersected ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is a PG relating my issue _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1V3CAT%23185_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1V3CAT#185_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks\n_lt_/p_gt_\n\n_lt_p_gt_\n\t  \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2016-12-03T14:33:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHiya _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/9254-yuccai/?do_eq_hovercard_qt_ data-mentionid_eq__qt_9254_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/9254-yuccai/_qt_ rel_eq__qt__qt__gt_@yuccai_lt_/a_gt__co_ good to see you again.  Sorry it has taken so long to get a reply.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1DE6PV%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1DE6PV#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAbove_co_ I am just screwing around.  Got some crappy box-dragging happening... without being blocked by room.  Changed isPicked to pickedMesh... just some assorted testing crap.  For accurate drag_t_n_t_drop_co_ it might be wise to start with the _lt_a href_eq__qt_http_dd_//babylonjs-playground.azurewebsites.net/?18_qt_ rel_eq__qt_external nofollow_qt__gt_Drag_t_n_t_Drop Playground Demo_lt_/a_gt_ and make the ground (which is REQUIRED in that demo)... be invisible.  (place its invisible ground behind/beneath your room).  Dragging mesh in a 3D world... using a 2d pointer... is a challenge.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs far as using picking (or using the new multi-pick)... to pick multiple _lt_u_gt_faces_lt_/u_gt_ (and possibly store all hit faces in an array)... using a backside box such as _lt_em_gt_room... _lt_/em_gt_that might be impossible (so far).  I have never heard of anyone doing it before.  The picked face will always be the one closest to camera (unless the ray is fired from the far side of the room). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI think most people would make the room... from 6 separate planes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut I DO see your hope.  If room picking (floor_co_ walls) would ALWAYS ignore the face that is closest to the camera (such as a room ceiling)... then you could get proper and correct face clicking (click upon inside walls and floor_co_ and get the correct pickingInfo.faceID_t_s).  This is a cool challenge.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOnce upon a time_co_ I was asked to remove the top... from a BJS box.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1KH9RY%238_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1KH9RY#8_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI just used my trusty _qt_indices chainsaw_qt__co_ and hacked some indices.  The top of the box disappeared.  I don_t_t think this method will work for you_co_ but i thought I would show you.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tFellow forum users... Yuccai is needing a picker... which IGNORES pickingInfo.faceID that are not rendered.  In other words... if you can see-thru the face_co_ don_t_t allow picking of IT.  Only pick the first RENDERED faceID that the ray hits.  Pick PAST see-thru faces_co_ and only hit the first (and maybe collect ALL...) faces that ARE rendered and can be seen.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat a stalwart challenge!  This might require coding a custom picker (a modification of the default BJS picking system).  This custom picker would test HIT face-normals... checking if the face is see-thru (back-sided).  If it IS a hit on a backfaced face_co_ ignore this pickedPoint/faceID and continue the ray further... until it hits a non-backfaced face.  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_  (what a sentence!)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI will keep thinking and perhaps try a custom picker (scary_co_ I_t_m not a very good coder).  Hopefully_co_ others will comment and have more wisdom.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"yuccai","Date":"2016-12-05T16:41:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIn fact it was not as difficult as I thought_co_ I just added my predicate (which consists in checking the sign of the face normal with the intersecting ray) for each faces intersected. I had to patch the following function of Babylon.js _dd_ \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_SubMesh.prototype.intersects _eq_ function (ray_co_ positions_co_ indices_co_ fastCheck) {\n    var intersectInfo _eq_ null_sm_\n    // LineMesh first as it_t_s also a Mesh...\n    if (this._mesh instanceof BABYLON.LinesMesh) {\n        var lineMesh _eq_ this._mesh_sm_\n        // Line test\n        for (var index _eq_ this.indexStart_sm_ index &lt_sm_ this.indexStart + this.indexCount_sm_ index +_eq_ 2) {\n            var p0 _eq_ positions[indices[index]]_sm_\n            var p1 _eq_ positions[indices[index + 1]]_sm_\n            var length _eq_ ray.intersectionSegment(p0_co_ p1_co_ lineMesh.intersectionThreshold)_sm_\n            if (length &lt_sm_ 0) {\n                continue_sm_\n            }\n            if (fastCheck || !intersectInfo || length &lt_sm_ intersectInfo.distance) {\n                intersectInfo _eq_ new BABYLON.IntersectionInfo(null_co_ null_co_ length)_sm_\n                if (fastCheck) {\n                    break_sm_\n                }\n            }\n        }\n    }\n    else {\n        // Triangles test\n        for (var index _eq_ this.indexStart_sm_ index &lt_sm_ this.indexStart + this.indexCount_sm_ index +_eq_ 3) {\n            var p0 _eq_ positions[indices[index]]_sm_\n            var p1 _eq_ positions[indices[index + 1]]_sm_\n            var p2 _eq_ positions[indices[index + 2]]_sm_\n            var p0p1 _eq_ p0.subtract(p1)_sm_\n            var p2p1 _eq_ p2.subtract(p1)_sm_\n            var normal _eq_ BABYLON.Vector3.Cross(p0p1_co_ p2p1)_sm_\n            if(BABYLON.Vector3.Dot(ray.direction_co_ normal) &lt_sm_ 0 ) {\n                var currentIntersectInfo _eq_ ray.intersectsTriangle(p0_co_ p1_co_ p2)_sm_\n                if (currentIntersectInfo) {\n                    if (currentIntersectInfo.distance &lt_sm_ 0) {\n                        continue_sm_\n                    }\n                    if (fastCheck || !intersectInfo || currentIntersectInfo.distance &lt_sm_ intersectInfo.distance) {\n                        intersectInfo _eq_ currentIntersectInfo_sm_\n                        intersectInfo.faceId _eq_ index / 3_sm_\n                        if (fastCheck) {\n                            break_sm_\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return intersectInfo_sm_\n}_sm_\n _lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThe changes are effected on triangles test side. From the 3 vertices of the face_co_ I calculate the normal and then I check the dot sign of this normal with the ray direction. If it is positive (the ray and the face are oriented in the same way)_co_ it means that the face is back to camera_co_ thus invisible in a back face culling mesh. So I keep only negative dot product.   \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]