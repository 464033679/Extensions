[{"Owner":"lst60916","Date":"2017-08-21T08:54:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi_co_ my friends_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRecently I try TOB ( tower of babel) exporter to get the mesh for babylonjs.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI try to export the shape keys under the group of ENTIRE_MESH config.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever_co_ after I deform another shape key after the first shape key is deformed completely.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI find it initially referenced the BASIS shape key group and then execute the next shape key .\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt seems to be fixed in the QI lib.js .\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m wondering if there is any approach that I can make the following happens? \n_lt_/p_gt_\n\n_lt_p_gt_\n\t------------------------------------------\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBlender ShapekeyA ( from 0~1_co_ default as 0)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBlender ShapekeyB ( from 0~1_co_ default as 0)\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_key _eq_ Qi.deformation(_qt_ENTIRE_MESH_qt_  _co__qt_ShapekeyA_qt__co_ 1 _co_ duration)\nmesh.queueSingleEvent(key)_sm_\nkey _eq_ Qi.deformation(_qt_ENTIRE_MESH_qt_  _co__qt_ShapekeyB_qt__co_ 1 _co_ duration)\nmesh.queueSingleEvent(key)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t_eq__eq__eq__eq__eq__eq__eq_&gt_sm_ in the recommened way_co_ finally_co_ I can get the mesh with (ShapekeyA_eq_1 )&amp_sm_&amp_sm_ (ShapekeyB_eq_1)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tinstead of  ( ShapekeyA returing to BASIS ) &amp_sm_&amp_sm_ ( ShapekeyB_eq_1) \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAny advice will be appreciated \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you so much!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2017-08-21T15:08:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIf you are referring to multiple key mixing.   QI is built for multi-key mixing (24 key mixing _lt_a href_eq__qt_https_dd_//palmer-jc.github.io/scenes/QueuedInterpolation/automaton/index.html_qt_ rel_eq__qt_external nofollow_qt__gt_example_lt_/a_gt_).  The QI.Deformation class is actually a simplified subclass of _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Extensions/blob/master/QueuedInterpolation/src/deformation/shapeKeyBased/VertexDeformation.ts_qt_ rel_eq__qt_external nofollow_qt__gt_QI.VertexDeformation_lt_/a_gt_.  QI.Deformation is useful when you only have one target key_co_ &amp_sm_ deforming from basis.  There is even a further simplified form_co_ called directly thru the mesh_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_mesh.queueDeform(_qt_ENTIRE_MESH_qt__co_ _qt_KEYA_qt__co_ 1_co_ duration)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tQI.VertexDeformation handles mixing.  One way would be_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_mesh.queueSingleEvent(new QI.Deformation(_qt_ENTIRE_MESH_qt__co_ _qt_KEYA_qt__co_ 1_co_ duration))_sm_\nmesh.queueSingleEvent(new QI.VertexDeformation(_qt_ENTIRE_MESH_qt__co_ _qt_BASIS_qt__co_ [_qt_KEYA_qt__co__qt_KEYB_qt_]_co_[1_co_1]_co_ duration))_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThe way to think about it is_co_ you as a developer do not care what might be or will be when you submit queue a target to morph to.  When a deformation is finally executed_co_ diffs what ever the current state is with the target requested.  If you had to keep track of what the state of QI.ShapeKeyGroup was_co_ it would be much more difficult.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_eq_ _eq_ _eq_ _eq_ _eq_ _eq_ _eq_ _eq_ _eq_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you are referring to independent areas of the same mesh.  You may have multiple QI.ShapeKeyGroup on the same mesh.  On the example above_co_ the eyes and the eyelids each have there own groups.  To do that in Blender_co_ set the names of the keys in the format _qt_GROUP1-KEYA_qt_ &amp_sm_ _qt_GROUP2-KEYB_qt_.  You might then_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_mesh.queueDeform(_qt_GROUP1_qt__co_ _qt_KEYA_qt__co_ 1_co_ duration)_sm_\nmesh.queueDeform(_qt_GROUP2_qt__co_ _qt_KEYB_qt__co_ 1_co_ duration)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tEach group has it own independent queue_co_ so if nothing was in either queue_co_ both would happen at the same time.  If you wanted them run sequentially_co_ you could_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var preReq _eq_ mesh.queueDeform(_qt_GROUP1_qt__co_ _qt_KEYA_qt__co_ 1_co_ duration)_sm_\nmesh.queueDeform(_qt_GROUP2_qt__co_ _qt_KEYB_qt__co_ 1_co_ duration_co_ null_co_ null_co_ {requireCompletionOf_dd_ preReq})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tNote for multiple groups_co_ beware of conflicting groups deforming the same vertices_co_ _lt_a href_eq__qt_https_dd_//palmer-jc.github.io/scenes/QueuedInterpolation/multi_shapekey_groups/index.html_qt_ rel_eq__qt_external nofollow_qt__gt_see_lt_/a_gt_.  Also_co_ from the Automaton example above_co_ FACE &amp_sm_ EYELIDS share.  See how expressions have a blinkable setting to avoid conflicts?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"lst60916","Date":"2017-08-29T15:57:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tThanks so much !!!\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2017-08-29T16:16:40Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tremember to tag it solved\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-08-29T22:32:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI did it\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]