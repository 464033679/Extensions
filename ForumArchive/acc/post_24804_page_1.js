[{"Owner":"Pryme8","Date":"2016-08-27T16:55:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIm trying to find the shortest length vector between two vec2_t_s for my tutorial im writing up...\n_lt_/p_gt_\n\n_lt_pre title_eq__qt_projection function_qt__gt_\nfunction project(a_co_ b){\n var proj _eq_ new Array(a.length)_sm_\n  var  bt _eq_ 0_sm_\n   for(var i _eq_ 0_sm_ i &lt_sm_ a.length_sm_ i++){\n    bt+_eq_ (b[i]*b[i])_sm_\n   }\n   for(var i _eq_ 0_sm_ i &lt_sm_ a.length_sm_ i++){\n    proj[i] _eq_ (dot(a_co_b)/bt)*b[i]_sm_\n  }\nreturn proj\n}_lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAny one know if this is correct or have any good websites that go over it?  Im having trouble finding good documentation on what Im trying to explain... I mean I get it in my head but being able to communicate that to someone else is rather hard.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JohnK","Date":"2016-08-27T18:25:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIf by vec2s you mean position vectors then the length between them is just the distance between the two points_co_ which is (b - a).length.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut I am not sure this is what you mean.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"slipstart","Date":"2016-08-27T22:48:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tPerhaps if you gave us an example of what you were trying to do it would be easier to understand.  It almost looks like you are trying to find a new vector from one to another.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-28T00:14:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tita for collision detection stuff_co_ it_t_s the shortest vector distance that the point needs to travel in to not be in collision. Is what I_t_m trying to work out.  I want to do projection collision detection.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-28T05:01:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tFigured it out... found a good web book.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2016-08-28T10:47:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tPlease provide the link to the web book.  Thanks\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-28T14:55:40Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//books.google.com/books?id_eq_TnwZBwAAQBAJ&amp_sm_printsec_eq_frontcover&amp_sm_source_eq_gbs_ge_summary_r&amp_sm_cad_eq_0#v_eq_onepage&amp_sm_q&amp_sm_f_eq_false_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//books.google.com/books?id_eq_TnwZBwAAQBAJ&amp_sm_printsec_eq_frontcover&amp_sm_source_eq_gbs_ge_summary_r&amp_sm_cad_eq_0#v_eq_onepage&amp_sm_q&amp_sm_f_eq_false_lt_/a_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-28T15:37:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_m working on a pretty extensive tutorial right now_co_ showing how to deploy web workers as a underlying physics engine for a custom canvas.  And I got to the collision testing part and realized that even though I know how to do it I had no clue how to properly explain it which made me think that maybe I don_t_t know it as well as I though and so Ive been read read reading..._lt_br /_gt__lt_br /_gt_\n\tI needed to learn web workers to increase calculation time on my Das Noise Library_co_ and to make it when i launch the  TERIABLE Demo all the calculations/procedural I/O crunching will happen on a sub thread to make everything flow better._lt_br /_gt__lt_br /_gt_\n\tAnd then somehow a web worker tutorial now has slowly turned into a Calculus lesson for estimating logarithmic pseudo distance...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthis is the part I just wrote o_O_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_qt_This is where the method for separating axes comes into play. If you look at our diagram on the right you will see two polygons. Both of these shapes are called Convex Shapes. A Convex shape is an_lt_span_gt_y polygon that can be defined by a set of points_co_ that if you were to draw a straight line anywhere on the shape from one point to another on the polygon_co_ the line will never travel outside of the shape. Anyways these two Convex polygons are in a non intersecting state._lt_/span_gt_\n_lt_/p_gt_\n\n_lt_div_gt_\n\t_lt_p_gt_\n\t\tThe value for the separation is positive and so we know that the shapes are not touching_co_ if it was negative the shapes would be overlapping and if it was 0 the shapes are just touching. With this kind of hit detection there would be three kinds of possible contact_co_ edge to edge_co_ vertex to edge_co_ and vertex to vertex. If we were to draw a line between the two polygons and pretend the separation line continues to infinity and then draw a line perpendicular to this line_co_ that is our separation axis._qt__lt_br /_gt__lt_br /_gt_\n\t\tIm up to 23 pages &gt_sm__&lt_sm_ and just got through basic terminology and calculations... this turned into a way bigger project then I intended... but I see the information as super super valid cause I_t_m digesting what PHD people are saying and try to break it down in a more simplistic way for the masses of us that did not go to college for Math.\n\t_lt_/p_gt_\n_lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]