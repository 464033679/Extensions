[{"Owner":"jerome","Date":"2016-10-25T08:01:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi people_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs this has been requested from time to time on this forum_co_ here is a simple and fast method for computing any mesh area _dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    var area _eq_ function(mesh) {\n        if (!mesh) {\n            return 0.0_sm_\n        }\n        var indices _eq_ mesh.getIndices()_sm_\n        var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind)_sm_\n        var v1x _eq_ 0.0_sm_\n        var v1y _eq_ 0.0_sm_\n        var v1z _eq_ 0.0_sm_\n        var v2x _eq_ 0.0_sm_\n        var v2y _eq_ 0.0_sm_\n        var v2z _eq_ 0.0_sm_\n        var crossx _eq_ 0.0_sm_\n        var crossy _eq_ 0.0_sm_\n        var crossz _eq_ 0.0_sm_\n        var ar _eq_ 0.0_sm_\n        var i1 _eq_ 0_sm_\n        var i2 _eq_ 0_sm_\n        var i3 _eq_ 0_sm_\n        var nbFaces _eq_ indices.length / 3_sm_\n\n        for (var i _eq_ 0_sm_ i &lt_sm_ nbFaces_sm_ i++) {\n            i1 _eq_ indices[i * 3]_sm_\n            i2 _eq_ indices[i * 3 + 1]_sm_\n            i3 _eq_ indices[i * 3 + 2]_sm_\n            v1x _eq_ positions[i1 * 3] - positions[i2 * 3]_sm_\n            v1y _eq_ positions[i1 * 3 + 1] - positions[i2 * 3 + 1]_sm_\n            v1z _eq_ positions[i1 * 3 + 2] - positions[i2 * 3 + 2]_sm_\n            v2x _eq_ positions[i3 * 3] - positions[i2 * 3]_sm_\n            v2y _eq_ positions[i3 * 3 + 1] - positions[i2 * 3 + 1]_sm_\n            v2z _eq_ positions[i3 * 3 + 2] - positions[i2 * 3 + 2]_sm_\n            crossx _eq_ v1y * v2z - v1z * v2y_sm_\n            crossy _eq_ v1z * v2x - v1x * v2z_sm_\n            crossz _eq_ v1x * v2y - v1y * v2x_sm_ \n            ar _eq_ ar + Math.sqrt(crossx * crossx + crossy * crossy + crossz * crossz)_sm_\n        }\n        return ar * 0.5_sm_\n    }_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tAs it doesn_t_t allocate any object_co_ nor calls external functions_co_ it should be fast_co_ GC friendly and it might be called within the render loop.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tJust let me know if you want it to be integrated in BJS as a method of the class Mesh or AbstractMesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t[EDIT] For experts_co_ note that this computation could be shared and done in one line only within the method _lt_em_gt_ComputeNormals()_lt_/em_gt_ of the class _lt_em_gt_VertexData _lt_/em_gt_just after this line _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2007_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2007_lt_/a_gt_  with something like _dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_area +_eq_ length * 0.5_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]