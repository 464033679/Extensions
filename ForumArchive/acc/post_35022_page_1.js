[{"Owner":"dbawel","Date":"2018-01-11T23:55:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have a script due tomorrow morning_co_ and have asked a question on a seperate post which is the ideal solution. The only other solution I could show have for tomorrow is to start the renderloop_co_ load an OBJ_co_ and then dispose of the scene - but then the scene needs to begin loading new meshes after it detects a new path and mesh in an array_co_ and render without any client interaction.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI can_t_t figure out how to load several scenes - lets say 5 scenes - and load scene 1 for 30 seconds_co_ destroy scene one_co_ on destroy scene two loads on it_t_s own_co_ and this process continues until scene 5 is loaded and then disposed.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2018-01-12T00:29:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWhat happens if you do something like_dd__lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var sceneArr _eq_ [s1_co_s2_co_s3_co_s4]_sm_\nvar activeScene _eq_ sceneArr[0]_sm_\nvar timeChunk _eq_ 30000_sm_\n\nsetTimeout(()_eq_&gt_sm_{\nactiveScene.dispose()_sm_\nactiveScene _eq_ sceneArr[1]}_co_timeChunk)_sm_\nsetTimeout(()_eq_&gt_sm_{\nactiveScene.dispose()_sm_\nactiveScene _eq_ sceneArr[2]}_co_timeChunk*2)_sm_\nsetTimeout(()_eq_&gt_sm_{\nactiveScene.dispose()_sm_\nactiveScene _eq_ sceneArr[3]}_co_timeChunk*3)_sm_\n\n\nengine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene\nactiveScene.render()_sm_\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tMight work... there is way better logic for this_co_ bit this should be simple to understand.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-01-12T22:13:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYou might wish to keep one scene.  All meshes for _qt_scene 1_qt_ would have layermask of 1_co_  _qt_scene 2_qt_ layermask of 4_co_ _qt_scene 3_qt_ layermask of 8.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you added a point light on your camera (light follows camera) _co_ and set the layermask of them for the scene to currently display_co_ then the other _qt_scenes_qt_ meshes would simply be in-active.  Disposing of scenes could be disruptive.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-01-12T22:46:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/11286-dbawel/?do_eq_hovercard_qt_ data-mentionid_eq__qt_11286_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/11286-dbawel/_qt_ rel_eq__qt__qt__gt_@dbawel_lt_/a_gt__co_ had to walk the dog before it got nasty.  What I meant by camera light is_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var light _eq_ new BABYLON.PointLight(_qt_cam-light_qt__co_ new BABYLON.Vector3(0_co_ 0_co_ 0)_co_ scene)_sm_\nlight.intensity _eq_ 0.8_sm_\nscene.beforeCameraRender _eq_ function () {\n    // move the light to match where the camera is\n    light.position _eq_ scene.activeCamera.position_sm_\n    light.rotation _eq_ scene.activeCamera.rotation_sm_\n}_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]