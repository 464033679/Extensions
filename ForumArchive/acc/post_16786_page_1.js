[{"Owner":"garidan","Date":"2015-08-27T09:04:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have a multiview_co_ 3 cameras and viewports_co_ and switching from _qt_old way_qt_ to manage actions to the actionmanager one._lt_br_gt_I use ExecuteCodeAction with trigger OnLeftPickTrigger and it does activate an event only on one of the views_co_ so one camera only._lt_br_gt_RegisterAction has no camera parameter thus I would expect babylon manages the right camera for picking meshes_co_ based on viewports and mouse coordinates_co_ but it does not seem the case._lt_br_gt_Any clue or suggestion?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"garidan","Date":"2015-08-27T09:12:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The _qt_working_qt_ camera is the last one pushed as active_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"garidan","Date":"2015-08-27T10:10:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_OK_co_ I see _qt__lt_span style_eq__qt_color_dd_rgb(0_co_134_co_179)_sm_font-family_dd_Consolas_co_ _t_Liberation Mono_t__co_ Menlo_co_ Courier_co_ monospace_sm_font-size_dd_12px_sm__qt__gt_cameraToUseForPointers_lt_/span_gt__qt_ in source code of scene....._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_this.cameraToUseForPointers _eq_ null_sm_ // Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position_lt_/pre_gt__lt_p_gt_Using multiviews_co_ and perhaps in other multi camera usecases_co_ this cameraToUseForPointers should be dynamically determined_co_ in my case based on pointer coordinates._lt_br_gt_Any clue_co_ or any idea for a patch/future enhancements ?_lt_/p_gt__lt_p_gt__lt_br_gt_ _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"garidan","Date":"2015-08-27T10:27:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I think the right place where I could override and change behaviour is _updatePointerPosition_dd__lt_br_gt_ _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_        Scene.prototype._updatePointerPosition _eq_ function (evt) {            var canvasRect _eq_ this._engine.getRenderingCanvasClientRect()_sm_            this._pointerX _eq_ evt.clientX - canvasRect.left_sm_            this._pointerY _eq_ evt.clientY - canvasRect.top_sm_            if (this.cameraToUseForPointers) {                this._pointerX _eq_ this._pointerX - this.cameraToUseForPointers.viewport.x * this._engine.getRenderWidth()_sm_                this._pointerY _eq_ this._pointerY - this.cameraToUseForPointers.viewport.y * this._engine.getRenderHeight()_sm_            }        }_sm__lt_/pre_gt__lt_p_gt_Here I could change cameraToUseForPointers dynamically_co_ with no side effects (?) right ?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-08-27T16:51:31Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Sounds good to me_dd_)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"garidan","Date":"2015-09-10T14:38:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_OK_co_ I did it this way_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var createScene _eq_ function() { BABYLON.Scene.prototype._updatePointerPosition _eq_ function (evt) {\tvar canvasRect _eq_ this._engine.getRenderingCanvasClientRect()_sm_        this._pointerX _eq_ evt.clientX - canvasRect.left_sm_        this._pointerY _eq_ evt.clientY - canvasRect.top_sm_\tthis.cameraToUseForPointers_eq_getViewportCamera(this._pointerX_co_ this._pointerY)_sm_ }......_lt_/pre_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var getViewportCamera _eq_ function(x0_co_y0) {\tvar canvas _eq_  engine.getRenderingCanvas()_sm_\t// reverse y axis_co_ apply scale -&gt_sm_ xy origin in lower left corner\ty _eq_ (perspectiveGlobalView.height - y0/engine.getHardwareScalingLevel())_sm_\tx _eq_ x0/engine.getHardwareScalingLevel()_sm_        // logic hereafter depends on your cameras layout_co_ code could be generalized here\t// default camera\tres _eq_ sideCamera_sm_\tif (x &gt_sm_ perspectiveGlobalView.x &amp_sm_&amp_sm_ x &lt_sm_ (perspectiveGlobalView.x+perspectiveGlobalView.width)) {\t\tif (y &gt_sm_ perspectiveGlobalView.y &amp_sm_&amp_sm_ y &lt_sm_ (perspectiveGlobalView.y+perspectiveGlobalView.height))\t{\t\t\tres _eq_ camera_sm_\t\t}\t} else if (x &gt_sm_ topGlobalView.x &amp_sm_&amp_sm_ x &lt_sm_ (topGlobalView.x+topGlobalView.width)) {\t\tif (y &gt_sm_ topGlobalView.y &amp_sm_&amp_sm_ y &lt_sm_ (topGlobalView.y+topGlobalView.height))\t{\t\t\tres _eq_ topCamera_sm_\t\t}\t}\t\treturn res_sm_}_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]