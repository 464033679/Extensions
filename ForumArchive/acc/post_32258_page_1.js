[{"Owner":"santarcade","Date":"2017-08-09T10:11:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello_co__lt_br /_gt_\n\tthe game I_t_m currently working on will be multi-player and needs to show replays. Instead of snapshotting complete game states_co_ I would like to have a deterministic engine_co_ so supplying the same initial state and the same inputs should result in same state evolutions over time._lt_br /_gt_\n\tTo achieve this_co_ I need physics and animations to be frame-rate independent and to be in sync with each other.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe idea is quantize the state execution time_co_ by updating the game state at a fixed frequency_co_ keeping an accumulator so to carry over exceeding time to the next frame update (the code would be similar to the one featured by CannonJS in its step function. The amount of internalStep can be capped to a maximum value_co_ to avoid accumulating delay into the so-called spiral of death.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI would be patching BABYLON.Scene.render() code_co_ which is where animations and physics steps are triggered_co_ by adding a conditional change if BABYLON.Engine is constructed with deterministicLockstep flag set to true_co_ defaulting to false to keep compatibility with today code._lt_br /_gt_\n\tI would add even a couple of observable events like onBeforeInternalStepObservable and onAfterInternalStepObservable so to be able to plug game logic code to execute before and after each internal discrete step.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo_co_ particularly to _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ would a pull request matching the criteria above be accepted?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you in advance_co__lt_br /_gt_\n\tsantarcade\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-08-09T21:27:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tIt will with pleasure!\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"brianzinn","Date":"2017-08-11T03:34:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tSounds like a great addition.  I have setup my game so it is self testing.  A page loads a scene and interactions occur with physics running - then I make assertions on the end result to ensure that the game is working as expected.  Different scenes run to completion in succession like a test fixture - using a BDD style testing (given - when - then).  I think your proposal would be useful as it would be an even stronger guarantee.  ie_dd_ even though it always passes on my machine I wonder about slower/faster machines.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"santarcade","Date":"2017-08-11T07:52:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk_co_ I made a PR for this._lt_br /_gt_\n\tTo explain the change briefly_co_ this new feature can be enabled with_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_this.engine _eq_ new BABYLON.Engine(theCanvas_co_ true_co_ {\n  deterministicLockstep_dd_ true_co_\n  lockstepMaxSteps_dd_ 4\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThis way_co_ the scene will render quantizing physics and animation steps by discrete chunks of the timeStep amount_co_ as set in the physics engine. For example_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let physEngine _eq_ new BABYLON.CannonJSPlugin(false)_sm_\nnewScene.enablePhysics(this.gravity_co_ physEngine)_sm_\nphysEngine.setTimeStep(1/60)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tWith the code above_co_ the engine will run discrete steps at 60Hz (0.01666667s) and_co_ in case of a late frame render time_co_ it will try to calculate a maximum of 4 steps (lockstepMaxSteps) to recover eventual accumulated delay_co_ before rendering the frame._lt_br /_gt_\n\tNote that when explicitly creating the CannonJSPlugin_co_ it is important to pass false as _useDeltaForWorldStep parameter in constructor_co_ to disable CannonJS internal accumulator.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo keep all the game logic in sync with the steps_co_ I_t_ve added a couple of callbacks that can be registered on the scene_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_newScene.onBeforeStepObservable.add(function(theScene){\n  console.log(_qt_Performing game logic_co_ BEFORE animations and physics for stepId_dd_ _qt_+theScene.getStepId())_sm_\n})_sm_\n\nnewScene.onAfterStepObservable.add(function(theScene){\n  console.log(_qt_Performing game logic_co_ AFTER animations and physics for stepId_dd_ _qt_+theScene.getStepId())_sm_\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tAs soon as there will be a playground available with this version_co_ I will make a sample showing all the code above.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tA room for possible improvement that requires some overview is in my change in scene.render()._lt_br /_gt_\n\tFor internalSteps (non-rendered steps calculated when performing multiple steps inside a single frame)_co_ I had to add this call_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_                if((internalSteps&gt_sm_1) &amp_sm_&amp_sm_ (this._currentInternalStep !_eq_ internalSteps-1)) {\n                    // Q_dd_ can this be optimized by putting some code in the afterStep callback?\n                    // I had to put this code here_co_ otherwise mesh attached to bones of another mesh skeleton_co_\n                    // would return incorrect positions for internal stepIds (non-rendered steps)\n                    this._evaluateActiveMeshes()_sm_\n                }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tOtherwise I experimented divergences (game state desynchronization) on some internalSteps on the absolutePositions of meshes attached to other meshes bones._lt_br /_gt_\n\tAs if proper skeleton calculation are performed only when some code internal to this function is executed._lt_br /_gt__lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt__dd_ is the above call reasonable to be kept there or should we define a best practice of functions to call in the before/after step_co_ to keep skeleton transforms in sync?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest_co__lt_br /_gt_\n\tsantarcade\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-08-11T17:26:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI did some comments on your PR but basically the only issue I see is that it relies on the physics engine and this should be avoided\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"santarcade","Date":"2017-08-16T14:23:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk_co_ I should have fixed the things pointed out by _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow the engine is properly deterministic_co_ same scene with same inputs evolves in the same manner over different browsers and platform. I tested on MacOS_co_ Linux_co_ Windows_co_ iOS_co_ Android on different platforms and browsers_co_ and I only got minor differences caused by floating point rounding (past the 11th decimal position)._lt_br /_gt_\n\tA truncation of floating point values at a good decimal position should be enough to guarantee a good screening of this problem_dd_ in my case this will be directly workaround by periodical re-sync of game state.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow I see another very good enhancement subject for BabylonJS._lt_br /_gt_\n\tAt the moment_co_ the game loop looks something like this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_for(discreteTicksToDo in Math.floor(elapsedFrameTime / fixedUpdateTime)) {\n  updatePhysics()_sm_\n  updateAnimations()_sm_\n  updateGameLogic()_sm_\n}\n\n// will render the actual game world after last discrete game tick\nrender()_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThis is very nice since it makes sure the world is coherent and deterministic_co_ offering the same experience at any given tick_co_ eg_dd_ even showing a replay on a different machine._lt_br /_gt_\n\tBut it comes with a drawback!_lt_br /_gt_\n\tConsider a game running at 60 FPS_co_ with a fixed update loop at 60FPS_dd_ when frames are rendered at 60 FPS steadily_co_ the game runs very smoothly._lt_br /_gt_\n\tIf_co_ instead_co_ a frame arrives late_co_ say between step 100 and step 101 instead of 0.0167s it takes 50% more_co_ the game will result shattering._lt_br /_gt_\n\tThe reason of that is_dd_ the step being rendered will be 101_co_ as if there was no delay_co_ while to smooth things out it should render a frame in the middle between step 101 and step 102.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tA way to solve this is keeping a buffer of the last two game states and what is being rendered is an interpolation of these two. So while the real tick being calculated is step 102_co_ what is shown on screen is an interpolation of steps 100 and 101_co_ according to how late the last frame was.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe big enhancement can be evicted by the following screen-shot_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ data-fileid_eq__qt_14462_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2017_08/profiler.png.dfe4eae489cc6878d36cbaf271faa735.png_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_profiler.thumb.png.9cf18e77eeaeee04add57c3dc1013842.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_14462_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2017_08/profiler.thumb.png.9cf18e77eeaeee04add57c3dc1013842.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe more internalSteps  needed between frames_co_ the higher the risk is to degrade the next frame time_co_ while for half of frame time the CPU is idle._lt_br /_gt_\n\tLong story short_dd_ according to me it would be VERY nice to split the code responsible of rendering with the one responsible of calculating the game state.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn my dream world_co_ we should have two threads_dd_\n_lt_/p_gt_\n\n_lt_ol_gt__lt_li_gt_\n\t\tthe render loop triggered by requestAnimationFrame_co_ responsible of doing a dumb interpolation of the last two game state snapshots\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tthe game tick loop_co_ put inside a web worker_co_ responsible of keeping the game state buffer up to date.\n\t_lt_/li_gt_\n_lt_/ol_gt__lt_p_gt_\n\tDoes this ring true to you? Do you see a technical issue with web workers to achieve this?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest_co__lt_br /_gt_\n\tsantarcade\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPS._lt_br /_gt_\n\tI realized this could be moved on a new thread. I will if there is enough traction.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-08-16T16:54:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJust a tiny comment and I_t_ll merge your change\n_lt_/p_gt_\n\n_lt_p_gt_\n\tregarding your dream_co_ I don_t_t see it in bjs for now because_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Webworkers shared buffers are not available everywhere (and this is te only performant way to communicate between threads)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Even if we rely on shared buffers they are just float32 buffers so it _t_s gonna be tough to simply use them\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-08-16T16:59:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\toh and by the way_dd_ thanks a lot for this contribution.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDo you mind updating this doc page as well to explain your great addition_dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/animations_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/tutorials/animations_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"santarcade","Date":"2017-08-17T12:53:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tOk_co_ I will do it.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"RelativeNull","Date":"2017-10-20T09:41:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tHey _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/16634-santarcade/?do_eq_hovercard_qt_ data-mentionid_eq__qt_16634_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/16634-santarcade/_qt_ rel_eq__qt__qt__gt_@santarcade_lt_/a_gt_ _co__lt_br /_gt__lt_br /_gt_\n\tOne note_co_ probably you should mention that this addition is available only in the 3.1 alpha preview. People may be thinking that it is already available in the 3.0 stable version._lt_br /_gt_\n\tAlso_co_ I saw that you set a default timestep value when one is not ommited through a physic engine. Probably in cases when we don_t_t have a physic engine setup we might still want to change the value. It would make sense in my opinion to have a function say engine.setTimeStep(60.0 / 1000.0) .\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]