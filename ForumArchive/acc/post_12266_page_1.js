[{"Owner":"jerome","Date":"2015-02-04T15:58:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I feel a bit confused at setting positions_co_ indices and UVs on a mesh._lt_/p_gt__lt_p_gt_My problem is I want to reuse vertices to have good normals on a circular or closed mesh (a cylinder or torus for example) AND stretch a texture uniformly on this mesh._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Say_co_ I have a path A of 4 vectors3 _dd_ A0_co_ A1_co_ A2_co_ A3_lt_/p_gt__lt_p_gt_and another path B of 4 vectors3 _dd_ B0_co_ B1_co_ B2_co_ B3_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_For convinience_co_ imagine they all have z_eq_0_co_ A has y _eq_ 1_co_ B has y _eq_0_co_ and just x varies along A and B._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you draw two horizontal parallel lines A and B and then mark A0...A3 on one and B0...B3 on the other_co_ you_t_ll understand what I mean._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_My final mesh is the surface between A and B._lt_/p_gt__lt_p_gt_But I want only 3 segments per path too _dd_ [A0_co_ A1]_co_ [A1_co_ A2]_co_ [A2_co_ A0]_co_ so _lt_u_gt_A0 and A3 are the same vector3_lt_/u_gt_._lt_/p_gt__lt_p_gt_The same with B._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_When setting my positions_co_ I push the four point (A0 to A3) coordinates in the _lt_em_gt_positions_lt_/em_gt_ array. So I declare actually 4 vertices._lt_/p_gt__lt_p_gt_Now_co_ UVs _dd__lt_/p_gt__lt_p_gt_V has value 0 for every A vertex and value 1 for every B vertex._lt_/p_gt__lt_p_gt_For Us_co_ I compute each segment distance from A0 divided by the total path length._lt_/p_gt__lt_p_gt__lt_em_gt_(caution _dd_ it_t_s not javascript notation_co_ please read it as natural language)_lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_example _dd__lt_/p_gt__lt_p_gt_uA0 _eq_ 0_co__lt_/p_gt__lt_p_gt_uA1 _eq_ length[A0_co_ A1] / length[path]_co__lt_/p_gt__lt_p_gt_uA2 _eq_ (length[A0_co_ A1]+length[A1_co_ A2])/length[path]_co__lt_/p_gt__lt_p_gt_etc_lt_/p_gt__lt_p_gt_then uA3 _eq_ 1_lt_/p_gt__lt_p_gt_The same for B._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This means my texture will have its height mapping the same ratio (1) the mesh surface and the texture width will be stretched along the width mesh_co_ each _lt_em_gt_U_lt_/em_gt_ being the _lt_em_gt_vertex.x/mesh width_lt_/em_gt_ percentage._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As I read in some OpenGL doc_co_ the UVs are per vertex. So I have right here 4 _lt_em_gt_vertices_lt_/em_gt__co_ so 4x3 _eq_ 12 _lt_em_gt_positions_lt_/em_gt_ and 4x2 _eq_ 8 _lt_em_gt_UVs_lt_/em_gt_._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now_co_ indices._lt_/p_gt__lt_p_gt_To create the surface between A and B_co_ I create two triangles (faces) per couple (segment) of points of each path._lt_/p_gt__lt_p_gt_Let_t_s consider segments [A0_co_ A1] regarding [b0_co_ B1]._lt_/p_gt__lt_p_gt_My first two triangles will be _dd_ [A0_co_ B0_co_ A1] and [b1_co_ A1_co_ B0] (different order on the second triangle to get the faces oriented the same direction_co_ just trust me)._lt_/p_gt__lt_p_gt_Ok ?  following ?_lt_/p_gt__lt_p_gt_So next two are _dd_ [A1_co_ B1_co_ A2] and [b2_co_ A2_co_ A1]_lt_/p_gt__lt_p_gt_As you guess the last two would be _dd_ [A2_co_ B2_co_ A3] and [b3_co_ A3_co_ B2]_lt_/p_gt__lt_p_gt_But remember_co_ I want my mesh circular as if each of your line were a circle actually (or a triangle if you prefer_co_ but it has nothing to do with the face triangles I just talk about the indices)._lt_/p_gt__lt_p_gt_If I want the normals to be computed the right way so the light will reflect in a realistic way on my mesh and no artefact will appear_co_ I need to re-use some vertices and join the last face to the first one._lt_/p_gt__lt_p_gt_So my last pair of face triangles must be _dd_ [A2_co_ B2_co_ A0] and [b0_co_ A0_co_ B2] _eq_&gt_sm_ I re-used A0 and B0 vertices and don_t_t care about A3 and B3 (which have the same values as A0 and B0)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_When I test an enlighted standard material_co_ I can check the normals are correct _dd_ nice reflection_co_ no artefact._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_When I texture my mesh material_co_ I notice the texture is only stretch onto the two first segment faces_co_ the last having the texture re-mapped from zero._lt_/p_gt__lt_p_gt_It_t_s like the UVs apply only per vertex _lt_strong_gt_used_lt_/strong_gt_ in _lt_em_gt_indices_lt_/em_gt_. Am I right ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If yes how to combine vertex re-use (for nice normals) and complete texturing ?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-04T16:14:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Before someone asks for a repro in the playground _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1AEYBA_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1AEYBA_lt_/a_gt_ _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_As you can see _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_- this is a quite cylindric mesh_co__lt_/p_gt__lt_p_gt_- the vertices from start and at end of the rotation are re-used so the normals are good (put the light on the edge)_co__lt_/p_gt__lt_p_gt_- the texture is stretched on the circular part of the mesh but is remapped entirely on the last plane segment._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__eq_&gt_sm_ I want it to be stretched around the full cylinder _dd_ it seems to be the case if I don_t_t re-use vertices in _lt_em_gt_indices_lt_/em_gt_ array_co_ but my normals are then ugly_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m afraid the algo isn_t_t simple to hack_co_ but my question is more about the way to do._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-05T15:55:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_ouurggg_lt_/p_gt__lt_p_gt_It seems noboby could understand what I meant _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So I will rephrase it with a progressive playground example (as you all love it _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ )_lt_/p_gt__lt_p_gt_Let_t_s go _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_From line 23 to 45_co__lt_/p_gt__lt_p_gt_I simply populate  two arrays _lt_em_gt_pathA_lt_/em_gt_ ans _lt_em_gt_pathB_lt_/em_gt_ with points following a circle function._lt_/p_gt__lt_p_gt_I also compute each point distance from the first point (distance _eq_ 0) and each path total distance for later use._lt_/p_gt__lt_p_gt_The ratio _lt_em_gt_pointDistance / totalPathDistance_lt_/em_gt_ will be each point _lt_em_gt_u_lt_/em_gt_ for UVs._lt_/p_gt__lt_p_gt_The _lt_em_gt_pathA_lt_/em_gt_ points will all have their _lt_em_gt_v_lt_/em_gt_ valued to 0.0_co_ and the _lt_em_gt_pathB_lt_/em_gt_ will all have their _lt_em_gt_v_lt_/em_gt_ valued 1.0_lt_/p_gt__lt_p_gt_You can see the corresponding _lt_em_gt_createLines()_lt_/em_gt_. Not big stuff until here._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_From these two _lt_em_gt_pathX_lt_/em_gt_ array_co_ I populate then a _lt_em_gt_positions_lt_/em_gt_ array_co_ a _lt_em_gt_indices _lt_/em_gt_array and a _lt_em_gt_uvs_lt_/em_gt_ array._lt_/p_gt__lt_p_gt__lt_em_gt_positions_lt_/em_gt_ _eq_ [A0_co_ B0_co_ A1_co_ B1_co_ A2_co_ B2_co_ ...]_lt_/p_gt__lt_p_gt__lt_em_gt_indices_lt_/em_gt_ _eq_ [ triangle(A0-B0-A1)_co_ triangle(B1-B0-A1)_co_ ...]_lt_/p_gt__lt_p_gt__lt_em_gt_uvs_lt_/em_gt_ _eq_ [ (uA0_co_ 0.0)_co_ (uB0_co_ 1.0)_co_ (uA1_co_ 0.0)_co_ (uB1_co_ 1.0)_co_ ...]_lt_/p_gt__lt_p_gt_With these three arrays and an extra _lt_em_gt_normals_lt_/em_gt_ array populated with _lt_em_gt_ComputeNormals()_lt_/em_gt__co_ I can now create a mesh (line 95 to 103)_dd_ this is the surface constructed by successive triangles between the two _lt_em_gt_pathX_lt_/em_gt_._lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#1_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Right._lt_/p_gt__lt_p_gt_Let_t_s give it some colored material _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#2_lt_/a_gt__lt_/p_gt__lt_p_gt_The circle is not closed because when populating the _lt_em_gt_pathX_lt_/em_gt_ I used the_lt_em_gt_ lower than_lt_/em_gt_ (&lt_sm_ 2*PI) operator instead of _lt_em_gt_lower or equal_lt_/em_gt_ (_eq_&lt_sm_ 2*PI). This is done in purpose._lt_/p_gt__lt_p_gt_You can notice that_co_ if I texture the material_co_ the texture is stretched along each path according to each point distance _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%234_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#4_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So now_co_ let_t_s close the circle._lt_/p_gt__lt_p_gt__lt_em_gt_line 46_lt_/em_gt_ _dd__lt_/p_gt__lt_p_gt_I add in each _lt_em_gt_pathX_lt_/em_gt_ array an extra last vector3 _dd_ the _lt_em_gt_pathX_lt_/em_gt_ first vector3. So the last point is now the first point on each path._lt_/p_gt__lt_p_gt_I also compute the distance for these new points._lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%233_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#3_lt_/a_gt__lt_/p_gt__lt_p_gt_Now you can notice the texture stretches right along the new length (distance) of each path _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%235_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#5_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Let_t_s go back to the former view _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%233_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#3_lt_/a_gt__lt_/p_gt__lt_p_gt_As you can see_co_ the edge between the start and the end of the path is visible in the light. The normals_co_ which are used to compute the light reflection_co_ are computed _lt_strong_gt_apart_lt_/strong_gt_ for the last points and first points._lt_/p_gt__lt_p_gt_In other words_co_ the last points and first points don_t_t belong to the same face (triangle)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The classical way to correct this is to _lt_strong_gt_re-use_lt_/strong_gt_ vertices. This means I will construct my _lt_em_gt_pathX_lt_/em_gt_ two last triangles with both last vertices and first vertices._lt_/p_gt__lt_p_gt_Go to line 78._lt_/p_gt__lt_p_gt_I don_t_t change the present algo_co_ I just undo the last triangles (not the smartest way to do_co_ but it_t_s easy to understand) and I redo them reusing first vertices _dd__lt_/p_gt__lt_ul_gt__lt_li_gt_delete last 6 _lt_em_gt_indices_lt_/em_gt_ elements (2 triangles)_lt_/li_gt__lt_li_gt_add 6 new elements referencing first vertices (2 new triangles)_lt_/li_gt__lt_/ul_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%236_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#6_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now the normals are right _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_. The light reflects in a realistic way._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But what if I now texture my mesh ?_lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%237_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#7_lt_/a_gt_   _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ _dd_( _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What is happening here ?_lt_/p_gt__lt_p_gt_The texture is still stretched along the _lt_em_gt_pathX_lt_/em_gt_ but only until to the next to last vertex. Then the texture is mapped from scratch from the next to last vertex to the last vertex._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Why ?_lt_/p_gt__lt_p_gt_I guess the UVs don_t_t rely on the last vertex declared in the _lt_em_gt_positions_lt_/em_gt_ array (the one with the right _lt_em_gt_u_lt_/em_gt_ in the _lt_em_gt_uvs_lt_/em_gt_ array)_co_ but on the last vertex _lt_strong_gt_used_lt_/strong_gt_ in the _lt_em_gt_indices_lt_/em_gt_ array._lt_/p_gt__lt_p_gt_As I reuse the first vertex in the _lt_em_gt_indices_lt_/em_gt_ array_co_ the texture has the _lt_em_gt_u_lt_/em_gt_ value of this first vertex_co_ which is 0.0 and not 1.0 (remember distance of the first vertex was zero). It must have 0.0 ! Because it is also the path first index !!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now do you understand_co_ readers_co_ what I meant ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_More generally _dd_ we can (must) re-use vertices in _lt_em_gt_indices_lt_/em_gt_ array to have right normals_co_ but we can_t_t re-use vertices in _lt_em_gt_UVs_lt_/em_gt_ (not allowed and it_t_s mandatory even to redeclare re-needed vertices as many times as needed)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So what is the right way to have both right normals and full stretched texture ?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-05T17:42:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_mmmh... driving back home_co_ I thought back to all of this_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I guess there_t_s no solution actually because a vertex may belong to many faces but has only one associated UV to a given texture._lt_/p_gt__lt_p_gt_So a re-used vertex can_t_t represent two different coordinates (uv) on the same texture map _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Two full days spent at trying to solve this grrrr _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_angry.png_qt_ alt_eq__qt__dd_angry_dd__qt__gt_ with useless workarounds_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It was the problem I had for some kind of textured closed ribbons._lt_/p_gt__lt_p_gt_So I think I will arbitrary make a choice _dd_ priority to normals for _lt_em_gt_closeXXX_lt_/em_gt_ paramaters._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If someone needs a full stretched texture_co_ he just will have to close the shape by himself (rotating its paths until _lt_em_gt_&lt_sm__eq_ 2*PI_lt_/em_gt_  with _lt_em_gt_closePath _eq_ false_lt_/em_gt_ instead of _lt_em_gt_&lt_sm_ 2*PI_lt_/em_gt_ with _lt_em_gt_closePath _eq_ true_lt_/em_gt_) _dd_ not such a big deal_co_ imho  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_mellow.png_qt_ alt_eq__qt__dd_mellow_dd__qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-02-05T17:46:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_that_t_s not an easy question. I think artists can also provide texture that can adapt using texture atlas_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-05T19:02:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_yep_co_ workaround thru art  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m now convinced _dd_ priority to normals !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_A texture would probably show some kind of separation edge between start and end (or image left and right_co_ etc) when applied to a closed/circular mesh anyway even stretched along its full length_co_ unless it is expressly designed not to do so._lt_/p_gt__lt_p_gt_Whereas we can choose (I mean thru code) to avoid light reflection artefacts by reusing the vertices._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_On one hand the code can master an option_co_ on the other hand we just have to speculate about the expected design of an asset (knowing there is still a workaround by closing oneselft the mesh) ..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So definetly _dd_ priority to normals.  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-02-05T23:19:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I can_t_t agree more. Look for instance how 3dsmax applies texture to s sphere_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-06T01:45:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_linux user_co_ sorry I can_t_t check 3DSMax_co_ but I trust you  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So_co_ an easy workaround for the developer using this kind of closed mesh is _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_- to let the algo computes the normals for the general case_lt_/p_gt__lt_p_gt_or_lt_/p_gt__lt_p_gt_- to add manually an extra vector3 at the end of the _lt_em_gt_path_lt_/em_gt_ array this way _dd_  _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_path.push(path[0])_sm__lt_/pre_gt__lt_p_gt_just after the populating array _lt_em_gt_for(var i){...}_lt_/em_gt_ loop_co_ if he expressly wants the texture to be stretched until the end and assumes to give up the normals nice reflection._lt_/p_gt__lt_div_gt_line 54 _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#S9WBW%238t_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#S9WBW#8t_lt_/a_gt__lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"chg","Date":"2015-02-06T02:05:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Have you considered alternative normal generation algorithms? Some let you supply a separate structure with adjacency information_co_ or has thresholds to treat vertices on edges which are close together as being the same for the purpose of generating normals._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Editors like 3ds Max actually do not suffer from the issue you are experiencing. They don_t_t use the rely on the representation of a mesh meant for the graphics pipeline when working with normals and UVs. Instead such programs typically represent meshes internally in structures that include adjacency information_co_ like winged edge or half edge_co_ which have extra information about the mesh the modeller algorithms need._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2015-02-06T02:07:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Jerome_co_ who the heck are you talking-to?  Are you having a conversation with yourself_co_ here in this thread?  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ (JcPalmer does that_co_ too_co_ and I love it.  He_t_s a genius just like you_co_ Jerome.)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You understand that BJS (what this forum is about)... is a JS layer between webGL and happy game-writers_co_ right?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The things you are talking about... are really OpenGL_co_ right?  I have a feeling that you might need to visit some OpenGL forums... to get the answers.  The odds that others have struggled with this subject and written about it... are quite high_co_ I would think._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You under-estimate your genius levels_co_ you know?  I_co_ and others_co_ would LOVE to answer your questions and engage in conversation... but you are about to take the tops off of the graphics chips on the motherboard_co_ and start digging around in there.  You_t_re scaring the dog!  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now get your butt over-to the OpenGL mesh-wranglers forums and see if anyone has already lived through your hell.   _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  There_t_s GOT TO BE answers to these questions_co_ somewhere... but maybe not here._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It_t_s fun listening to your narration of your thinking process_co_ though.  SUPER fun!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"chg","Date":"2015-02-06T02:25:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_70822_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12266_qt_ data-ipsquote-username_eq__qt_Wingnut_qt_ data-cite_eq__qt_Wingnut_qt_ data-ipsquote-timestamp_eq__qt_1423188465_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_Jerome_co_ who the heck are you talking-to?  Are you having a conversation with yourself_co_ here in this thread?  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ (JcPalmer does that_co_ too_co_ and I love it.  He_t_s a genius just like you_co_ Jerome.)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You understand that BJS (what this forum is about)... is a JS layer between webGL and happy game-writers_co_ right?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The things you are talking about... are really OpenGL_co_ right?  I have a feeling that you might need to visit some OpenGL forums... to get the answers.  The odds that others have struggled with this subject and written about it... are quite high_co_ I would think._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You under-estimate your genius levels_co_ you know?  I_co_ and others_co_ would LOVE to answer your questions and engage in conversation... but you are about to take the tops off of the graphics chips on the motherboard_co_ and start digging around in there.  You_t_re scaring the dog!  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now get your butt over-to the OpenGL mesh-wranglers forums and see if anyone has already lived through your hell.   _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  There_t_s GOT TO BE answers to these questions_co_ somewhere... but maybe not here._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It_t_s fun listening to your narration of your thinking process_co_ though.  SUPER fun!_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_As I said_co_ the solution is to compute normals _t_better_t__co_ using an algorithm that either takes extra adjacency info (eg. D3DXComputeNormals) or which can treat tris whose edges line up as being joined even if they don_t_t share the same vertex indices_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-06T08:17:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_@chg _dd_ Actually_co_ I didn_t_t think about recomputing the normals and about taking account of the adjacency information. This might be very smart_co_ imo._lt_/p_gt__lt_p_gt_I just use BJS tools like _lt_em_gt_ComputeNormals()_lt_/em_gt_. I don_t_t feel smart enough (or feel too lazy _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ ) to implement another _lt_em_gt_normals_lt_/em_gt_ computation just for this exotic case._lt_/p_gt__lt_p_gt_Maybe will it be implemented some days by someone more brave than me in the BJS core depths._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_@Wingy _dd_ it_t_s not about OpenGL but genuine BJS. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_I only use the BJS layer and BJS tools here._lt_/p_gt__lt_p_gt_I just face a specific border case (textured closed mesh) and I couldn_t_t find a smart workaround to solve it. So I stop fighting and solve by making an arbitrary choice of behavior _dd_ normals are prioritary to textures._lt_/p_gt__lt_p_gt_Lazy way to solve it_co_ I know _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_tongue.png_qt_ alt_eq__qt__dd_P_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/tongue@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ but efficient._lt_/p_gt__lt_p_gt_As there is no real bug_co_ but just a different behavior than the one I initialy wanted and no simple way to achieve it_co_ I decide to change my mind and to accept this current behavior._lt_/p_gt__lt_p_gt_Then I just have to justify it _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ ! _lt_/p_gt__lt_p_gt_So here is the Rule (my justification _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_tongue.png_qt_ alt_eq__qt__dd_P_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/tongue@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ ) _dd_ on textured closed ribbons_co_ normals are prioritary to textures._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Chg proposed another way to sove it by using a new (not yet existing and I won_t_t code it !) _lt_em_gt_ComputeNormals()_lt_/em_gt_ method which could take account of not face joined but very close vertices. Too complex for me _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ !_lt_/p_gt__lt_p_gt_I let these considerations to mythological half-gods like DK or Davrous and go back to my humble concerns _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_laugh.png_qt_ alt_eq__qt__dd_lol_dd__qt__gt_ ._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2015-02-06T16:47:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Nod.  Thanks for the info.  Funny_co_ too!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Trouble at the seams.  Border trouble._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Get the normals right_co_ and the UVs suck.  Get the UVs right and the normals suck.  It_t_s based-upon whether you re-use the starting vertices_co_ or use ending vertices placed atop the starting vertices.  How to close the seam.  At least I think that_t_s the situation_co_ Wingy-simplified.  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But_co_ the same problem would be experienced when using OpenGL graphics ONLY_co_ right?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I understand that you are working in the NOW_co_ but I foresee a time when hardware does _qt_seam-sensing_qt_ and UVs/normals compensations.  The hardware would likely make the UVs perfect_co_ and then do a fuzzy-logic _qt_averaging_qt_ or some other fancy words... to fix the lighting normals across the seam._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_And I think I understand the _qt_extra information_qt_ thing_co_ too.  Vertices that are flagged as _qt_starter_qt_ or _qt_finisher_qt_ would be treated differently_co_ and this might apply at hardware_co_ OpenGL_co_ and/or BJS layers.  They are_co_ in a way_co_ a different kind of vertex_co_ so they could affect ANY layer._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Interesting.  I HOPE seam-management and seam-compensations happen at hardware level_co_ someday.  You shouldn_t_t have to concern yourself with these problems/options.  That_t_s what we have computers-for.  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  Hardware should know what we want_co_ and ignore what we asked-for.  heh_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In a way_co_ this is _qt_snap_qt_ (align) for vertices. (Lately_co_ I have been thinking about _qt_snap_qt_ for assembling complex models using only Babylon basic shapes.  It_t_s a future feature of a Babylon scene editor_co_ but WHICH editor?  I think we have two basic scene editors_co_ and I don_t_t think either has snap/align or object arrays.  All in all_co_ a different subject.)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"spritefire","Date":"2015-02-09T06:11:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I understand what is going with this from a 3d modelling perspective and can picture the UV as green lines on the mesh when it_t_s calculated out _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_tongue.png_qt_ alt_eq__qt__dd_P_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/tongue@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_br_gt__lt_br_gt_How about we change the way that the seam is closed. Rather than trying to fill a gap_co_ make the last induces the same position as the first (so that it is a full cylinder)_co_ then create another set of induces (the same co-ords as the last). Now these ones you can break and create as a join to weld the mesh shut. _lt_br_gt__lt_br_gt_I haven_t_t tested this_co_ but I think this should work._lt_br_gt_ _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-09T08:43:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_@spitefire _dd_ that_t_s what I did._lt_/p_gt__lt_p_gt_The problem is not really how to join edges a closed mesh but _dd__lt_/p_gt__lt_p_gt_- normals are per vertex_lt_/p_gt__lt_p_gt_- a vertex may belong to many faces. If you want a right light reflection_co_ it MUST belong to contiguous faces._lt_/p_gt__lt_p_gt_- texture uv are per vertex used in the mesh construction (so per vertex referenced in the _lt_em_gt_indices_lt_/em_gt_ array only)_lt_/p_gt__lt_p_gt_- uv are just 2D coordinates_co_ each uv is mapped to each vertex reference in the _lt_em_gt_indices_lt_/em_gt_ array_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So you_lt_/p_gt__lt_ul_gt__lt_li_gt_either declare two different vertices (with same vector3 coordinate) and the texture is mapped right but normals aren_t_t right because you don_t_t reuse this vertex for the first face contiguous to the last face of the mesh_co__lt_/li_gt__lt_li_gt_either reuse the vertex common to first and last contiguous faces_co_ then its normal is right_co_ but you can_t_t set this shared vertex two different uvs (first and last)._lt_/li_gt__lt_/ul_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I tried it many ways..._lt_/p_gt__lt_p_gt_If you want realistic light reflection_co_ you really need to reuse vertices for contiguous faces (unless computing especially different normals for these very edge vertices_co_ so it won_t_t be real _lt_em_gt_normals_lt_/em_gt_ anymore)._lt_/p_gt__lt_p_gt_If you try any workaround with other set of indices on the same mesh_co_ artefacts appear in light reflection on the surface ._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Maybe the right way would be  to have two full set of indices_co_ so two meshes superset in each other _dd_ one for light reflection with right normals (and so reused vertices) and another one for texturing with right uvs (no reused vertex) and no reflection... don_t_t even know if it could work_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"dbawel","Date":"2015-02-11T09:03:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I would vote that this is most likely a result due to non-contiguous vertex ordering or equidistant surface bias when drawing triangles - as I often experience many variations of this depending on which software renderer is calculating UV vertex indexing and surface bias.  I haven_t_t yet played with this surface vertex and line info_co_ but this is usually a problem depending on how triangles and normals are ultimately calculated through non-contiguous vertice ordering - without my taking time to reconstruct and run a quick trial._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_BTW - you_t_re correct - it is quite entertaining to listen to jerome offer up his own dual conversations.  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_laugh.png_qt_ alt_eq__qt__dd_lol_dd__qt__gt_    I often feel as simply an observer when reading many of his threads.  _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ if surface bias is scaleable within BJS_co_ then I believe problem solved._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-02-11T09:40:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_ _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_In the train back from Paris TechDays_co_ instead of sleeping last night_co_ I thought I could eventually add some modification to the _lt_em_gt_computeNormals()_lt_/em_gt_ method._lt_/p_gt__lt_p_gt_Something like an optional array of _lt_em_gt_indices_lt_/em_gt_ pairs parameter._lt_/p_gt__lt_p_gt_If this array is defined_co_ it will tell _dd_ please consider each pair of referenced vertices as the same one vertex for normal computation. Even if they aren_t_t declared on the same face._lt_/p_gt__lt_p_gt_So we could have contiguous faces_co_ with no vertex re-use (so right uv and right texturing)_co_ AND right light reflection._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In brief_co_ have a different normal computation for given vertex._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"chg","Date":"2015-02-11T12:27:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_71491_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12266_qt_ data-ipsquote-username_eq__qt_jerome_qt_ data-cite_eq__qt_jerome_qt_ data-ipsquote-timestamp_eq__qt_1423647647_qt__gt__lt_div_gt__lt_p_gt_ _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_\nIn the train back from Paris TechDays_co_ instead of sleeping last night_co_ I thought I could eventually add some modification to the _lt_em_gt_computeNormals()_lt_/em_gt_ method._lt_/p_gt__lt_p_gt_\nSomething like an optional array of _lt_em_gt_indices_lt_/em_gt_ pairs parameter..._lt_/p_gt__lt_/div_gt__lt_/blockquote_gt_ BTW the D3DX lib function is what Microsoft considers open source (MS-PL license) if you want to check the c++ implementation of the alternative I mentioned before _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ (EDIT_dd_ btw_co_ you may want to try and focus on edges rather than faces or vertices_co_ I know you are thinking of ribbons now_co_ but fans are common too_co_ for geometry that can be smooth shaded each edge should only belong to two triangles)_lt_p_gt_\n _lt_/p_gt__lt_p_gt_\n_lt_/p_gt__lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_71222_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_12266_qt_ data-ipsquote-username_eq__qt_jerome_qt_ data-cite_eq__qt_jerome_qt_ data-ipsquote-timestamp_eq__qt_1423471417_qt__gt__lt_div_gt__lt_p_gt_...unless computing especially different normals for these very edge vertices_co_ so it won_t_t be real _lt_em_gt_normals_lt_/em_gt_ anymore)._lt_/p_gt__lt_/div_gt__lt_/blockquote_gt_I prefer terms _qt_lighting normals_qt_ vs _qt_surface normals_qt_ (the later being what I think you mean by _qt_real_qt_ normals) for making the distinction _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ Lighting normals are used for lighting and shading meshes_co_ but they need not be the same as the normals to the geometry as you note_co_ lighting normals are no less valid_co_ as they describe the approximated surface being considered with respect to say say gouraud or phong shading as projected onto the polygonal mesh_co_ for the purposes of making it appear smoother than it really is. That is to say_co_ I think of lighting normals as normals to the higher order shape the mesh approximates_co_ with the surface normals to the actual mesh not necessarily being the best representation.\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]