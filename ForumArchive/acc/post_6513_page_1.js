[{"Owner":"BeRightBack","Date":"2014-05-18T06:41:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Is there a way in babylonjs/ts to prevent meshes from falling through a map made with GroundFromHeightMap? meshes_t_s physics seems to work only with flat ground tho the camera_t_s gravity recognize height maps so what am_t_ I missing?_co_ in my searches_co_ I_t_ve read that it was not support in Babylonjs_co_ If so I would like to know and perhaps try other libraries tho I_t_m getting use to this one_co_ which is very intuitive and usually find my own way._lt_/p_gt__lt_p_gt_since my meshes are floating on water_co_ i guess it could be made with shaders but yet to heavy for my understanding so far_co_ any hint to get me started would be appreciated._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-05-18T23:34:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_We are using cannonjs for now as unique physics provider. After many discussions we decided to move our current model to a plugin oriented model for physics. This will allow us to have many physics providers (amno.js for instance)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But in your specific case do you need only an imprecise collisions (in this case the picking engine can be enough)?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2014-05-19T00:48:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Sorry to interrupt_co_ but_co_ is ANY webGL library or anyone... doing full physics on heightmaps?  I don_t_t think I have ever seen a sphere rolling up and down a heightMap mountain yet_co_ nor a box tumbling down a heightmap mountain... in any webGL demo_co_ so far.  That_t_s some rather intense calculations_co_ I suspect. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I HAVE bounced some cannonballs off of mountains in a game called Serious Sam_co_ though.  But that_t_s got a little faster language than JS... under its hood.  *shrug*.   I_t_m not very educated in these matters._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeRightBack","Date":"2014-05-19T01:14:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks for your answers_co_ _qt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_sphere rolling up and down a heightMap mountain_qt_ is exactly what i_t_m looking for_co_ ammo.js seems to support it _dd_ see example 8   _lt_/span_gt__lt_a href_eq__qt_http_dd_//lo-th.github.io/Ammo.lab/_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//lo-th.github.io/Ammo.lab/_lt_/a_gt_  it_t_s using noise generation_co__co_ I also found an interesting code which I_t_m studiyng right now _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_div_gt__t_use strict_t__sm__lt_/div_gt__lt_div_gt_// Ported from Stefan Gustavson_t_s java implementation_lt_/div_gt__lt_div_gt_// _lt_a href_eq__qt_http_dd_//staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf_lt_/a_gt__lt_/div_gt__lt_div_gt_// Read Stefan_t_s excellent paper for details on how this code works._lt_/div_gt__lt_div_gt_//_lt_/div_gt__lt_div_gt_// Sean McCullough banksean@gmail.com_lt_/div_gt__lt_div_gt_ _lt_/div_gt__lt_div_gt_/**_lt_/div_gt__lt_div_gt_ * You can pass in a random number generator object if you like._lt_/div_gt__lt_div_gt_ * It is assumed to have a random() method._lt_/div_gt__lt_div_gt_ */_lt_/div_gt__lt_div_gt_var SimplexNoise _eq_ (function() {_lt_/div_gt__lt_div_gt_var SimplexNoise _eq_ function® {_lt_/div_gt__lt_div_gt_if (r _eq__eq_ undefined) r _eq_ Math_sm__lt_/div_gt__lt_div_gt_ this.grad3 _eq_ [[1_co_1_co_0]_co_[-1_co_1_co_0]_co_[1_co_-1_co_0]_co_[-1_co_-1_co_0]_co_ _lt_/div_gt__lt_div_gt_                                [1_co_0_co_1]_co_[-1_co_0_co_1]_co_[1_co_0_co_-1]_co_[-1_co_0_co_-1]_co_ _lt_/div_gt__lt_div_gt_                                [0_co_1_co_1]_co_[0_co_-1_co_1]_co_[0_co_1_co_-1]_co_[0_co_-1_co_-1]]_sm_ _lt_/div_gt__lt_div_gt_ this.p _eq_ []_sm__lt_/div_gt__lt_div_gt_ for (var i_eq_0_sm_ i&lt_sm_256_sm_ i++) {_lt_/div_gt__lt_div_gt_ this.p_lt_em_gt_ _eq_ Math.floor(r.random()*256)_sm__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt_ }_lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt_ // To remove the need for index wrapping_co_ double the permutation table length _lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt_ this.perm _eq_ []_sm_ _lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt_ for(var i_eq_0_sm_ i&lt_sm_512_sm_ i++) {_lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt_this.perm_lt_/em_gt__lt_em_gt__lt_em_gt__eq_this.p[i &amp_sm_ 255]_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_} _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // A lookup table to traverse the simplex around a given point in 4D. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Details can be found where this table is used_co_ in the 4D noise method. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ this.simplex _eq_ [ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [0_co_1_co_2_co_3]_co_[0_co_1_co_3_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_2_co_3_co_1]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[1_co_2_co_3_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [0_co_2_co_1_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_3_co_1_co_2]_co_[0_co_3_co_2_co_1]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[1_co_3_co_2_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [1_co_2_co_0_co_3]_co_[0_co_0_co_0_co_0]_co_[1_co_3_co_0_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[2_co_3_co_0_co_1]_co_[2_co_3_co_1_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [1_co_0_co_2_co_3]_co_[1_co_0_co_3_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[2_co_0_co_3_co_1]_co_[0_co_0_co_0_co_0]_co_[2_co_1_co_3_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [2_co_0_co_1_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[3_co_0_co_1_co_2]_co_[3_co_0_co_2_co_1]_co_[0_co_0_co_0_co_0]_co_[3_co_1_co_2_co_0]_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   [2_co_1_co_0_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[3_co_1_co_0_co_2]_co_[0_co_0_co_0_co_0]_co_[3_co_2_co_0_co_1]_co_[3_co_2_co_1_co_0]]_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_}_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_SimplexNoise.prototype.dot _eq_ function(g_co_ x_co_ y) { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_return g[0]*x + g[1]*y_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_}_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_SimplexNoise.prototype.noise _eq_ function(xin_co_ yin) { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var n0_co_ n1_co_ n2_sm_ // Noise contributions from the three corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Skew the input space to determine which simplex cell we_t_re in _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var F2 _eq_ 0.5*(Math.sqrt(3.0)-1.0)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var s _eq_ (xin+yin)*F2_sm_ // Hairy factor for 2D _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var i _eq_ Math.floor(xin+s)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var j _eq_ Math.floor(yin+s)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var G2 _eq_ (3.0-Math.sqrt(3.0))/6.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t _eq_ (i+j)*G2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var X0 _eq_ i-t_sm_ // Unskew the cell origin back to (x_co_y) space _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var Y0 _eq_ j-t_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x0 _eq_ xin-X0_sm_ // The x_co_y distances from the cell origin _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y0 _eq_ yin-Y0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // For the 2D case_co_ the simplex shape is an equilateral triangle. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Determine which simplex we are in. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var i1_co_ j1_sm_ // Offsets for second (middle) corner of simplex in (i_co_j) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(x0&gt_sm_y0) {i1_eq_1_sm_ j1_eq_0_sm_} // lower triangle_co_ XY order_dd_ (0_co_0)-&gt_sm_(1_co_0)-&gt_sm_(1_co_1) _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else {i1_eq_0_sm_ j1_eq_1_sm_}      // upper triangle_co_ YX order_dd_ (0_co_0)-&gt_sm_(0_co_1)-&gt_sm_(1_co_1) _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // A step of (1_co_0) in (i_co_j) means a step of (1-c_co_-c) in (x_co_y)_co_ and _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // a step of (0_co_1) in (i_co_j) means a step of (-c_co_1-c) in (x_co_y)_co_ where _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // c _eq_ (3-sqrt(3))/6 _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x1 _eq_ x0 - i1 + G2_sm_ // Offsets for middle corner in (x_co_y) unskewed coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y1 _eq_ y0 - j1 + G2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x2 _eq_ x0 - 1.0 + 2.0 * G2_sm_ // Offsets for last corner in (x_co_y) unskewed coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y2 _eq_ y0 - 1.0 + 2.0 * G2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Work out the hashed gradient indices of the three simplex corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var ii _eq_ i &amp_sm_ 255_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var jj _eq_ j &amp_sm_ 255_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi0 _eq_ this.perm[ii+this.perm[jj]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi1 _eq_ this.perm[ii+i1+this.perm[jj+j1]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi2 _eq_ this.perm[ii+1+this.perm[jj+1]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Calculate the contribution from the three corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t0 _eq_ 0.5 - x0*x0-y0*y0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t0&lt_sm_0) n0 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t0 *_eq_ t0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n0 _eq_ t0 * t0 * this.dot(this.grad3[gi0]_co_ x0_co_ y0)_sm_  // (x_co_y) of grad3 used for 2D gradient _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t1 _eq_ 0.5 - x1*x1-y1*y1_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t1&lt_sm_0) n1 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t1 *_eq_ t1_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n1 _eq_ t1 * t1 * this.dot(this.grad3[gi1]_co_ x1_co_ y1)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ }_lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t2 _eq_ 0.5 - x2*x2-y2*y2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t2&lt_sm_0) n2 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t2 *_eq_ t2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n2 _eq_ t2 * t2 * this.dot(this.grad3[gi2]_co_ x2_co_ y2)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Add contributions from each corner to get the final noise value. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // The result is scaled to return values in the interval [-1_co_1]. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ return 70.0 * (n0 + n1 + n2)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_}_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_// 3D simplex noise _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_SimplexNoise.prototype.noise3d _eq_ function(xin_co_ yin_co_ zin) { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var n0_co_ n1_co_ n2_co_ n3_sm_ // Noise contributions from the four corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Skew the input space to determine which simplex cell we_t_re in _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var F3 _eq_ 1.0/3.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var s _eq_ (xin+yin+zin)*F3_sm_ // Very nice and simple skew factor for 3D _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var i _eq_ Math.floor(xin+s)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var j _eq_ Math.floor(yin+s)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var k _eq_ Math.floor(zin+s)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var G3 _eq_ 1.0/6.0_sm_ // Very nice and simple unskew factor_co_ too _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t _eq_ (i+j+k)*G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var X0 _eq_ i-t_sm_ // Unskew the cell origin back to (x_co_y_co_z) space _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var Y0 _eq_ j-t_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var Z0 _eq_ k-t_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x0 _eq_ xin-X0_sm_ // The x_co_y_co_z distances from the cell origin _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y0 _eq_ yin-Y0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var z0 _eq_ zin-Z0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // For the 3D case_co_ the simplex shape is a slightly irregular tetrahedron. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Determine which simplex we are in. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var i1_co_ j1_co_ k1_sm_ // Offsets for second corner of simplex in (i_co_j_co_k) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var i2_co_ j2_co_ k2_sm_ // Offsets for third corner of simplex in (i_co_j_co_k) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(x0&gt_sm__eq_y0) { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   if(y0&gt_sm__eq_z0) _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_     { i1_eq_1_sm_ j1_eq_0_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_1_sm_ k2_eq_0_sm_ } // X Y Z order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_     else if(x0&gt_sm__eq_z0) { i1_eq_1_sm_ j1_eq_0_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_0_sm_ k2_eq_1_sm_ } // X Z Y order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_     else { i1_eq_0_sm_ j1_eq_0_sm_ k1_eq_1_sm_ i2_eq_1_sm_ j2_eq_0_sm_ k2_eq_1_sm_ } // Z X Y order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { // x0&lt_sm_y0 _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   if(y0&lt_sm_z0) { i1_eq_0_sm_ j1_eq_0_sm_ k1_eq_1_sm_ i2_eq_0_sm_ j2_eq_1_sm_ k2_eq_1_sm_ } // Z Y X order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   else if(x0&lt_sm_z0) { i1_eq_0_sm_ j1_eq_1_sm_ k1_eq_0_sm_ i2_eq_0_sm_ j2_eq_1_sm_ k2_eq_1_sm_ } // Y Z X order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   else { i1_eq_0_sm_ j1_eq_1_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_1_sm_ k2_eq_0_sm_ } // Y X Z order _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // A step of (1_co_0_co_0) in (i_co_j_co_k) means a step of (1-c_co_-c_co_-c) in (x_co_y_co_z)_co_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // a step of (0_co_1_co_0) in (i_co_j_co_k) means a step of (-c_co_1-c_co_-c) in (x_co_y_co_z)_co_ and _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // a step of (0_co_0_co_1) in (i_co_j_co_k) means a step of (-c_co_-c_co_1-c) in (x_co_y_co_z)_co_ where _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // c _eq_ 1/6._lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x1 _eq_ x0 - i1 + G3_sm_ // Offsets for second corner in (x_co_y_co_z) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y1 _eq_ y0 - j1 + G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var z1 _eq_ z0 - k1 + G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x2 _eq_ x0 - i2 + 2.0*G3_sm_ // Offsets for third corner in (x_co_y_co_z) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y2 _eq_ y0 - j2 + 2.0*G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var z2 _eq_ z0 - k2 + 2.0*G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var x3 _eq_ x0 - 1.0 + 3.0*G3_sm_ // Offsets for last corner in (x_co_y_co_z) coords _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var y3 _eq_ y0 - 1.0 + 3.0*G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var z3 _eq_ z0 - 1.0 + 3.0*G3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Work out the hashed gradient indices of the four simplex corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var ii _eq_ i &amp_sm_ 255_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var jj _eq_ j &amp_sm_ 255_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var kk _eq_ k &amp_sm_ 255_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi0 _eq_ this.perm[ii+this.perm[jj+this.perm[kk]]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi1 _eq_ this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi2 _eq_ this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var gi3 _eq_ this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Calculate the contribution from the four corners _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t0 _eq_ 0.6 - x0*x0 - y0*y0 - z0*z0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t0&lt_sm_0) n0 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t0 *_eq_ t0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n0 _eq_ t0 * t0 * this.dot(this.grad3[gi0]_co_ x0_co_ y0_co_ z0)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ }_lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t1 _eq_ 0.6 - x1*x1 - y1*y1 - z1*z1_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t1&lt_sm_0) n1 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t1 *_eq_ t1_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n1 _eq_ t1 * t1 * this.dot(this.grad3[gi1]_co_ x1_co_ y1_co_ z1)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t2 _eq_ 0.6 - x2*x2 - y2*y2 - z2*z2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t2&lt_sm_0) n2 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t2 *_eq_ t2_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n2 _eq_ t2 * t2 * this.dot(this.grad3[gi2]_co_ x2_co_ y2_co_ z2)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ var t3 _eq_ 0.6 - x3*x3 - y3*y3 - z3*z3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ if(t3&lt_sm_0) n3 _eq_ 0.0_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ else { _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   t3 *_eq_ t3_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_   n3 _eq_ t3 * t3 * this.dot(this.grad3[gi3]_co_ x3_co_ y3_co_ z3)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ } _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // Add contributions from each corner to get the final noise value. _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ // The result is scaled to stay just inside [-1_co_1] _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ return 32.0*(n0 + n1 + n2 + n3)_sm_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_}_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_return SimplexNoise_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_})()_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_div_gt__lt_em_gt__lt_em_gt_NoiseGen _eq_ new SimplexNoise_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_ _lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_        ground_geometry _eq_ new THREE.PlaneGeometry(75_co_ 75_co_ 50_co_ 50)_sm__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_        for (var i _eq_ 0_sm_ i &lt_sm_ ground_geometry.vertices.length_sm_ i++) {_lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt_            var vertex _eq_ ground_geometry.vertices_lt_/em_gt__lt_/em_gt__lt_em_gt__lt_em_gt__lt_em_gt__sm__lt_/em_gt__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt__lt_em_gt_            vertex.z _eq_ NoiseGen.noise(vertex.x / 10_co_ vertex.y / 10) * 2_sm__lt_/em_gt__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_div_gt__lt_em_gt__lt_em_gt__lt_em_gt_        }_lt_/em_gt__lt_/em_gt__lt_/em_gt__lt_/div_gt__lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"gwenael","Date":"2014-05-19T07:43:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_pre class_eq__qt_ipsCode prettyprint_qt__gt__t_use strict_t__sm_// Ported from Stefan Gustavson_t_s java implementation// _lt_a href_eq__qt__qt__gt_http_dd_//staffwww.itn....implexnoise.pdf//_lt_/a_gt_ Read Stefan_t_s excellent paper for details on how this code works.//// Sean McCullough banksean@gmail.com /** * You can pass in a random number generator object if you like. * It is assumed to have a random() method. */var SimplexNoise _eq_ (function() {var SimplexNoise _eq_ function® {if (r _eq__eq_ undefined) r _eq_ Math_sm_ this.grad3 _eq_ [[1_co_1_co_0]_co_[-1_co_1_co_0]_co_[1_co_-1_co_0]_co_[-1_co_-1_co_0]_co_                                 [1_co_0_co_1]_co_[-1_co_0_co_1]_co_[1_co_0_co_-1]_co_[-1_co_0_co_-1]_co_                                 [0_co_1_co_1]_co_[0_co_-1_co_1]_co_[0_co_1_co_-1]_co_[0_co_-1_co_-1]]_sm_  this.p _eq_ []_sm_ for (var i_eq_0_sm_ i&lt_sm_256_sm_ i++) { this.p[i] _eq_ Math.floor(r.random()*256)_sm_ } // To remove the need for index wrapping_co_ double the permutation table length  this.perm _eq_ []_sm_  for(var i_eq_0_sm_ i&lt_sm_512_sm_ i++) {this.perm[i]_eq_this.p[i &amp_sm_ 255]_sm_}   // A lookup table to traverse the simplex around a given point in 4D.  // Details can be found where this table is used_co_ in the 4D noise method.  this.simplex _eq_ [    [0_co_1_co_2_co_3]_co_[0_co_1_co_3_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_2_co_3_co_1]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[1_co_2_co_3_co_0]_co_    [0_co_2_co_1_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_3_co_1_co_2]_co_[0_co_3_co_2_co_1]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[1_co_3_co_2_co_0]_co_    [0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_    [1_co_2_co_0_co_3]_co_[0_co_0_co_0_co_0]_co_[1_co_3_co_0_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[2_co_3_co_0_co_1]_co_[2_co_3_co_1_co_0]_co_    [1_co_0_co_2_co_3]_co_[1_co_0_co_3_co_2]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[2_co_0_co_3_co_1]_co_[0_co_0_co_0_co_0]_co_[2_co_1_co_3_co_0]_co_    [0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_    [2_co_0_co_1_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[3_co_0_co_1_co_2]_co_[3_co_0_co_2_co_1]_co_[0_co_0_co_0_co_0]_co_[3_co_1_co_2_co_0]_co_    [2_co_1_co_0_co_3]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[0_co_0_co_0_co_0]_co_[3_co_1_co_0_co_2]_co_[0_co_0_co_0_co_0]_co_[3_co_2_co_0_co_1]_co_[3_co_2_co_1_co_0]]_sm_ }_sm_ SimplexNoise.prototype.dot _eq_ function(g_co_ x_co_ y) { return g[0]*x + g[1]*y_sm_}_sm_ SimplexNoise.prototype.noise _eq_ function(xin_co_ yin) {  var n0_co_ n1_co_ n2_sm_ // Noise contributions from the three corners  // Skew the input space to determine which simplex cell we_t_re in  var F2 _eq_ 0.5*(Math.sqrt(3.0)-1.0)_sm_  var s _eq_ (xin+yin)*F2_sm_ // Hairy factor for 2D  var i _eq_ Math.floor(xin+s)_sm_  var j _eq_ Math.floor(yin+s)_sm_  var G2 _eq_ (3.0-Math.sqrt(3.0))/6.0_sm_  var t _eq_ (i+j)*G2_sm_  var X0 _eq_ i-t_sm_ // Unskew the cell origin back to (x_co_y) space  var Y0 _eq_ j-t_sm_  var x0 _eq_ xin-X0_sm_ // The x_co_y distances from the cell origin  var y0 _eq_ yin-Y0_sm_  // For the 2D case_co_ the simplex shape is an equilateral triangle.  // Determine which simplex we are in.  var i1_co_ j1_sm_ // Offsets for second (middle) corner of simplex in (i_co_j) coords  if(x0&gt_sm_y0) {i1_eq_1_sm_ j1_eq_0_sm_} // lower triangle_co_ XY order_dd_ (0_co_0)-&gt_sm_(1_co_0)-&gt_sm_(1_co_1)  else {i1_eq_0_sm_ j1_eq_1_sm_}      // upper triangle_co_ YX order_dd_ (0_co_0)-&gt_sm_(0_co_1)-&gt_sm_(1_co_1)  // A step of (1_co_0) in (i_co_j) means a step of (1-c_co_-c) in (x_co_y)_co_ and  // a step of (0_co_1) in (i_co_j) means a step of (-c_co_1-c) in (x_co_y)_co_ where  // c _eq_ (3-sqrt(3))/6  var x1 _eq_ x0 - i1 + G2_sm_ // Offsets for middle corner in (x_co_y) unskewed coords  var y1 _eq_ y0 - j1 + G2_sm_  var x2 _eq_ x0 - 1.0 + 2.0 * G2_sm_ // Offsets for last corner in (x_co_y) unskewed coords  var y2 _eq_ y0 - 1.0 + 2.0 * G2_sm_  // Work out the hashed gradient indices of the three simplex corners  var ii _eq_ i &amp_sm_ 255_sm_  var jj _eq_ j &amp_sm_ 255_sm_  var gi0 _eq_ this.perm[ii+this.perm[jj]] % 12_sm_  var gi1 _eq_ this.perm[ii+i1+this.perm[jj+j1]] % 12_sm_  var gi2 _eq_ this.perm[ii+1+this.perm[jj+1]] % 12_sm_  // Calculate the contribution from the three corners  var t0 _eq_ 0.5 - x0*x0-y0*y0_sm_  if(t0&lt_sm_0) n0 _eq_ 0.0_sm_  else {    t0 *_eq_ t0_sm_    n0 _eq_ t0 * t0 * this.dot(this.grad3[gi0]_co_ x0_co_ y0)_sm_  // (x_co_y) of grad3 used for 2D gradient  }  var t1 _eq_ 0.5 - x1*x1-y1*y1_sm_  if(t1&lt_sm_0) n1 _eq_ 0.0_sm_  else {    t1 *_eq_ t1_sm_    n1 _eq_ t1 * t1 * this.dot(this.grad3[gi1]_co_ x1_co_ y1)_sm_  } var t2 _eq_ 0.5 - x2*x2-y2*y2_sm_  if(t2&lt_sm_0) n2 _eq_ 0.0_sm_  else {    t2 *_eq_ t2_sm_    n2 _eq_ t2 * t2 * this.dot(this.grad3[gi2]_co_ x2_co_ y2)_sm_  }  // Add contributions from each corner to get the final noise value.  // The result is scaled to return values in the interval [-1_co_1].  return 70.0 * (n0 + n1 + n2)_sm_ }_sm_ // 3D simplex noise SimplexNoise.prototype.noise3d _eq_ function(xin_co_ yin_co_ zin) {  var n0_co_ n1_co_ n2_co_ n3_sm_ // Noise contributions from the four corners  // Skew the input space to determine which simplex cell we_t_re in  var F3 _eq_ 1.0/3.0_sm_  var s _eq_ (xin+yin+zin)*F3_sm_ // Very nice and simple skew factor for 3D  var i _eq_ Math.floor(xin+s)_sm_  var j _eq_ Math.floor(yin+s)_sm_  var k _eq_ Math.floor(zin+s)_sm_  var G3 _eq_ 1.0/6.0_sm_ // Very nice and simple unskew factor_co_ too  var t _eq_ (i+j+k)*G3_sm_  var X0 _eq_ i-t_sm_ // Unskew the cell origin back to (x_co_y_co_z) space  var Y0 _eq_ j-t_sm_  var Z0 _eq_ k-t_sm_  var x0 _eq_ xin-X0_sm_ // The x_co_y_co_z distances from the cell origin  var y0 _eq_ yin-Y0_sm_  var z0 _eq_ zin-Z0_sm_  // For the 3D case_co_ the simplex shape is a slightly irregular tetrahedron.  // Determine which simplex we are in.  var i1_co_ j1_co_ k1_sm_ // Offsets for second corner of simplex in (i_co_j_co_k) coords  var i2_co_ j2_co_ k2_sm_ // Offsets for third corner of simplex in (i_co_j_co_k) coords  if(x0&gt_sm__eq_y0) {    if(y0&gt_sm__eq_z0)      { i1_eq_1_sm_ j1_eq_0_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_1_sm_ k2_eq_0_sm_ } // X Y Z order      else if(x0&gt_sm__eq_z0) { i1_eq_1_sm_ j1_eq_0_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_0_sm_ k2_eq_1_sm_ } // X Z Y order      else { i1_eq_0_sm_ j1_eq_0_sm_ k1_eq_1_sm_ i2_eq_1_sm_ j2_eq_0_sm_ k2_eq_1_sm_ } // Z X Y order    }  else { // x0&lt_sm_y0    if(y0&lt_sm_z0) { i1_eq_0_sm_ j1_eq_0_sm_ k1_eq_1_sm_ i2_eq_0_sm_ j2_eq_1_sm_ k2_eq_1_sm_ } // Z Y X order    else if(x0&lt_sm_z0) { i1_eq_0_sm_ j1_eq_1_sm_ k1_eq_0_sm_ i2_eq_0_sm_ j2_eq_1_sm_ k2_eq_1_sm_ } // Y Z X order    else { i1_eq_0_sm_ j1_eq_1_sm_ k1_eq_0_sm_ i2_eq_1_sm_ j2_eq_1_sm_ k2_eq_0_sm_ } // Y X Z order  }  // A step of (1_co_0_co_0) in (i_co_j_co_k) means a step of (1-c_co_-c_co_-c) in (x_co_y_co_z)_co_  // a step of (0_co_1_co_0) in (i_co_j_co_k) means a step of (-c_co_1-c_co_-c) in (x_co_y_co_z)_co_ and  // a step of (0_co_0_co_1) in (i_co_j_co_k) means a step of (-c_co_-c_co_1-c) in (x_co_y_co_z)_co_ where  // c _eq_ 1/6. var x1 _eq_ x0 - i1 + G3_sm_ // Offsets for second corner in (x_co_y_co_z) coords  var y1 _eq_ y0 - j1 + G3_sm_  var z1 _eq_ z0 - k1 + G3_sm_  var x2 _eq_ x0 - i2 + 2.0*G3_sm_ // Offsets for third corner in (x_co_y_co_z) coords  var y2 _eq_ y0 - j2 + 2.0*G3_sm_  var z2 _eq_ z0 - k2 + 2.0*G3_sm_  var x3 _eq_ x0 - 1.0 + 3.0*G3_sm_ // Offsets for last corner in (x_co_y_co_z) coords  var y3 _eq_ y0 - 1.0 + 3.0*G3_sm_  var z3 _eq_ z0 - 1.0 + 3.0*G3_sm_  // Work out the hashed gradient indices of the four simplex corners  var ii _eq_ i &amp_sm_ 255_sm_  var jj _eq_ j &amp_sm_ 255_sm_  var kk _eq_ k &amp_sm_ 255_sm_  var gi0 _eq_ this.perm[ii+this.perm[jj+this.perm[kk]]] % 12_sm_  var gi1 _eq_ this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12_sm_  var gi2 _eq_ this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12_sm_  var gi3 _eq_ this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12_sm_  // Calculate the contribution from the four corners  var t0 _eq_ 0.6 - x0*x0 - y0*y0 - z0*z0_sm_  if(t0&lt_sm_0) n0 _eq_ 0.0_sm_  else {    t0 *_eq_ t0_sm_    n0 _eq_ t0 * t0 * this.dot(this.grad3[gi0]_co_ x0_co_ y0_co_ z0)_sm_  } var t1 _eq_ 0.6 - x1*x1 - y1*y1 - z1*z1_sm_  if(t1&lt_sm_0) n1 _eq_ 0.0_sm_  else {    t1 *_eq_ t1_sm_    n1 _eq_ t1 * t1 * this.dot(this.grad3[gi1]_co_ x1_co_ y1_co_ z1)_sm_  }  var t2 _eq_ 0.6 - x2*x2 - y2*y2 - z2*z2_sm_  if(t2&lt_sm_0) n2 _eq_ 0.0_sm_  else {    t2 *_eq_ t2_sm_    n2 _eq_ t2 * t2 * this.dot(this.grad3[gi2]_co_ x2_co_ y2_co_ z2)_sm_  }  var t3 _eq_ 0.6 - x3*x3 - y3*y3 - z3*z3_sm_  if(t3&lt_sm_0) n3 _eq_ 0.0_sm_  else {    t3 *_eq_ t3_sm_    n3 _eq_ t3 * t3 * this.dot(this.grad3[gi3]_co_ x3_co_ y3_co_ z3)_sm_  }  // Add contributions from each corner to get the final noise value.  // The result is scaled to stay just inside [-1_co_1]  return 32.0*(n0 + n1 + n2 + n3)_sm_ }_sm_ return SimplexNoise_sm_})()_sm_ NoiseGen _eq_ new SimplexNoise_sm_         ground_geometry _eq_ new THREE.PlaneGeometry(75_co_ 75_co_ 50_co_ 50)_sm_        for (var i _eq_ 0_sm_ i &lt_sm_ ground_geometry.vertices.length_sm_ i++) {            var vertex _eq_ ground_geometry.vertices[i]_sm_            vertex.z _eq_ NoiseGen.noise(vertex.x / 10_co_ vertex.y / 10) * 2_sm_        }_lt_/pre_gt__lt_p_gt_Hi PetSaCoch_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I allowed myself to format your post so it_t_s easier to read the code you posted. (use the icon _t_Code_t_ for that)._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeRightBack","Date":"2014-05-19T16:10:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks for the tips_co_ not sure how to adapt it tho_co_ If ever I come up with something useful_co_ i_t_ll post it_co_ I_t_ll give a try to picking_co_ and wait for the new plugin and doing some test with ammo and oimo _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Dad72","Date":"2014-05-19T17:05:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The plugin system is done_co_ but need someone brave_co_ it starts to do a plugin for amno.js or oimo.js_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeRightBack","Date":"2014-05-19T17:17:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_is it downloadable somewhere? i_t_ll be glad to test it as I plan to stick with Babylon and working full time on it_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeRightBack","Date":"2014-05-19T17:31:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_sorry I_t_m a little slow ... but better late than noting loll_co__co_ so I understand that I can create my own pluggin_co_ using the already implemented _lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_plugin system in 1.12-beta? a lot of fun ahead! since I have to implement physics in my game anyway_co_ i_t_ll do my best_lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Dad72","Date":"2014-05-20T11:29:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_That_t_s cool. will you share then the plugin to benefit the community? I would be very interested._lt_/p_gt__lt_p_gt_Thank you in advance_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeRightBack","Date":"2014-05-20T13:02:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_of course_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Dad72","Date":"2014-05-20T14:10:03Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Cool_co_ It is good to know. good luck for this plugin._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]