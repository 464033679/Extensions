[{"Owner":"Vousk-prod.","Date":"2015-03-23T10:38:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_BTW_co_ your morph experiments are fascinating!_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-23T10:53:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_thank you_lt_/p_gt__lt_p_gt_when talking about poor verbose messages_co_ I meant error-dedicated messages _dd_ try to give wrong indices in a submesh_co_ you_t_ll get the raw webGL error. Not some user friendly message explaining you probably gave not enough indices in regard of vertex numbers._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_that_t_s what I meant. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Vousk-prod.","Date":"2015-03-23T11:18:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yup_co_ I_t_ve totally understood that_co_ no problem. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_happy.png_qt_ alt_eq__qt_^_^_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/happy@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_My post was just to say something like _qt_log is ready to be used_co_ sure there is no real error handling in many parts of BJS but it_t_s never too late to start  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_tongue.png_qt_ alt_eq__qt__dd_P_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/tongue@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  (and in fact_co_ there are parts with good error handling_co_ the whole files and textures loading system and indexDB stuff for instance)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Vousk-prod.","Date":"2015-03-23T11:21:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_(But I think if I have to choose_co_ I also prefer to have a good user doc explaining well all params rather than a good error handling system.)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-03-23T15:57:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Prefer doc please!!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Logging is disastrous for performance and I will not validate a PR that will add logs because_dd__lt_/p_gt__lt_p_gt_- Performance issues_lt_/p_gt__lt_p_gt_- Library size_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-23T16:05:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_all agree ! _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-25T15:06:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_iiiiihaaaaaaa !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Finally_co_ DOUBLESIDE problem solved (I hope)..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Well_co_ no long post with new PG link record this time _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ _co_ only a short demo _dd__lt_/p_gt__lt_p_gt_here is a plane DOUBLESIDE ribbon  with many paths _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%233_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#3_lt_/a_gt_ (please rotate) _lt_/p_gt__lt_p_gt_Note that backfaceculling isn_t_t disabled because it causes z-fighting issues when meshes are created with DOUBLESIDE_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The same (rotate please) with its plain material _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#2_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Let_t_s morph it with a simple y-sinus function (line 33 _dd_ updatePath) _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#1_lt_/a_gt__lt_/p_gt__lt_p_gt_Now you can check that the light reflects both sides._lt_/p_gt__lt_p_gt_Change speed line 89 if you want to play _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This PG code seems pretty long._lt_/p_gt__lt_p_gt_So now imagine_co_ once your ribbon is created_co_ you just give new ribbon paths each frame to one single method in the render loop instead._lt_/p_gt__lt_p_gt_That_t_s what I_t_m trying to implement _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_Just wait and see..._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-03-25T18:29:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_To improve performance I suggest using updatable _eq_ true meshes _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-03-25T19:33:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Updateable is being set true.  It is the arg right after scene in CreateRibbon. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If there was a Float32Array version of BABYLON.VertexData.ComputeNormals_co_ or one that went both ways_co_ mesh.updateVerticesDataDirectly might help._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_A nice demo_co_ but a very high price is being paid for being open ended.  If you had an end point for positions &amp_sm_ matching normals.  You could just interpolate them._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-03-25T19:45:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Gulped_co_ but I have not the time to test it_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_        /**         * @param {any} - positions (number[] or Float32Array)         * @param {any} - indices   (number[] or Uint16Array)         * @param {any} - normals   (number[] or Float32Array)         */        public static ComputeNormals(positions_dd_ any_co_ indices_dd_ any_co_ normals_dd_ any) {            var positionVectors _eq_ []_sm_            var facesOfVertices _eq_ []_sm_            var index_sm_            for (index _eq_ 0_sm_ index &lt_sm_ positions.length_sm_ index +_eq_ 3) {                var vector3 _eq_ new Vector3(&lt_sm_number&gt_sm_ positions[index]_co_ &lt_sm_number&gt_sm_ positions[index + 1]_co_ &lt_sm_number&gt_sm_ positions[index + 2])_sm_                positionVectors.push(vector3)_sm_                facesOfVertices.push([])_sm_            }            // Compute normals            var facesNormals _eq_ []_sm_            for (index _eq_ 0_sm_ index &lt_sm_ indices.length / 3_sm_ index++) {                var i1 _eq_ indices[index * 3]_sm_                var i2 _eq_ indices[index * 3 + 1]_sm_                var i3 _eq_ indices[index * 3 + 2]_sm_                var p1 _eq_ positionVectors[i1]_sm_                var p2 _eq_ positionVectors[i2]_sm_                var p3 _eq_ positionVectors[i3]_sm_                var p1p2 _eq_ p1.subtract(p2)_sm_                var p3p2 _eq_ p3.subtract(p2)_sm_                facesNormals[index] _eq_ Vector3.Normalize(Vector3.Cross(p1p2_co_ p3p2))_sm_                facesOfVertices[i1].push(index)_sm_                facesOfVertices[i2].push(index)_sm_                facesOfVertices[i3].push(index)_sm_            }            for (index _eq_ 0_sm_ index &lt_sm_ positionVectors.length_sm_ index++) {                var faces _eq_ facesOfVertices[index]_sm_                var normal _eq_ Vector3.Zero()_sm_                for (var faceIndex _eq_ 0_sm_ faceIndex &lt_sm_ faces.length_sm_ faceIndex++) {                    normal.addInPlace(facesNormals[faces[faceIndex]])_sm_                }                normal _eq_ Vector3.Normalize(normal.scale(1.0 / faces.length))_sm_                normals[index * 3] _eq_ normal.x_sm_                normals[index * 3 + 1] _eq_ normal.y_sm_                normals[index * 3 + 2] _eq_ normal.z_sm_            }        }_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-25T20:40:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_aarrrg it runs at 20 fps only at home on my old laptop_lt_/p_gt__lt_p_gt_it was 60 fps at work._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_You are right_co_ the computeNormals could get optimized maybe... but I don_t_t feel strong enough to touch something so deep in BJS core and used everywhere_co_ gasp !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Well_co_ this ribbon is quite big _dd_ 160 x 40 path points_co_ so 140 x 40 x 2 (double side)  _eq_ 12800 vertices !!!_lt_/p_gt__lt_p_gt_this means 38400 indices to pass thru to compute normals _dd_-P_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I could have done a simpler example... didn_t_t think_lt_/p_gt__lt_p_gt_It_t_s a special case here _dd_ big ribbon_co_ double side and every point of every path recomputed each frame... maybe not that common_lt_/p_gt__lt_p_gt_don_t_t know_lt_/p_gt__lt_p_gt_the same with BACKSIDE only (+ backfaceculling _eq_ false) _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%234_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#4_lt_/a_gt__lt_/p_gt__lt_p_gt_much better performance !_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T05:38:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I_t_m thiking about another complementary way to improve _lt_em_gt_computeNormals()_lt_/em_gt_ for this case._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_A double-sided existant mesh has twice the same positions and twice more indices than the same single sided mesh_co_ because the second side is just the first side copied and inverted._lt_/p_gt__lt_p_gt_So_co_ if we could tell to the computeNormals method that it shoud compute normals only on half the indices array_co_ it would speed up a lot._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Something like_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_computeNormals(positions_co_ indices_co_ normals_co_ sideOrientation)_lt_/pre_gt__lt_p_gt_If sideOrientation _eq__eq_ DOUBLESIDE then_lt_/p_gt__lt_ul_gt__lt_li_gt_set the limit for computation to _lt_em_gt_half _eq_ indices.length / 2_lt_/em_gt_ and compute normals as usual until this indices array limit_co__lt_/li_gt__lt_li_gt_after the usual normals computation_co_ just add a extra loop to set only the uncomputed backside normals (the second half of the normals array)_lt_/li_gt__lt_/ul_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_normals[i + half] _eq_ -normals[i]_sm__lt_/pre_gt__lt_p_gt_Twice less computations..._lt_/p_gt__lt_p_gt_Should quite as fast as single side normal computation_co_ I guess._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_BTW_co_ I can see  that the _lt_em_gt_computeNormals() _lt_/em_gt_method ( _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/Mesh/babylon.mesh.vertexData.ts#L1116_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/Mesh/babylon.mesh.vertexData.ts#L1116_lt_/a_gt_ ) and yours_co_ JC_co_ have both two new array allocations ( _lt_em_gt_positionsVectors_lt_/em_gt_ and _lt_em_gt_faceOfVertice_lt_/em_gt_)._lt_/p_gt__lt_p_gt_Maybe the _lt_em_gt_computeNormals _lt_/em_gt_method wasn_t_t initially designed to be called in the render loop so it was simple and obvious to use new arrays._lt_/p_gt__lt_p_gt_And it still works well for single-sided big mesh updated in the render loop._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I guess it would worth to think about a way to do without these array allocations. I will give a try... unless someone smarter than me has already the right good idea to do it  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2015-03-26T10:46:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi J!  I don_t_t mean to interrupt your questions (I have no answers) but..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Isn_t_t there SOME (shader?) method that can be used... to avoid EVER using double-sided mesh?  Assuming jMesh.doublesided _eq_ true... this dream shader would_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Check if THIS normal is aiming towards _qt_the back_qt_ per the current viewProjection.  (Is this a dark normal?)_lt_/p_gt__lt_p_gt_    -  IF the normal is aimed backwards_co_ invert the normal._lt_/p_gt__lt_p_gt_    -  IF _lt_u_gt_not_lt_/u_gt_ aimed backwards... continue normal-ly  (ar ar)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I don_t_t know if this would work... and it would be _qt_simulated doublesided_qt_ and not true doublesided._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Maybe that_t_s how our current _lt_em_gt_backFaceCulling _eq_ false_lt_/em_gt_... works.  I haven_t_t studied it._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T13:24:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well_co_ I read much about the doubleside topic._lt_/p_gt__lt_p_gt_The issue is that_co_ in WebGL_co_ one normal is associated to one vertex _dd_ 1 to 1 relationship._lt_/p_gt__lt_p_gt_So if you want the light to be reflected both sides of a mesh_co_ there_t_s only one way (as much as I read about this topic) _dd_ to duplicate vertices._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_When updating a mesh (positions update)_co_ we need to update twice more vertices for a double-sided mesh than for a single-sided one... and to re-compute normals (which is a heavier calculation than just setting news coordinates _dd_ iterate each position_co_ then each indices_co_ make associations per face and compute vector cross products)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The topic is then how to optimize this normal computation for big meshes as it wasn_t_t intended to be used in the render loop initially_co_ I guess._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I don_t_t think a shader could easily do the job_co_ because we need to know everything about all the vertices at once._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-03-26T13:57:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_After think about it_co_ the only changes to the Typescript source for computeNormals() were to pass syntax checking.  Javascript does not do any checking.  I changed one of the hundreds of playgrounds in this thread for storing things in typed / native arrays_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_  var positions _eq_ new Float32Array(mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind) )_sm_  var indices _eq_ new Uint16Array(mesh.getIndices())_sm_  var normals _eq_ new Float32Array(positions.length)_sm__lt_/pre_gt__lt_p_gt_And then using updateVerticesDataDirectly _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_  var updateMesh _eq_ function(mesh_co_ positions_co_ indices_co_ normals_co_ sideOrientation) {    mesh.updateVerticesDataDirectly(BABYLON.VertexBuffer.PositionKind_co_ positions)_sm_    BABYLON.VertexData.ComputeNormals(positions_co_ indices_co_ normals)_sm_    mesh.updateVerticesDataDirectly(BABYLON.VertexBuffer.NormalKind_co_ normals)_sm_  }_sm__lt_/pre_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%237_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#7_lt_/a_gt__lt_/p_gt__lt_p_gt_The change was small_co_ but seems much more constant (probably avoiding all the garbage your way was spewing).  Still think a solution that calls ComputeNormals in the render loop is a bad idea.  Are there 1_co_ 2_co_ or 3 points that represent the maximum extent of the morph?  If so_co_ compute the positions &amp_sm_ normals for them ONCE.  Use them as morph targets.  Interpolate between 2 of them at a time._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T15:17:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Very nice change JC _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Meanwhile_co_ I made changes in my direction. Maybe could we then mix both as they are complementary ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#E0HF5_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#E0HF5_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What did I do ?_lt_/p_gt__lt_p_gt_A big refactor and a strong cleaning up in global variables_co_ functions_co_ etc._lt_/p_gt__lt_p_gt_Now things are more clear._lt_/p_gt__lt_p_gt_I will tag parts with _lt_em_gt_&lt_sm_under the hood&gt_sm__lt_/em_gt_ for people who want to understand how it works and _lt_em_gt_&lt_sm_user friendly&gt_sm__lt_/em_gt_ for people who just want to use it and ignore the former part._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_strong_gt_line 128_lt_/strong_gt_ _dd__lt_/p_gt__lt_p_gt_I coded a generic _lt_em_gt_updateMesh()_lt_/em_gt_ function knowing nothing about the mesh type to be updated. It just needs to receive a _lt_em_gt_positionFunction_lt_/em_gt_ as parameter._lt_/p_gt__lt_p_gt_This _lt_em_gt_positionFunction _lt_/em_gt_function will then be  called inside _lt_em_gt_updateMesh()_lt_/em_gt_ and will set the _lt_em_gt_positions_lt_/em_gt_ array._lt_/p_gt__lt_p_gt_You can also notice (line 135) I don_t_t use the classical _lt_em_gt_computeNormals()_lt_/em_gt_ method but a _lt_em_gt_localComputeNormals()_lt_/em_gt_ instead and that I give it an extra _lt_em_gt_sideOrientation_lt_/em_gt_ parameter._lt_/p_gt__lt_p_gt_This part of code can be shared with any update mesh function._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_/under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_strong_gt_line 100 _lt_/strong_gt__dd__lt_/p_gt__lt_p_gt_I coded the awaited _lt_em_gt_positionFunction()_lt_/em_gt_ method with a closure in the ribbon positions dedicated _lt_em_gt_positionsOfRibbon()_lt_/em_gt_ method._lt_/p_gt__lt_p_gt_Thus the _lt_em_gt_updateMesh() _lt_/em_gt_method can remain generic and useful for any mesh type._lt_/p_gt__lt_p_gt_The mesh positions computation depends only of the mesh type. So we just have to describe in this kind of dedicated method how to compute positions for each kind of mesh _dd_ tube_co_ extrusion_co_ lines_co_ etc._lt_/p_gt__lt_p_gt_This part of code is coded once par mesh type in the API._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_/under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_user friendly&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_strong_gt_line 88_lt_/strong_gt_ _dd_ custom morphing function_lt_/p_gt__lt_p_gt_This function computes a new paths array for ribbon. This is the only part to be then coded by the user _dd_ how is my mesh updated ?_lt_/p_gt__lt_p_gt_The user has only to deal with a paths array to create or update his ribbon. He doesn_t_t need to know more._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_/user friendly&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_strong_gt_line 23_lt_/strong_gt_ _dd_ localComputeNormals_lt_/p_gt__lt_p_gt_I just copied/pasted the original _lt_em_gt_computeNormals()_lt_/em_gt_ method here._lt_/p_gt__lt_p_gt_Then I changed some little things _dd_ I added a new parameter _lt_em_gt_sideOrientation_lt_/em_gt_._lt_/p_gt__lt_p_gt_Why ?_lt_/p_gt__lt_p_gt_Well_co_ we know a double-sided mesh has replicated positions_co_ indices_co_ normals twice. So why not compute normals only on half the positions/indices and then just set the same normals_co_ but negative (backside)_co_ to the rest of the un-computed normals ?_lt_/p_gt__lt_p_gt_It_t_s twice less normal computation_co_ quite the same than for a single sided mesh_co_ isn_t_t it ?_lt_/p_gt__lt_p_gt_Seems to work quite well _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ ... I need to test tonight on my old laptop at home to check the real gain._lt_/p_gt__lt_p_gt_For now_co_ on my work computer_co_ there is no difference between a single-sided and a double-sided mesh._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_/under the hood&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_em_gt_&lt_sm_user friendly&gt_sm__lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_strong_gt_line 149_lt_/strong_gt_ _dd_ render loop and morphing_lt_/p_gt__lt_p_gt_As you can see here_co_ the user has not much work to do _dd__lt_/p_gt__lt_ul_gt__lt_li_gt_to compute his new paths_co__lt_/li_gt__lt_li_gt_to pass them to the couple_lt_em_gt_ positionFunction/updateMesh_lt_/em_gt_ which will be embbeded in a single more pertinent function in the final version _dd_ createRibbon(a_co_b_co_c_co_ _lt_strong_gt_ribbon_lt_/strong_gt_)_lt_/li_gt__lt_/ul_gt__lt_p_gt__lt_em_gt_&lt_sm_user friendly&gt_sm__lt_/em_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T15:38:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_mmhh..._lt_/p_gt__lt_p_gt_something should be still done_co_ I guess ..._lt_/p_gt__lt_p_gt_On my fast computer here_co_ I have 60 fps in chromium with the yesterday dirty code and original c_lt_em_gt_omputeNormals()_lt_/em_gt_ use for DOUBLESIDE _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#1_lt_/a_gt__lt_/p_gt__lt_p_gt_and now only 45 fps with the new link _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#E0HF5_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#E0HF5_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_aaargggg_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_only a good new _dd_ the fps rate is the same with single-sided and double-sided mesh  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_don_t_t understand why_co_ because the number of normal computation was really reduced by two !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_maybe something somewhere else in the code reorganization ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_pffff_co_ need to re-check where something went wrong ..._lt_/p_gt__lt_p_gt_spoke too fast_co_ once again_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2015-03-26T15:51:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_You have just too much for me to keep up with.  On Ubuntu_co_ I only seem to ever hit 30 fps.  Have an original  GTX480_co_ powering a 30_qt_ display (using nVidia driver).  I almost hit 30 with the one you say is 45 fps._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you are going to use your own computeNormals_co_  I would switch to typed arrays for the internal vars &amp_sm_ not re-create them every call. You create them with a fixed size_co_ so index only.  No pushing.  I am talking about_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_    var positionVectors _eq_ []_sm__lt_br_gt_    var facesOfVertices _eq_ []_sm__lt_br_gt_ _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T16:16:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok I understand what you mean._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I personaly think the _lt_em_gt_computeNormals() _lt_/em_gt_method could be used in the render loop... even it means it needs an optimization (BJS wants to be THE optimized tool_co_ nope ? _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ )_lt_/p_gt__lt_p_gt_Your implementation shows we can improve it !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Well_co_ mine too_co_ now ... pfff... I just retested and have now 60 fps (chromium fps display) _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_don_t_t get why this fps vary this way_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I guess something smart can really be done for the _lt_em_gt_computeNormals()_lt_/em_gt_ method _dd__lt_/p_gt__lt_p_gt_maybe_co_ as you suggest_co_ to use typed arrays_co_ use indexes instead of pushing_lt_/p_gt__lt_p_gt_and not to allocate new intermediate array (to store them once at mesh level ?)_lt_/p_gt__lt_p_gt_and to compute normals only for one side if double-sided and then to replicate negative results to the other side_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have to confess I feel afraid to modify this method because it is really much used everywhere in BJS._lt_/p_gt__lt_p_gt_So I won_t_t do it _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_sad.png_qt_ alt_eq__qt__dd_(_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/sad@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_I will just give my opinion _dd_ it should be optimized to be usuable in render loops and no array re-allocation as well as one-side only normal computation for double sided mesh are good leads imho_lt_/p_gt__lt_p_gt_and I agree with you _dd_ typed arrays and indexes uses are very good leads too._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Well_co_ I guess I will implement the mesh update logic using the provided BJS _lt_em_gt_computeNormals()_lt_/em_gt_ whatever it is or will be._lt_/p_gt__lt_p_gt_Things will only get better and better anyway _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_BTW_co__lt_/p_gt__lt_p_gt_My platform is a DELL Precision T1700 tower_lt_/p_gt__lt_p_gt_OS _dd_ ubuntu 14.04 64b_lt_/p_gt__lt_p_gt_RAM _dd_ 8 Gb_lt_/p_gt__lt_p_gt_CPU _dd_ intel xeon E3-1220 at 4 x 3.1 GHz_lt_/p_gt__lt_p_gt_GPU _dd_ Nvidia Quadro K620 with ubuntu provided nvidia driver_lt_/p_gt__lt_p_gt_and two 22_qt_ screens besides_co_ each at 1920 x 1080 resolution... extended desktop_lt_/p_gt__lt_p_gt_Unity window manager and many compiz effects _dd_ windows morphing_co_ transparency_co_ etc_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T17:30:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_tested at home on old laptop ... same result _dd_ 20 fps with or without _lt_em_gt_localComputeNormals()_lt_/em_gt__lt_/p_gt__lt_p_gt_and 20 fps with JC_t_s typed arrays_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_well_co_ this means our _qt_improvements_qt_ don_t_t bring much so far _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you want to test_co_ you people_co_ here are the links (please one after the other_co_ not simultaneously in many tabs) _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_initial Quick&amp_sm_Dirty _eq_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#1_lt_/a_gt__lt_/p_gt__lt_p_gt_JC_t_s typed arrays optimization _eq_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#16NCF0%237_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#16NCF0#7_lt_/a_gt__lt_/p_gt__lt_p_gt_Jerome_t_s half normals computation + cleaning _eq_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#E0HF5_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#E0HF5_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_BTW_co_ I noticed I had often much better fps rate with a script running alone in my browser (from my local webserver) than the same script running in the PG._lt_/p_gt__lt_p_gt_Probably due to editor program ..._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-26T17:56:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_mmmh..._lt_/p_gt__lt_p_gt_after having monitored the 3 versions_co_ it appears that _dd__lt_/p_gt__lt_ul_gt__lt_li_gt_they run quite the same speed_co__lt_/li_gt__lt_li_gt_they don_t_t trigger the GC or impact the VM memory allocator_lt_/li_gt__lt_/ul_gt__lt_p_gt_So these improvements are... above all better code or cleaner code_co_ but nothing really noticeable to the end user._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Well ... how conclude ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In this very case_co_ the end user will be provided a way to update a double-sided mesh_co_ right. That_t_s all._lt_/p_gt__lt_p_gt_He is not obliged to update his mesh each frame in the render loop_co_ he_t_s not obliged to make it double-sided_co_ he_t_s not obliged to have about 40 000 indices in the same mesh._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But if he still wants to_co_ all this at the the time_co_ he would have then to accept that the performance may decrease a lot on not strong GPU._lt_/p_gt__lt_p_gt_That_t_s it._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I had the same kind of problem with dynamicTexture _dd_ 40 text dynamicTextures to update each frame... fps crumbling down._lt_/p_gt__lt_p_gt_I just found another way to do. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_Sometimes you can_t_t fight with the JS VM or the GPU channel._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-27T14:16:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I didn_t_t know if I had to post this rather in this old post _dd_ _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/11907-spherical-harmonic-wingnuts-challenge/?hl_eq_challenge_qt__gt_http_dd_//www.html5gamedevs.com/topic/11907-spherical-harmonic-wingnuts-challenge/?hl_eq_challenge_lt_/a_gt_ or here ..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_well_co_ doesn_t_t matter _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#27QHMX_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#27QHMX_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I just wanted to stress a bit my mesh update algo before starting to code it in TS in BJS _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_the same_co_ public version _dd_ _lt_a href_eq__qt_http_dd_//logiciels.iut-rodez.fr/proto/weathermap/test2/SH.html_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//logiciels.iut-rodez.fr/proto/weathermap/test2/SH.html_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_lines 40-41 _dd__lt_/p_gt__lt_p_gt_delay _dd_ nb of ms between two changes_lt_/p_gt__lt_p_gt_steps _dd_ nb of steps when morphing_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_under the hood _dd_ there is now only one mesh which is updated each frame during a morph sequence instead of a new ribbon object creation in the older script version._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Vousk-prod.","Date":"2015-03-27T14:25:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I prefer with these initial vars _dd_ _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt__lt_span style_eq__qt_font-family_dd__t_courier new_t__co_ courier_co_ monospace_sm__qt__gt_  var delay _eq_ 1000_sm__lt_br_gt_  var steps _eq_ Math.floor(delay/50)_sm__lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-03-27T14:29:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_ _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_laugh.png_qt_ alt_eq__qt__dd_lol_dd__qt__gt_ punchy !_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2015-03-27T14:38:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Oh man_co_ that_t_s gorgeous_co_ Jerome!  Way to go!  Morphing spherical harmonics... YAY!!!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Friggin-ay.  Nice._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_What do you think_co_ guys?  Maybe interpolate the firecolors from previous to next... with the same number of steps as the mesh morph?  (ahem)  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  Maybe that_t_s not important at this time_co_ but..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_...if you think-of each morph step as a path point_co_ then... hmm.  Should the mesh update area include an attempted call to customTextureUpdate_co_ much like tube animating tries to find/call a customRadiusFunction?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]