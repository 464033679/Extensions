[{"Owner":"VictorF","Date":"2018-11-10T11:24:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#222222_sm_font-size_dd_14px_sm__qt__gt_\n\tPlease let me introduce myself_dd_ I’m a total newbie in webgl related projects but I have a big experience in 3d and other render engines like Unreal_co_ now I want to start using webgl experiments and obviously my first step is choosing a engine_co_ but there are two things that will make my decision.\n_lt_/p_gt_\n\n_lt_ul style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#222222_sm_font-size_dd_14px_sm_padding_dd_0px 0px 0px 40px_sm__qt__gt_\n\t_lt_li_gt_\n\t\t_lt_p_gt_\n\t\t\tHow Babylon.js stream the contents? I mean my project should be able to download the assets in streaming without needing to download everything before the “game” starts. Also I played in the past with Google Marzipano_co_ it uses cubemaps (I’ll need them too in this one)_co_ but it has a supernice feature_co_ it allows you to define them in lots of resolutions and it starts using the lower res version and once is loaded it tries to download a higher res and so.\n\t\t_lt_/p_gt_\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\t_lt_p_gt_\n\t\t\tCan I make raycast to concave meshes? I need to get the real world coordinates of a picked point in screen space.\n\t\t_lt_/p_gt_\n\t_lt_/li_gt_\n_lt_/ul_gt_\n\n_lt_p style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#222222_sm_font-size_dd_14px_sm__qt__gt_\n\tThank you in advance!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-11-11T03:17:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello and welcome!!!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t1. Babylon.js can stream content either on demand or when a mesh is required (_lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/using_the_incremental_loading_system_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/how_to/using_the_incremental_loading_system_lt_/a_gt_). On demand is something that you can control by calling SceneLoader.Append() or assetsManager(_lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/how_to_use_assetsmanager_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/how_to/how_to_use_assetsmanager_lt_/a_gt_). We also support container that let you load data to use it later (_lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/how_to_use_assetcontainer_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/how_to/how_to_use_assetcontainer_lt_/a_gt_).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t2. You can cast to any kind of geometry with scene.pick (_lt_a href_eq__qt_https_dd_//doc.babylonjs.com/babylon101/picking_collisions_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/babylon101/picking_collisions_lt_/a_gt_ or _lt_a href_eq__qt_https_dd_//doc.babylonjs.com/babylon101/raycasts_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/babylon101/raycasts_lt_/a_gt_). The other way is supported with _lt_a href_eq__qt_https_dd_//doc.babylonjs.com/api/classes/babylon.vector3#unproject_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/api/classes/babylon.vector3#unproject_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]