[{"Owner":"freetoplay","Date":"2018-08-31T19:11:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI would like some tips on how to optimize my scene. I am trying to create an app that has at least 3 scenes at even given time. Right now_co_ I am using the Vue framework that has a shared components of scenes that looks like this_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_export default Vue.extend({\nname_dd_ _qt_SceneComponent_qt__co_\ndata_dd_ function() {\nreturn {\nengine_dd_ null_co_\nscene_dd_ null\n}_sm_\n}_co_\nprops_dd_ {\nonSceneMount_dd_ {\ntype_dd_ Function_co_\nrequired_dd_ true\n}_co_\n}_co_\nmounted() {\nthis.setupScene()_sm_\n}_co_\nmethods_dd_ {\nsetupScene() {\nconst canvas _eq_ this.$refs.canvas as HTMLCanvasElement_sm_\nthis.engine _eq_ new BABYLON.Engine(canvas_co_ true_co_ null_co_ false)_sm_\nconst scene _eq_ new BABYLON.Scene(this.engine)_sm_\nthis.scene _eq_ scene_sm_\nthis.$nextTick(() _eq_&gt_sm_ {\nwindow.addEventListener(_qt_resize_qt__co_ this.handleResize)_sm_\n})_sm_\nthis.handleResize()_sm_\nthis.onSceneMount({\nscene_dd_ this.scene_co_\nengine_dd_ this.engine_co_\ncanvas_dd_ this.$refs.canvas\n})_sm_\n}_co_\nhandlResize() {\nif (this.engine) {\nthis.engine.resize()_sm_\n}\n}\n}_co_\nbeforeDestroy() {\nwindow.removeEventListener(_qt_resize_qt__co_ this.handleResize)_sm_\n}\n})_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe HTML template looks like this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_&lt_sm_canvas ref_eq__qt_canvas_qt_&gt_sm_&lt_sm_/canvas&gt_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThen currently all of my onSceneMount function for my scenes look like this_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_onSceneMount(data_dd_ ISceneArgs) {\n      const { canvas_co_ scene_co_ engine } _eq_ data_sm_\n      const { fileLocation_co_ fileName } _eq_ this.modelInfo_sm_\n\n      scene.clearColor _eq_ new BABYLON.Color4(0_co_ 0_co_ 0_co_ 1)_sm_\n\n      const main _eq_ async function() {\n        await BABYLON.SceneLoader.AppendAsync(fileLocation_co_ fileName_co_ scene)_sm_\n        BABYLON.SceneOptimizer.OptimizeAsync(scene)_sm_\n        scene.freezeActiveMeshes()_sm_\n        scene.createDefaultCameraOrLight(true)_sm_\n        scene.lights[0].intensity _eq_ 1.5_sm_\n\n        scene.activeCamera.useFramingBehavior _eq_ true_sm_\n\n        scene.activeCamera.alpha +_eq_ Math.PI_sm_\n\n        scene.activeCamera.fov _eq_ 0.6_sm_\n\n        const framingBehavior _eq_ scene.activeCamera.getBehaviorByName(_qt_Framing_qt_)_sm_\n\n        framingBehavior.framingTime _eq_ 0_sm_\n        framingBehavior.elevationReturnTime _eq_ -1_sm_\n\n        const worldExtends _eq_ scene.getWorldExtends()_sm_\n        framingBehavior.zoomOnBoundingInfo(worldExtends.min_co_ worldExtends.max)_sm_\n\n        const meshes _eq_ scene.meshes_sm_\n\n        for (let i _eq_ 1_sm_ i &lt_sm_ meshes.length_sm_ i++) {\n          if (meshes[i].material) {\n            meshes[i].material.freeze()_sm_\n          }\n        }\n\n        let mesh_dd_ BABYLON.AbstractMesh_sm_\n        let xStart _eq_ 0_sm_\n\n        const handlePointerUp _eq_ function(e_dd_ PointerEvent) {\n          canvas.removeEventListener(_qt_pointermove_qt__co_ handlePointerMove)_sm_\n        }_sm_\n\n        const handlePointerLeave _eq_ function(e_dd_ PointerEvent) {\n          canvas.removeEventListener(_qt_pointermove_qt__co_ handlePointerMove)_sm_\n        }_sm_\n\n        const handlePointerMove _eq_ function(e_dd_ PointerEvent) {\n          mesh.rotation.y _eq_ -0.01 * (e.clientX - xStart)_sm_\n          xStart _eq_ e.clientX_sm_\n        }_sm_\n\n        const handlePointerDown _eq_ function(e_dd_ PointerEvent) {\n          mesh _eq_ scene.getMeshByID(_qt___root___qt_)_sm_\n\n          xStart _eq_ e.clientX_sm_\n\n          canvas.addEventListener(_qt_pointermove_qt__co_ handlePointerMove)_sm_\n        }_sm_\n\n        canvas.addEventListener(_qt_pointerdown_qt__co_ handlePointerDown)_sm_\n        canvas.addEventListener(_qt_pointerup_qt__co_ handlePointerUp)_sm_\n        canvas.addEventListener(_qt_pointerleave_qt__co_ handlePointerLeave)_sm_\n\n        engine.runRenderLoop(() _eq_&gt_sm_ {\n          if (scene) {\n            scene.render()_sm_\n          }\n        })_sm_\n      }_sm_\n\n      main()_sm_\n    }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tRendering one scene works great_co_ but working with multiple scenes has been tough. I have attached a screenshot of what I want to do below.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_08/1411352777_Screenshotfrom2018-08-3115-10-04.png.d73d24c5b8a1feb1ee59d99d5abd43b6.png_qt_ class_eq__qt_ipsAttachLink ipsAttachLink_image_qt__gt__lt_img data-fileid_eq__qt_19848_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_08/917091630_Screenshotfrom2018-08-3115-10-04.thumb.png.5cb6f7ade1361797164d7f58bac3a500.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ alt_eq__qt_Screenshot from 2018-08-31 15-10-04.png_qt__gt__lt_/a_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"dbawel","Date":"2018-09-03T08:14:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAs you can convert React/Redux scenes to Vue_co_ I suggest you look at what _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/25365-brianzinn/?do_eq_hovercard_qt_ data-mentionid_eq__qt_25365_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/25365-brianzinn/_qt_ rel_eq__qt__qt__gt_@brianzinn_lt_/a_gt_ has posted on GitHub.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDB\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"brianzinn","Date":"2018-09-03T14:43:54Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI would look at the Remix3D website.  They have images and as you mouse across them_co_ they are using sprites to animate rotation_co_ so without WebGL (the images are like a film strip).  If you pre-generate the images_co_ you should be able to get the rotation.y on mouse move events like in Remix3D.  Selecting a model could then create the scene and engine - or have an engine with the models loaded for quick transition?  When you say _qt_at least 3 scenes_qt_ then I am imagining this is going to struggle on mobile_co_ if they are a target device _lt_span_gt__lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tedit_dd_ You can try only calling scene.render() in your renderLoop when your mouse enters the canvas_co_ too.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]