[{"Owner":"neoRiley","Date":"2014-01-31T20:22:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Neo is a class that I_t_ve been maintaining to make it easier to deal with Babylon and to add some functionality that other api_t_s have natively.  I_t_d love to see these considered for babylon_co_ but done _qt_right_qt_ or with best practices in mind for performance with babylon.  I_t_m not even sure I_t_m handling somethings correctly with Translate/Rotate_co_ so any changes you guys have would be welcomed for sure.  I know I could fork the repo and do a pull request_co_ but I think this is something that needs to be discussed as an approach.  Even though I like this approach and I_t_ve actually helped write a 3D api that was very successful_co_ it ultimately is up to Babylon_t_s developers and I really think a discussion is probably needed and I want to be sure to treat the babylon guys with respect and help out where I can in the right manner._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_That being said_co_ here_t_s what Neo currently adds to BABYLON.Mesh_dd__lt_/p_gt__lt_ul_gt__lt_li_gt_Translate - pass an axis_co_ distance and Neo.Space.WORLD or Neo.Space.LOCAL to specify local/world coordinate space._lt_/li_gt__lt_li_gt_Rotate - like Translate_co_ pass the axis_co_ amount (degrees) and coordinate space._lt_/li_gt__lt_li_gt_DrawAxis - draws a single axis handle_lt_/li_gt__lt_li_gt_DrawAllAxis - draws all 3 axis handles relative to the mesh_lt_/li_gt__lt_/ul_gt__lt_p_gt_Neo also provides simple conversion proprties from degrees &gt_sm_ radians and back - it_t_s simple_co_ but its a calculation that doesn_t_t need to be repeated especially in a loop_lt_/p_gt__lt_ul_gt__lt_li_gt_toDEGREES - usage_dd_ .78*NEO.toDEGREES_sm_ //45 degrees_lt_/li_gt__lt_li_gt_toRADIANS - usage_dd_ 45*NEO.toRADIANS_sm_ //.78 radians_lt_/li_gt__lt_/ul_gt__lt_p_gt_The class_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var NEO _eq_ { REVISION_dd_ _qt_0.0.1_qt_ }_sm_// JavaScript DocumentNEO.Space _eq_ Object.freeze({    LOCAL_dd_0_co_    WORLD_dd_1})_sm_NEO.Axis _eq_ Object.freeze({    X _dd_ new BABYLON.Vector3(1_co_0_co_0)_co_    Y _dd_ new BABYLON.Vector3(0_co_1_co_0)_co_    Z _dd_ new BABYLON.Vector3(0_co_0_co_1)})_sm_/*** Returns a random number between min and max*/NEO.GetRandomInRange _eq_ function(min_co_ max){return Math.random() * (max - min) + min_sm_}_sm_NEO.toDEGREES _eq_ 180/Math.PI_sm_NEO.toRADIANS _eq_ Math.PI/180_sm_NEO.JackIntoBabylon _eq_ function(){        BABYLON.Mesh.prototype.Translate _eq_ function(axis_co_ distance_co_ space)    {        if( space _eq__eq_ NEO.Space.LOCAL )        {                var tempV3 _eq_ this.getPositionExpressedInLocalSpace().add(axis.scale(distance))_sm_            this.setPositionWithLocalVector(tempV3)_sm_        }        else        {            this.computeWorldMatrix(true)_sm_// without this_co_ the final call in a frame overwrites any other calls to translate            this.setAbsolutePosition(this.getAbsolutePosition().add(axis.scale(distance)))_sm_        }    }_sm_        BABYLON.Mesh.prototype.Rotate _eq_ function(axis_co_ amount_co_ space)    {        var tempV3 _eq_ axis.scale(NEO.toRADIANS*amount)_sm_        if( space _eq__eq_ NEO.Space.LOCAL )        {            this.rotation _eq_ this.rotation.add(tempV3)_sm_        }        else        {            var rotationToApply _eq_ BABYLON.Quaternion.RotationYawPitchRoll(tempV3.y_co_ tempV3.x_co_ tempV3.z)_sm_            if( this.rotationQuaternion _eq__eq_ null ) this.rotationQuaternion _eq_ new BABYLON.Quaternion(0_co_0_co_0_co_1)_sm_            this.rotationQuaternion _eq_ rotationToApply.multiply(this.rotationQuaternion)_sm_        }    }_sm_        BABYLON.Mesh.prototype.DrawAllAxis _eq_ function(scene_co_ length_co_ headLength_co_ headWidth )    {        // this creates all three axis arrows and adds it to the mesh for th user                if( length _eq__eq__eq_ undefined ) length _eq_ 5_sm_        if( headLength _eq__eq__eq_ undefined ) headLength _eq_ 2_sm_        if( headWidth _eq__eq__eq_ undefined ) headWidth _eq_ 1_sm_        this.DrawAxis(scene_co_ new BABYLON.Vector3(1_co_0_co_0)_co_ length_co_ new BABYLON.Color3(1_co_0_co_0)_co_ headLength_co_ headWidth)_sm_        this.DrawAxis(scene_co_ new BABYLON.Vector3(0_co_1_co_0)_co_ length_co_ new BABYLON.Color3(0_co_1_co_0)_co_ headLength_co_ headWidth)_sm_        this.DrawAxis(scene_co_ new BABYLON.Vector3(0_co_0_co_1)_co_ length_co_ new BABYLON.Color3(0_co_0_co_1)_co_ headLength_co_ headWidth)_sm_    }_sm_        BABYLON.Mesh.prototype.DrawAxis _eq_ function(scene_co_ dir_co_ length_co_ color_co_ headLength_co_ headWidth)    {        // create an arrow out of cube_t_s and cylinders that faces in the direction specified in world space        // then the user is free to attach to their mesh                if( length _eq__eq__eq_ undefined ) length _eq_ 5_sm_        if( headLength _eq__eq__eq_ undefined ) headLength _eq_ 2_sm_        if( headWidth _eq__eq__eq_ undefined ) headWidth _eq_ 1_sm_        if( color _eq__eq__eq_ undefined ) color _eq_ new BABYLON.Color3(1_co_1_co_0)_sm_ //yellow                // create the arrow container for the line and head        var arrow _eq_ new BABYLON.Mesh(_qt_axisArrow_qt__co_ scene)_sm_        arrow.isVisible _eq_ false_sm_                // create the line        var line _eq_ BABYLON.Mesh.CreateBox(_qt_arrowLine_qt__co_ 1_co_ scene_co_ true)_sm_        var mat _eq_ new BABYLON.StandardMaterial(_qt_arrowColor_qt__co_ scene)_sm_        mat.diffuseColor _eq_ color_sm_        mat.ambientColor _eq_ color_sm_        mat.emissiveColor _eq_ color_sm_        line.material _eq_ mat_sm_        line.scaling _eq_ new BABYLON.Vector3(.1_co_.1_co_ length)_sm_                // create the head        var head _eq_ BABYLON.Mesh.CreateCylinder(_qt_arrowHead_qt__co_ headLength_co_ 0_co_ headWidth_co_ 4_co_ scene_co_ true)_sm_        head.material _eq_ mat_sm_                // set the head in position and rotation        head.Rotate(NEO.Axis.X_co_ -90_co_ NEO.Space.WORLD)_sm_        head.Translate(NEO.Axis.Z_co_ ((length*.5) + (headLength*.5))_co_ NEO.Space.WORLD)_sm_                // parent the line and head to the arrow_co_ then arrow to the mesh        line.parent _eq_ arrow        head.parent _eq_ arrow_sm_                arrow.parent _eq_ this_sm_                // reset to zero locally after being parented so that we_t_re facing straight ahead on z        arrow.rotation _eq_ BABYLON.Vector3.Zero()_sm_                        // deal with rotation locally        if( NEO.Axis.X.equals(dir) )        {                arrow.Translate(NEO.Axis.X_co_ length*.5_co_ NEO.Space.LOCAL)_sm_            arrow.Rotate(NEO.Axis.Y_co_ 90_co_ NEO.Space.LOCAL)_sm_                    }        else if( NEO.Axis.Y.equals(dir) )        {            arrow.Translate(NEO.Axis.Y_co_ length*.5_co_ NEO.Space.LOCAL)_sm_            arrow.Rotate(NEO.Axis.X_co_ -90_co_ NEO.Space.LOCAL)_sm_                    }        else if( NEO.Axis.Z.equals(dir) )        {            arrow.Translate(NEO.Axis.Z_co_ length*.5_co_ NEO.Space.LOCAL)_sm_        }    }_sm_}_lt_/pre_gt__lt_p_gt_Usage_dd_  include the Neo.js file in your project_co_ then call_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_Neo.JackIntoBabylon()_sm_ _lt_/pre_gt__lt_p_gt_The Translate/Rotate methods are still being worked on and I_t_m probably going to add other methods_co_ but for now_co_ this works very well and mirrors other api_t_s that I_t_ve used and rotations work in degrees and convert to radians_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_mesh.Translate(NEO.Axis.Z_co_ length*.5_co_ NEO.Space.LOCAL)_sm_mesh.Rotate(NEO.Axis.Y_co_ 90_co_ NEO.Space.LOCAL)_sm_    _lt_/pre_gt__lt_p_gt_And if you_t_re not used to using radians (like most lower level users of 3D api_t_s are) but you_t_re having to provide radians to deal with a babylon method_co_ you can simply use NEO.toRADIANS to convert from your easy to read degrees to radians.  Personally_co_ I_t_d love to see if babylon could consider having a boolean flag on the engine that allows someone to choose using radians or degrees. This is something we did in Papervision and it went over fairly well with the developers_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_this.sunLight _eq_ new BABYLON.DirectionalLight(_qt_Sun_qt__co_ new BABYLON.Vector3(-22*NEO.toRADIANS_co_-90*NEO.toRADIANS_co_ 0)_co_ this.scene)_sm__lt_/pre_gt__lt_p_gt_The DrawAxis/DrawAllAxis is very easy to use - all you have to do is provide the scene in the arguments for DrawAllAxis.  For debugging_co_ its obviously essential and easy to use.   _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_// draw all 3 axis handles for a meshthis.mesh _eq_ BABYLON.Mesh.CreateSphere(_qt_entryPoint_qt__co_ 10_co_ 1.0_co_scene)_sm_this.mesh.DrawAllAxis(scene)_sm_// draw a single axis handle for a meshthis.mesh.DrawAxis(scene_co_ NEO.Axis.Z)_sm__lt_/pre_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//content.screencast.com/users/neoRiley/folders/Snagit/media/383e8638-e871-4ee3-9e8e-e9c967ac9be2/2014-01-31_12-19-10.png_qt_ alt_eq__qt_2014-01-31_12-19-10.png_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Side note_dd_  I was the first contributor to the Papervision3D (Flash 3D api back in the day) and did a lot of work on the forward facing/public api to make it not only friendly_co_ but to work with the nomenclature of AS3 and flash developers coming in for the first time to use a 3D api - I have a lot of experience with this.  We *could* assume a user understands programing in 3D space (api)_co_ but *had* to assume they did not understand programming 3D space (the engine)_co_ and that_t_s what made PV3D so easy to use and get into in my opinion._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Anyway_co_ I hope this helps others who are struggling with getting into Babylon and I hope we can get some of these things added to babylon and implemented the way babylon would do it.  The developers have been super nice about questions_co_ answers and requests_co_ and that_t_s a huge credit to this api_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks guys_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_John_lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/applications/core/interface/file/attachment.php?id_eq_881_qt__gt_Neo.js.zip_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Alvin","Date":"2014-01-31T21:58:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Great idea_co_ and your project looks really nice _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"neoRiley","Date":"2014-02-02T07:59:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks very much Alvin!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I have an update to Rotate_co_ that fixes world rotation_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.Mesh.prototype.Rotate _eq_ function(axis_co_ amount_co_ space)\t{\t\tvar tempV3 _eq_ axis.scale(NEO.toRADIANS*amount)_sm_\t\tif( space _eq__eq_ NEO.Space.LOCAL )\t\t{\t\t\tthis.rotation _eq_ this.rotation.add(tempV3)_sm_\t\t}\t\telse\t\t{\t\t\tvar rotationToApply _eq_ BABYLON.Quaternion.RotationYawPitchRoll(tempV3.y_co_ tempV3.x_co_ tempV3.z)_sm_\t\t\tif( this.rotationQuaternion _eq__eq_ null ) this.rotationQuaternion _eq_ new BABYLON.Quaternion(0_co_0_co_0_co_1)_sm_\t\t\tthis.rotationQuaternion _eq_ this.rotationQuaternion.multiply(rotationToApply)_sm_\t\t}\t}_sm__lt_/pre_gt__lt_p_gt_There_t_s still an issue with setting local rotation and I_t_m waiting for an answer on how to properly set that.  I_t_ll add that as soon as it_t_s available_co_ but for now_co_ I_t_ve attached the latest version.  I_t_ll have to start versioning the file name _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_NOTE_dd_  If you set WORLD rotation_co_ local rotation calls will not work.  This is due to the fact that Mesh.rotation is abandoned if Mesh.rotationQuaternion is not null.  When you set WORLD rotation on a Mesh_co_ rotationQuaternion is used and there_t_s the issue.  _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/applications/core/interface/file/attachment.php?id_eq_888_qt__gt_Neo.js.zip_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-02-02T16:18:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello neo_co_ do you mind contributing these features to babylon.js ?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-02-02T17:31:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_For DrawAxis_co_ I suggest creating a new BABYLON.Axis object that can be attached (or removed) to a mesh (just for the sake of objects tracking _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-02-02T17:35:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_(I can do the integration if you wish_co_ I do not want to bother you)_lt_/p_gt__lt_p_gt_Or perhaps we couldjust have a mesh.showAxis(true) which can create the axis or remove it. In this way the mesh.dispose could also dispose the axis_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Dad72","Date":"2014-02-02T17:43:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_It would be indeed well to integrate it in Babylon._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"neoRiley","Date":"2014-02-02T18:51:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Definitely would love to have this added to babylon as that was my intention from the beginning - thanks for allowing me to contribute!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I would love to have help Deltakosh - you mention disposing and since I don_t_t know the Mesh class (or engine) that well_co_ it_t_d probably be prudent to have you integrate.  The helper enums/consts were definitely meant to be changed over to a babylone specific signature_co_ I just wasn_t_t sure how you prefer to implement such things. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The one thing I want to get resolved before integration_co_ however_co_ is the rotation issue - right now_co_ I need help setting rotationQuaternion in LOCAL space.  Right now_co_ as I was saying earlier_co_ if someone starts out using Mesh.rotation_co_ and then sets WORLD rotation_co_ they cannot return to using Mesh.rotation.  So_co_ we *have* to provide code to setting local rotation with quaternions before integrating Neo_t_s logic into babylon._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-02-02T19:45:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_But this is working no?_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var rotationToApply _eq_ BABYLON.Quaternion.RotationYawPitchRoll(tempV3.y_co_ tempV3.x_co_ tempV3.z)_sm_            if( this.rotationQuaternion _eq__eq_ null ) this.rotationQuaternion _eq_ new BABYLON.Quaternion(0_co_0_co_0_co_1)_sm_            this.rotationQuaternion _eq_ this.rotationQuaternion.multiply(rotationToApply)_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"neoRiley","Date":"2014-02-04T20:41:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok here_t_s the latest_co_ and please note that babylon has been updated as well thanks to David!  We_t_ve been working hard on getting things ironed out as far having dedicated properties represent local and world space exclusively for euler and quaternion rotation._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_New to babylon_t_s api_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Mesh.rotation _eq_ local euler rotation_lt_/p_gt__lt_p_gt_Mesh.worldRotation _eq_ world euler rotation_lt_/p_gt__lt_p_gt_Mesh.rotationQuaternion _eq_ local quaternion rotation_lt_/p_gt__lt_p_gt_Mesh.worldRotationQuaternion _eq_ world quaternion rotation_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Please note_dd_ we are still looking at some sync issues between local and world eulers.  I_t_ll be posting a question after this to see if someone has time to look at why._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Neo has been updated on how it handles eulers and quats with degree_t_s being passed_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If you want to rotate using Eulers_co_ use RotateEulers()_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_// degrees are converted to radiansRotateEulers(axis_co_ amount_co_ space) // axis_dd_ Vector3_co_ amount_dd_degrees_co_ NEO.Space.WORLD/LOCAL_lt_/pre_gt__lt_p_gt_If you want to rotate using quaternions_co_ use Rotate()_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_// degrees are converted to radiansRotate(axis_co_ amount_co_ space) // axis_dd_ Vector3_co_ amount_dd_degrees_co_ NEO.Space.WORLD/LOCAL_lt_/pre_gt__lt_p_gt_If you want to set Euler rotation to a specific rotation - ie_dd_ setting a mesh_t_s rotation to another_t_s_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_SetEulerRotation(vector3_co_ space)_sm_ // vector3_dd_radians_co_ NEO.Space.WORLD/LOCAL// usage_dd_container.SetEulerRotation(this.entryPoint.rotation_co_ NEO.Space.WORLD)_sm_ // since Mesh.rotation is a Vector3 expressed in radians_lt_/pre_gt__lt_p_gt_So far_co_ this has worked in dealing with parented meshes translating and rotating locally and the question above of how to set WORLD quaternion values has been dealt with _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The latest Neo.js is attached_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I would like to add methods for dealing in radians without the degree conversion_co_ I_t_m just trying to be careful about the nomenclature and what will be added to Babylon later._lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/applications/core/interface/file/attachment.php?id_eq_906_qt__gt_Neo.js.zip_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Dad72","Date":"2014-02-04T22:16:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thank you for this job_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]