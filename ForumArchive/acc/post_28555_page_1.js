[{"Owner":"BeanstalkBlue","Date":"2017-02-20T17:08:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIn both Three.js and Bablyon.js I have implemented almost the exact same scene of 10000 instances of a 30 vertex mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn my _lt_em_gt__lt_strong_gt_Three.js_lt_/strong_gt__lt_/em_gt_ implementation it takes ~_lt_em_gt__lt_strong_gt_3ms_lt_/strong_gt__lt_/em_gt_ to do the draw call that renders these.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn my _lt_em_gt__lt_strong_gt_Babylon.js_lt_/strong_gt__lt_/em_gt_ implementation it takes ~_lt_em_gt__lt_strong_gt_40ms_lt_/strong_gt__lt_/em_gt_ (Frame time) to do 1 draw call that renders these instances. I am following the Instance demo on the babylon website.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn Three.js_co_ there is a _qt_InstancedBufferGeometry_qt_ object that speeds this up considerably. Does BabylonJS have a similar concept? How do I build a vertex buffer that draws these instances faster?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe mesh being drawn is the same for all instances_co_ with the same shader being used for all meshes_co_ with only a small amount of data (position_co_ orientation) of the mesh changing per instance.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2017-02-20T17:10:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSPS\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//doc.babylonjs.com/overviews/solid_particle_system_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/overviews/solid_particle_system_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-02-20T19:15:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t+1 \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe SPS can be seen as the equivalent of the 3JS BufferGeometry.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-20T19:21:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThanks! The SPS is pretty restrictive in how it works though. I am not building a particle system. I guess I could delve into the BabylonJS typescript and duplicate the SPS with customizations for my own system_co_ but is there another way?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tPlaying with SPS in the babylon-playground it seems like this runs quite a lot slower CPU-side (maybe around 5x slower) than what I am doing with three.js so I wonder if under the hood a different method is being used to manage the instances?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-02-20T19:33:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tLike we don_t_t really know what you_t_re trying to achieve_co_ or don_t_t have a 3JS working example to what compare it_co_ it_t_s not easy  to help you ... \n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-20T20:13:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/?do_eq_hovercard_qt_ data-mentionid_eq__qt_25751_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/_qt_ rel_eq__qt__qt__gt_@BeanstalkBlue_lt_/a_gt_ does 3JS cull on the CPU side each instance or is it done triangle-per-triangle on the GPU_t_s side?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf I remember correctly the BJS implementation of Instanced Mesh does the culling on the CPU side (which I think is understandable when you understand at which level BJS is meant to operate) and then reconstruct the InstancedBufferArray before each render.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t know how 3JS is working_co_ but my first guess would be_dd_ no culling_co_ everything is static (except of course the transformation matrix) and that_t_s why it_t_s fast.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo I would say it depend of what you_t_re trying to achieve_co_ culling is costing a lots of CPU time in Javascript_co_ the Mesh class is a full features one in BJS you can do many things with it_co_ but even if you don_t_t use these feature it has an overhead and anyway I think most of the time would be spent during the culling.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you don_t_t mind about CPU culling of your instanced then I guess using BJS_t_ instanced meshes is not the best option. I wonder if SPS is culling on a per instance basis (I don_t_t know SPS very well_co_ but Jerome will answer about this) but I would say it doesn_t_t/shouldn_t_t.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou said SPS is too restrictive for  you_co_ can you tell us which these restrictions you think about? \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-20T20:21:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIf Mesh is CPU culling that would make a lot of sense for why it is taking so much CPU time. I want to do my own culling_co_ as I have an efficient way to do this that applies to my game specifically.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tConsider the case of a minecraft world made up of simple cubes (not my exact case_co_ but close enough). And let_t_s say we want to achieve drawing it with cube instances. We don_t_t need per instance orientations that SPS gives us since all cubes are oriented the same way.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSince the entire world is made of these instances_co_ optimising this process is critical to game performance_co_ so I would like to discard things like the per instance orientations in SPS.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBasically_co_ do I need to look at the BabylonJS code and rebuild the SPS class for my own purposes? Or does BabylonJS expose enough of the primitives that SPS uses so that I can build this myself without even looking at the BabylonJS typescript?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-20T20:49:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk_co_ so it_t_s not about _qt_restrictions_qt_ when you talk about the SPS_co_ it_t_s the opposite_dd_ the SPS system offer more features than you need and then you think you could achieve better performances if you stick to the strict minimum.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI may be wrong_co_ but I don_t_t think you would win a lot of time by getting rid of the orientation info. You would of course_co_ because with what you need a Matrix is not necessary and a simple Vector3 would seal the deal.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMaybe _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ can tell us if it_t_s possible to disable culling at the InstancedMesh level_co_ but I took a look at the instancedMesh.ts file and it doesn_t_t seem to be the case. It could be a fairly simple change to add this feature and CPU time would definitely be won.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut I think you will agree when I say that BJS is a high level 3D Engine_co_ we try to cover most cases but we won_t_t cover them all. If 3JS is rendering a bunch of instanced mesh without doing any culling_co_ well_co_ my first thought would be that it_t_s not a good idea_co_ my second thought would be_dd_ well_co_ the power ratio between one Javascript Thread and a GPU being that ridiculous maybe it_t_s something to consider. But you can_t_t compare the perf of a single drawcall with static buffers against a 3D engine that update the instancedArray buffer while doing culling.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut when I think about what you_t_re willing to do_co_ looks like to me that if rendering all these instances is one of the cornerstone of your game/app and if performances are critical then there_t_s no mistake_dd_ you have to write your own class and stick as close as possible to the metal.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t think it would be something really hard to do_co_ I_t_m relying heavily on InstancedArray for the Canvas2D feature and I_t_ve developed a set of classes to create/update easily the Float32Array buffer that will update the instanced Array and also that support dynamic size (which is a must have when you cull because you don_t_t know how many instances you will send to the GPU)_co_ the class is DynamicFloatArray in the babylon.dynamicFloatArray.ts file. Then you have the whole _qt_low level_qt_ of BJS that you can use to deal with mesh_co_ effect/shaders and their rendering.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt_t_s what I did when I_t_ve developed Canvas2D. It requires you to take a closer look at all these things_co_ but it_t_s accessible and it will definitely pay off at the end if you write your own 3D Visual class.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDescription of the DynamicFloatArray class\n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tQuote\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\t The purpose of this class is to store float32 based elements of a given size (defined by the stride argument) in a dynamic fashion_co_ that is_co_ you can add/free elements. You can then access to a defragmented/packed version of the underlying Float32Array by calling the pack() method._lt_br /_gt_\n\t\t\t   The intent is to maintain through time data that will be bound to a WebGlBuffer with the ability to change add/remove elements._lt_br /_gt_\n\t\t\t   It was first built to efficiently maintain the WebGlBuffer that contain instancing based data._lt_br /_gt_\n\t\t\t   Allocating an Element will return a instance of DynamicFloatArrayElement which contains the offset into the Float32Array of where the element starts_co_ you are then responsible to copy your data using this offset._lt_br /_gt_\n\t\t\t   Beware_co_ calling pack() may change the offset of some Entries because this method will defragment the Float32Array to replace empty elements by moving allocated ones at their location._lt_br /_gt_\n\t\t\t   This method will return an ArrayBufferView on the existing Float32Array that describes the used elements. Use this View to update the WebGLBuffer and NOT the _qt_buffer_qt_ field of the class. The pack() method won_t_t shrink/reallocate the buffer to keep it GC friendly_co_ all the empty space will be put at the end of the buffer_co_ the method just ensure there are no _qt_free holes_qt_. \n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-02-21T05:24:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tthe SPS is a big mesh so it behaves like a mesh _dd_ one world matrix_co_ one global culling.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou don_t_t need to update all the SPS parts (particles) each frame_co_ you can update only the required ones and only when you need what is quite performant in this case _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tsetParticles(i_co_ i) _eq_&gt_sm_ updates only the i-th particle\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can also set/otientate all your particles only once at the world creation for instance and make an immutable SPS is nothing evolves then... or set everything once with an updatable SPS and then just update the very needed part.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSeveral people on this forum made games with a world based SPS like Iiceman or Temechon as far as I remember.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCan_t_t you reproduce a short prototype of what you_t_re dong in the playground and telling us what you would expect from it so we could maybe help you ?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-02-21T17:32:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tYou want to disable culling? easy _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ set mesh.alwaysSelectAsActiveMesh _eq_ true\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-21T17:34:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/?do_eq_hovercard_qt_ data-mentionid_eq__qt_25751_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/_qt_ rel_eq__qt__qt__gt_@BeanstalkBlue_lt_/a_gt_ I don_t_t know if you_t_re still following this thread because you apparently switched back to 3js_co_ but you should give a try to the two _qt_simple_qt_ solutions we proposed_dd_ using SPS or disabling culling like DK mentioned above.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-21T18:11:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThe _qt_disable culling_qt_ suggestion I think doesn_t_t stop every mesh from getting inserted into the world mesh tree_co_ which is still getting cull tested. I_t_m not sure. But debug overlay says _qt_mesh selection_qt_ is still taking ~20ms per frame for 2000 meshes. In my 3JS InstancedBufferGeometry way it is at least 5-10x faster.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am willing to draft a prototype in the playground I guess_co_ but maybe someone can offer some direction first. Is SPS really the way to go for this? Consider this screenshot_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_img alt_eq__qt_hex-field-instance-testing-babylon.png_qt_ class_eq__qt_ipsImage_qt_ height_eq__qt_503_qt_ src_eq__qt_https_dd_//blog.scarlet6.com/images/2017-02/hex-field-instance-testing-babylon.png_qt_ width_eq__qt_1000_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou could think of this as simply a heightfield represented by meshes.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-02-21T18:13:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tmesh selection include also the world matrix computation that you can turn off with mesh.freezeWorldMatrix() and material.freeze()\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-21T18:22:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tThat is faster! When I turn the mesh count up to the same level as my 3JS code it is still a lot slower though. Anything else I am missing? Should I just be writing a prototype of this in the playground? Or is meshes the wrong approach?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-02-21T18:36:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tInstances are the right way to deal with independant meshes that can move or rotate. If you want the 3js equivalent you have to use SPS\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut providing a PG can help us capture what you want to do\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-21T19:54:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/?do_eq_hovercard_qt_ data-mentionid_eq__qt_25751_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/25751-beanstalkblue/_qt_ rel_eq__qt__qt__gt_@BeanstalkBlue_lt_/a_gt_ you really have to test with a static SPS_co_ _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5453_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/_qt_ rel_eq__qt__qt__gt_@jerome_lt_/a_gt_ will be able to help you in case you need it_co_ but you can quickly create a PG and share it using SPS_co_ it should be the same speed as 3JS considering the fact these are typically the same operations.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-02-21T20:12:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tlet_t_s go...\n_lt_/p_gt_\n\n_lt_p_gt_\n\there are 10K cylinders (all updatable if needed) running at 60 fps in my chrome _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VHJYX%230_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VHJYX#0_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-21T20:16:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tWow_co_ thanks for putting in the time and effort to do that! This seems like a great community.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-21T20:25:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI could achieve 400K cylinder still at 60fps on my machine...\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-02-21T20:35:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tsame with some random update _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VHJYX%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VHJYX#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-21T22:42:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIn the case that updating many particles is required_co_ will having two particle systems and then alternating between updating one and rendering the other (render one this frame_co_ render the other next frame) potentially speed things up?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI started writing a playground prototype of this below. How do I stop one SPS from drawing for the current frame? (so that I can theoretically let it_t_s vertex buffer get updated this frame without blocking on that GPU call)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#VHJYX%234_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#VHJYX#4_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-02-21T23:13:18Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tJust call sps.setEnabled(false)_sm_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-22T01:04:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI don_t_t think that_t_s a function of sps actually?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnyway I think for this idea I need to create my own new version of the SolidParticleSystem and implement a double buffered vertex buffer object. Because right now with a single buffer_co_ the SolidParticleSystem becomes coupled to the GPU on vertex data changes_co_ which is bad for performance.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOr please correct me if this is somehow already implemented in Babylon.js.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nockawa","Date":"2017-02-22T01:14:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAre you sure the performances are impacted due to changing the content of the instanced vertex buffer before submitting it for render? Is it something you successfully proved? \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI want to be sure because long time ago we were told by drivers publisher/OpenGL/DX people that we had to do that_co_ then few years later they said it was no longer true because they took care of it (the same way) internally. So I wonder how is it working with WebGL_co_ but my understanding was WebGL was using OpenGL internally_co_ so...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMaybe the implem on mobile is less advanced than desktop_co_ this would be something to check.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut using double buffering techniques must be done when you are really sure you win at the end...a noticeable win...\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-22T01:19:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThat_t_s a good point. Thanks _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tChanging the vertex buffer data is causing a very large drop in framerate for me.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor this optimization_co_ I don_t_t know the answer for sure. I do notice that 3JS has a double-buffered particle system demo.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever maybe I leave this alone for now and optimize it later_co_ since ultimately the fastest way to do this requires WebGL 2.0 anyway_co_ and I don_t_t want to spend too much time on a WebGL 1.0 solution that only saves a small (or maybe zero) render time.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBy the way_co_ I don_t_t want to prematurely optimize_co_ but the reason I am so focused on this right now is that the entire game world is made of these objects_co_ so finding a performant way to draw them is going to be an important task at some point.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]