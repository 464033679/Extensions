[{"Owner":"Ni fait ni à faire","Date":"2015-01-21T11:37:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m working on a project in which a moving light revolves closely around an arbitrary model_co_ revealing the surface it has lit_co_ in a _qt_fog of war_qt_ style (but with precise lighting)_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//pix.toile-libre.org/upload/original/1421827954.png_qt_ alt_eq__qt_1421827954.png_qt__gt__lt_/p_gt__lt_p_gt_(this model is _qt__lt_a href_eq__qt_http_dd_//www.blendswap.com/blends/view/76985_qt_ rel_eq__qt_external nofollow_qt__gt_Ice Asteroid_lt_/a_gt__qt_ by _lt_a href_eq__qt_http_dd_//www.blendswap.com/users/view/jesterelly_qt_ rel_eq__qt_external nofollow_qt__gt_jesterelly_lt_/a_gt_ and is under _lt_a href_eq__qt_http_dd_//creativecommons.org/licenses/by/3.0_qt_ rel_eq__qt_external nofollow_qt__gt_CC-By license_lt_/a_gt_)_lt_/p_gt__lt_p_gt_(the *point* light is just an example_co_ may as well be directional light with a shadowgenerator)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_To do this_co_ I must keep track of once-lit areas to display them even if they are not illuminated atm. As this information can only be assigned to the whole surface (the camera is mobile_co_ and all surface is concerned)_co_ I thought of _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/11602-writing-to-texture-from-a-fragment-shader/_qt__gt_using a texture to store it_lt_/a_gt__co_ _qt_inside_qt_ the model material._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I was kindly pointed toward RenderTargetTextures_co_ which seem the way to go _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ _co_ but I struggle with implementing my plan (and I don_t_t know if it is correct anymore) _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_1) using a new material _eq_ standard material + a light map texture_co_ which stores all pixels of the diffuse texture ever lit ( 0/1 states)_co_ and display (or not) a fragment accordingly. Seems OK._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_2) the _qt_light map_qt_ is a RTT which_lt_/p_gt__lt_ul_gt__lt_li_gt_onBeforeRender replaces the model material with a _qt_detect light_qt_ custom material _dd_ its fragment shader output only convoys light/shadow information_co_ and_lt_em_gt_ _lt_/em_gt__lt_u_gt_it is displayed on a plane_co_ to form the model UV map (but only with lit/unlit zones)_lt_/u_gt_._lt_/li_gt__lt_li_gt_the rendering takes place_co_ creating the _qt_instant_qt_ light map_lt_/li_gt__lt_li_gt_onAfterRender puts back the almost-standard model material_co_ and _lt_u_gt_makes an _qt_addition_qt_ of the newly created light map and the previous one_lt_/u_gt_ (final_uvpixel_value _eq_ uvpixel_value_1 + uvpixel_value_2)_co_  passing it as a texture to the model material._lt_/li_gt__lt_/ul_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I scratch my head on these 2 points _dd_ in particular_co_ I have no idea how to access to the _qt_light state_qt_ of the model surface_co_ presented as a flat texture. I tried to _qt_unwrap_qt_ my model by replacing_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_gl_Position _eq_ viewProjection * finalWorld * vec4(position_co_ 1.0)_sm__lt_/pre_gt__lt_p_gt_by_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_gl_Position _eq_ vec4(vDiffuseUV_co_0._co_ 1.0)_sm__lt_/pre_gt__lt_p_gt_in the standard material vertex_co_ but so far I only got _lt_a href_eq__qt_http_dd_//pix.toile-libre.org/upload/original/1421835227.png_qt_ rel_eq__qt_external nofollow_qt__gt_beautiful glitches (always on UV-mapped models)_lt_/a_gt_. I can_t_t think of another way to go for the moment._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Any idea about this _qt_real-time surface illumination texture_qt_ is welcome _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ (thank you very much for reading this)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-01-21T13:18:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hey again _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_OK_co_ I_t_ve found a solution that works in theory_co_ although it might be slow &amp_sm_ not look incredibly good._lt_/p_gt__lt_p_gt_I_t_ve put in _lt_span style_eq__qt_color_dd_#008000_sm__qt__gt__lt_strong_gt_green_lt_/strong_gt__lt_/span_gt_ the steps that should be done with shaders_co_ and in _lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt__lt_strong_gt_blue_lt_/strong_gt__lt_/span_gt_ the steps to be done with JS code._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt_1/ create a new square texture for your object_lt_/span_gt__co_ containing for each pixel its coordinates like so_dd_ Red _eq_ U (0 to 1)_co_ Green _eq_ V (0 to 1)_co_ Blue _eq_ 0 (important for later)_lt_/p_gt__lt_p_gt__lt_em_gt_Note_dd_ this texture can (and should) be of lower resolution than the true one_co_ in order to gain performance_lt_/em_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt_2/ before drawing the final render of your object_co_ render it first with this _qt_coordinates_qt_ texture_lt_/span_gt_ _lt_u_gt_from the light perspective_lt_/u_gt__co_ in a separate RTT_co_ and without shading_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt_3/ initialize an array of texels defined by their (u_co_v) coordinates_lt_/span_gt__sm_ this will be the list of texels you_t_ll need to mark as _qt_already seen_qt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt_4/ scan every pixels of the separate RTT_lt_/span_gt__co_ and for each_dd__lt_/p_gt__lt_p_gt_  a. if its _t_Blue_t_ value is &gt_sm_0_co_ skip_lt_/p_gt__lt_p_gt_  b. otherwise_co_ obtain the coordinates from the pixel _t_Red_t_ and _t_Green_t_ values (cf. how this texture was built)_lt_/p_gt__lt_p_gt_  c. check if you have a texel with these coordinates in your array_sm_ if not_co_ push the texel in it_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#0000ff_sm__qt__gt_5/ go through all the texels you_t_ve collected in your array_lt_/span_gt__sm_ for each of them_co_ modify the _t_coordinates_t_ texture by setting the _t_Blue_t_ value to 1 at their coordinates_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_#008000_sm__qt__gt_6/ when you do the proper rendering of your object_lt_/span_gt__co_ check for each pixel rendered its corresponding color in the _t_coordinates_t_ texture_sm_ if the _t_Blue_t_ value is zero_co_ it means it has never been lit and you should skip it._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I found the _qt_texture containing UV info_qt_ method while browsing forums and I must say it sounds like a very good start for you! Hope you eventually make it out._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Ni fait ni à faire","Date":"2015-01-21T19:29:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi again !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This seems to be a working solution (which is an incredible leap forward _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ alt_eq__qt__dd_D_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ thx so much)_co_ but the resolution ( 256x256 texture) and performance constraints are difficult trade-offs. I can_t_t believe there is no way to do this in a more WebGL way_co_ I keep searching &amp_sm_ keep this thread updated._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Big thanks _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Ni fait ni à faire","Date":"2015-01-25T18:42:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_There I (hope to) go _dd_ _lt_a href_eq__qt_http_dd_//gamedev.stackexchange.com/questions/31162/updating-texture-memory-via-shader_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//gamedev.stackexchange.com/questions/31162/updating-texture-memory-via-shader _lt_/a_gt__lt_/p_gt__lt_p_gt_Time to do some raw WebGL programming _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_ph34r.png_qt_ alt_eq__qt__dd_ph34r_dd__qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/ph34r@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Ni fait ni à faire","Date":"2015-01-28T04:13:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_68494_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_11877_qt_ data-ipsquote-username_eq__qt_Ni fait ni à faire_qt_ data-cite_eq__qt_Ni fait ni à faire_qt_ data-ipsquote-timestamp_eq__qt_1421840258_qt__gt__lt_div_gt__lt_div_gt_Replacing_lt_p_gt__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_gl_Position _eq_ viewProjection * finalWorld * vec4(position_co_ 1.0)_sm__lt_/pre_gt__lt_p_gt_by_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_gl_Position _eq_ vec4(vDiffuseUV_co_0._co_ 1.0)_sm__lt_/pre_gt__lt_p_gt_in the standard material vertex_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I managed to get the _qt_flattened light map_qt_ effect by patching the_lt_em_gt_ Create Your Own Shader_lt_/em_gt_ Phong vertex shader in a better way _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_vec4 outPosition _eq_ worldViewProjection * vec4(uv.x_co_ uv.y_co_ 0.0_co_ 1.0)_sm_gl_Position _eq_ outPosition_sm__lt_/pre_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//i.imgur.com/HRC27ck.png_qt_ alt_eq__qt_HRC27ck.png_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(flattened surface of a lit sphere)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It still needs some tweaking ( specular looks strange) but is definitely what I was searching for. Big thanks to jahow !_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-01-28T06:49:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well done_co_ this is a great idea _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]