[{"Owner":"Pryme8","Date":"2016-08-14T15:23:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tSo I can totally do the normal ellipsoid camera movements and the same system as demonstrated by _lt_a href_eq__qt_http_dd_//www.babylonjs.com/Demos/Espilit/_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs.com/Demos/Espilit/_lt_/a_gt__lt_br /_gt_\n\tBut Im really running into problems with making this handle like a real FPS controller_co_ like with stepping over things_co_ and how it handles slopes._lt_br /_gt__lt_br /_gt_\n\tWhat would be a better solution? a Ray casting system_co_ or strap a simple object inside of like Cannon and do a mesh hit detection on a hidden capsule...  Whats the best option?  I want something smooth and dynamic.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"mightymarcus","Date":"2016-08-14T15:36:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tUse the bullet physics javascript port.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/armory3d/haxebullet_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/armory3d/haxebullet_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt_t_s a haxe port_co_ but you can find a javascript file ammo.js there. It_t_s automatically ported from C++ to JS with Emscripten. It needs some time to get into it_co_ but then you have first class physics. It_t_s used btw in Blender.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can create a single physics body out of your terrain vertices data. If you want to try it I can show you how to use it_co_ I played around a little with it  and know how to make physic bodies out of indices and vertices. It_t_s a little bit complicated first.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-14T15:38:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI should be able to figure it out_co_ thanks boss!_lt_br /_gt__lt_br /_gt_\n\tAny clue how to make a capsule mesh?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"mightymarcus","Date":"2016-08-14T16:02:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHm. I would make one with blender and export as obj. Then you can get the indices and vertices with babylonjs and hardcode them to your custom createCapsule function. Something like that.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOr you create a sphere and find the vertices in the middle and _qt_stretch_qt_ it. _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-14T16:03:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\thmmm Im glad you decided to grace our forums_co_ I like the way you think.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Pryme8","Date":"2016-08-14T16:58:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//pryme8.github.io/Magic_Marble/editor.html_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//pryme8.github.io/Magic_Marble/editor.html_lt_/a_gt__lt_br /_gt__lt_br /_gt_\n\tI forgot I did a physics controller for this... porting it over now for FPS.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t*UPDATE_dd__lt_br /_gt_\n\tSo I need help... for some reason im drawing a mental block on how to get my speeds play into effect on the forward vector_lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_if(player_box.body.collisionResponse){\n\t\t\tplayer_box.body.grounded _eq_ true_sm_\n\t\t\t}else{\n\t\t\tplayer_box.body.grounded _eq_ false_sm_\t\n\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\tif(player_box.body.grounded){\n\t\t\tif(keys.w){\n\t\t\t\tif(player.speed.f &lt_sm_ settings.speeds.normal.f){\n\t\t\t\t\tplayer.speed.f +_eq_ settings.accel_sm_\n\t\t\t\t}else{\n\t\t\t\tplayer.speed.f _eq_ settings.speeds.normal.f_sm_\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}else if(keys.s){\n\t\t\t\tif(player.speed.f &gt_sm_ settings.speeds.normal.b){\n\t\t\t\t\tplayer.speed.f -_eq_ settings.accel_sm_\n\t\t\t\t}else{\n\t\t\t\tplayer.speed.f _eq_ settings.speeds.normal.b_sm_\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tif(keys.a){\n\t\t\t\tif(player.speed.s &gt_sm_ settings.speeds.normal.s*-1){\n\t\t\t\t\tplayer.speed.s -_eq_ settings.accel_sm_\n\t\t\t\t}else{\n\t\t\t\tplayer.speed.s _eq_ settings.speeds.normal.s*-1_sm_\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(keys.d ){\n\t\t\t\tif(player.speed.s &lt_sm_ settings.speeds.normal.s){\n\t\t\t\t\tplayer.speed.s +_eq_ settings.accel_sm_\n\t\t\t\t}else{\n\t\t\t\tplayer.speed.s _eq_ settings.speeds.normal.s_sm_\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t \tplayer.speed.f*_eq_0.8_sm_\n\t\t\t\tplayer.speed.s*_eq_0.8_sm_\n\t\t\t\tplayer.speed.u_eq_0_sm_\n\t\t\t\tif(player.speed.f&lt_sm_0.05 &amp_sm_&amp_sm_ player.speed.f &gt_sm_ -0.05){\n\t\t\t\t\tplayer.speed.f _eq_ 0_sm_\n\t\t\t\t}\n\t\t\t\tif(player.speed.s&lt_sm_0.05 &amp_sm_&amp_sm_ player.speed.s &gt_sm_ -0.05){\n\t\t\t\t\tplayer.speed.s _eq_ 0_sm_\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar forward _eq_ v3(player.speed.s_co_0_co_player.speed.f).subtract(scene.activeCamera.upVector).normalize()_sm_\n\t\t\t\t\n\t\t\t\t\n\t\t\tplayer_box.body.velocity.x _eq_ forward.x_sm_\n\t\t\tplayer_box.body.velocity.z _eq_ forward.z_sm_\n\t\t\t}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThis example lets you move around forward backwards ect correctly but does not take the cameras current forward into account._lt_br /_gt__lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var forward _eq_ scene.activeCamera.getTarget().subtract(scene.activeCamera.position).normalize()_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\treplacing forward with this_co_ makes the direction of movement correct_co_ but it is constant_co_ and the speed restraints do not come into effect._lt_br /_gt__lt_br /_gt_\n\tforward.x*_eq_ player.speed.s_sm_ forward.z*_eq_player.speed.f_sm__lt_br /_gt_\n\tbut that makes things act really funky._lt_br /_gt__lt_br /_gt_\n\tany ideas?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]