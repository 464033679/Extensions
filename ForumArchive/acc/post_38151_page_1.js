[{"Owner":"lst60916","Date":"2018-06-10T17:53:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks for the great BJS and TOB exporter_lt_span_gt__co__lt_/span_gt_ the meshes could be generated from Blender and rendered in BJS environment efficiently.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever I find out something interesting that _lt_strong_gt_JS heap increases_lt_/strong_gt_ when the _lt_strong_gt_mesh is instanced _lt_/strong_gt_in the scene. But the _lt_strong_gt_heap size could not be decreased when the mesh is disposed_lt_/strong_gt_. I_lt_span_gt_’_lt_/span_gt_m curious whether this will cause some memory issues_lt_span_gt_(_lt_/span_gt_such as memory leak_lt_span_gt_)_lt_/span_gt_._lt_img alt_eq__qt__dd_blink_dd__qt_ data-emoticon_eq__qt__qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_blink.png_qt_ title_eq__qt__dd_blink_dd__qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is the demo of the system_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt__lt_a href_eq__qt_https_dd_//willlinifm.github.io/Playground_bjs/index.html_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//willlinifm.github.io/Playground_bjs/index.html_lt_/a_gt__lt_/span_gt__lt_span_gt__lt_span_gt_ _lt_/span_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe Source code is as the following  or the link _lt_span_gt__lt_span_gt__lt_span_gt__dd__lt_/span_gt__lt_/span_gt__lt_/span_gt__lt_br /_gt_\n\t_lt_a href_eq__qt_https_dd_//willlinifm.github.io/Playground_bjs/js/Scene.js_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//willlinifm.github.io/Playground_bjs/js/Scene.js_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/scenejs.png.4013e6110114a839b038b301fc58a85a.png_qt_ data-fileid_eq__qt_18660_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_scenejs.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18660_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/scenejs.thumb.png.908c3af8f78af50a1b0e5aff69f06b62.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf the playground is better for debugging_lt_span_gt__co__lt_/span_gt_ please try this link.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe implementation and the outcome are nearly the same.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_(_lt_/span_gt_Click Sphere to generate mesh //// Click ground to dispose it_lt_span_gt_)_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt__lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#4GQCEL%232_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#4GQCEL#2_lt_/a_gt__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe attachment are the heap snapshots !_lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t。The heap1 snapshot _lt_u_gt_is took before the mesh is made an instance by TOB-generated-js file_lt_/u_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap1.png.79f6b06151a82f579a6553d975aa8a62.png_qt_ data-fileid_eq__qt_18662_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_heap1.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18662_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap1.thumb.png.6f21a5e7f8485813f167a7b59652a7d1.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t。The heap2 heap snapshot _lt_u_gt_is took after the mesh is made an instance by TOB-generated-js file. We can find that the heap size is increased_lt_/u_gt_._lt_img alt_eq__qt__dd_o_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_ohmy.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/ohmy@2x.png 2x_qt_ title_eq__qt__dd_o_qt_ width_eq__qt_20_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap2.png.56cd3b4dcafa9a390531c622766a889c.png_qt_ data-fileid_eq__qt_18663_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_heap2.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18663_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap2.thumb.png.e23f4f122aa0f3e01d4dcc2dbde1f536.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t。The heap3 snapshot _lt_u_gt_is somehow hard to understand that when the mesh dispose function is called_lt_span_gt__co__lt_/span_gt_ the heap size still raise a high level compared to the first snapshot_lt_/u_gt_._lt_img alt_eq__qt__dd_wacko_dd__qt_ data-emoticon_eq__qt__qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wacko.png_qt_ title_eq__qt__dd_wacko_dd__qt_ /_gt_ _lt_strong_gt_NO~~_lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap3.png.e345efe8b75a3a50eca4746cb7cc3d89.png_qt_ data-fileid_eq__qt_18665_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_heap3.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18665_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/heap3.thumb.png.ec13482796b439dd09d641c80bffa655.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy questions are_lt_span_gt_ _lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t1. If the meshes are generated and the _lt_strong_gt__lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_Js heap size is increasing_lt_/span_gt_ _lt_/strong_gt_at the same time. Will it cause the memory issue and make the system run slowly_lt_span_gt_?_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t2. _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt_How to make the best to _lt_strong_gt_decrease the heap _lt_/strong_gt_size _lt_strong_gt_after mesh dispose_lt_/strong_gt_ process_lt_/span_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t3. I_lt_span_gt_’_lt_/span_gt_m not sure_lt_span_gt__co__lt_/span_gt_ but during watching the snapshot constructor information_lt_span_gt__co__lt_/span_gt_ I find there may be some _lt_strong_gt_looping references_lt_/strong_gt_ within BJS/TOB/MeshFactory structure. Will it cause the _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt__lt_strong_gt_GC(Garbage Collection)_lt_/strong_gt__lt_/span_gt_ unable to release memory_lt_span_gt_?_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you !\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBJS and everything here are awesome!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_ _lt_/span_gt_ \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-06-11T14:35:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t1. Depends on your amount of memory and number of meshes.  Keep in mind if you are using a TOB MeshFactory_co_ it will be creating clones_co_ which are for saving GPU memory_co_ not CPU memory.  Also the default dispose() only releases GPU memory_co_ or only use count when using cloning.  More meshes WILL reduce speed though_co_ just not because of memory.  There are 2 cause_dd_\n_lt_/p_gt_\n\n_lt_ul_gt_\n\t_lt_li_gt_\n\t\tThe cpu time to loop through each mesh in the scene_co_ do computations_co_ see if it will need to be drawn_co_ etc\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tOpenGL draw calls for each mesh.  This can be avoided using BABYON.InstancedMesh not clones_co_ but not really that useful imho.  They still suck cpu just just like clones.  They save on the draw call_co_ BUT they must be of the same material.  Clones can change the material.  If these meshes do not move like trees_co_ better to merge them all together after cloning than use instances.  You save on the draw call &amp_sm_ cpu time.  FYI_co_ meshes can only be merge when the material is the same.\n\t_lt_/li_gt_\n_lt_/ul_gt_\n\n_lt_p_gt_\n\t2.  You must make sure you hold no references in order for the Javascript class to be garbage collected.  Any heap reference vars should be set to null.  There is also a way to delete Javascript objects_co_ but heard that it is slower than GC.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t3. If you are using a MeshFactory_co_ there is a function clean() in it.  In each Mesh class_co_ dispose() is overridden &amp_sm_ clean() is called when you have a mesh factory.  This should remove it as a held reference_co_ and thus not be an impediment to GC.  The reason they have to be kept around in MeshFactory is so a donor mesh_co_ that has not disposed of its GPU geometry_co_ can be located.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"lst60916","Date":"2018-06-12T17:34:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi_co_ _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/8492-jcpalmer/?do_eq_hovercard_qt_ data-mentionid_eq__qt_8492_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/8492-jcpalmer/_qt_ rel_eq__qt__qt__gt_@JCPalmer_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks for your _lt_strong_gt_Expert - Explanation_lt_/strong_gt_! _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_br /_gt_\n\tAfter studying your instruction and related resource_co__lt_br /_gt_\n\tI’m still curious about the following concept.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t1. My scene is designed to display only 5- 10 meshes simultaneously! So maybe draw calls are not a big burden in this condition ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\t2. Even when I try to instance only one mesh_co_ _lt_strong_gt_I face the following condition. The instance function drives a lot of looping-reference relationship? _lt_/strong_gt_(sorry I dont know the exact term. Just find a lot of similar reference with a long distance). It’s is hard for me to find it and de-reference it! Do you know where can I make it? Or do you experience the similar situation before ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t(High poly mesh model link is here  _dd_ _lt_a href_eq__qt_https_dd_//willlinifm.github.io/Playground_bjs/obj/Armour/Armour.js_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//willlinifm.github.io/Playground_bjs/obj/Armour/Armour.js_lt_/a_gt_ )\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_img class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_o_1cfqgge731ota1oqam7g8afqcnb_qt_ src_eq__qt__qt_ alt_eq__qt__qt_ /_gt__lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/loop_ref_question.png.f5189fac03d6e050a45509fc64f146ad.png_qt_ data-fileid_eq__qt_18706_qt_ rel_eq__qt__qt__gt__lt_img class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18706_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_06/loop_ref_question.thumb.png.2e3bfc19aea4038634cc882d8f6d5c73.png_qt_ alt_eq__qt_loop_ref_question.thumb.png.2e3bfc19aea4038634cc882d8f6d5c73.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\t3. If it still raises a high level of heap after I dispose the mesh. _lt_span style_eq__qt_color_dd_#c0392b_sm__qt__gt__lt_strong_gt_What/Where is a good flow to de-reference objects (If MeshFactory is used to instance mesh)_lt_/strong_gt__lt_/span_gt_ ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you so much!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-06-12T20:15:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI am not really sure.  I do not use this browser.  Do not know what a back_pointer exactly is. Looking at your very large file_co_ I see you have child meshes as well.  That is probably something to do with it.  Each child mesh has a reference to the parent.  This is BJS_co_ not TOB.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst_co_ using existing export_co_ call without using MeshFactory_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_var mesh _eq_ new Armour.armour(_qt_armour_qt__co_ scene)_sm_\nmesh.dispose()_sm_\nmesh _eq_ null_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tIf that does not release memory_co_ then either it is either the Armour.armour mesh sub-class or BJS.  I doubt it is the child meshes_co_ since they are member of the parent class_co_ and should go out of scope after mesh _eq_ null_sm_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_this.armour1 _eq_ cloning ? child_armour1(scene_co_ this_co_ source.armour1) _dd_ child_armour1(scene_co_ this)_sm_\nthis.armour2 _eq_ cloning ? child_armour2(scene_co_ this_co_ source.armour2) _dd_ child_armour2(scene_co_ this)_sm_\nthis.armour3 _eq_ cloning ? child_armour3(scene_co_ this_co_ source.armour3) _dd_ child_armour3(scene_co_ this)_sm_\nthis.armour4 _eq_ cloning ? child_armour4(scene_co_ this_co_ source.armour4) _dd_ child_armour4(scene_co_ this)_sm_\n_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2018-06-13T14:12:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tNow that I think about it_co_ it probably is the children holding a reference to the parent by the_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/babylon.node.ts#L70_qt_ rel_eq__qt_external nofollow_qt__gt_ BABYLON.Node_lt_/a_gt_ super class.  Combined with the parent holding a reference to children_co_ neither gets to a reference count of 0.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn my work_co_ I never did a lot of removal with meshes which were both big &amp_sm_ had children to notice.  Try to manually edit the file to remove the references to children.  they are not really used by the parent_co_ I just put them there so you could easily get a reference without going thru the framework_co_ getChildren &amp_sm_ then sort out the right one.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_cloning ? child_armour1(scene_co_ this_co_ source.armour1) _dd_ child_armour1(scene_co_ this)_sm_\ncloning ? child_armour2(scene_co_ this_co_ source.armour2) _dd_ child_armour2(scene_co_ this)_sm_\ncloning ? child_armour3(scene_co_ this_co_ source.armour3) _dd_ child_armour3(scene_co_ this)_sm_\ncloning ? child_armour4(scene_co_ this_co_ source.armour4) _dd_ child_armour4(scene_co_ this)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tFYI_co_ your example is way to big_co_ so I made a sample to show code (top level Cube wt ChildPlane).  This is version 5.6.  I have not committed it.  It has one minor problem that I have not gotten around to dealing with.  It is now ES6.  Looks like now 2 problems.  Was going to finalize soon to be the final version pre-Blender 2.8 though.  Anyway_co_ the top level mesh is subclassed from the base class you specify_co_ and any children are just instances of the base class.  Have not thought of whether I will keep the child references or add  lines in dispose override.  There can be many levels of children_co_ so I_t_ll look at the python to decide.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_class Cube extends BABYLON.Mesh {\n    constructor(name_co_ scene_co_ materialsRootDir_co_ source) {\n        super(name_co_ scene_co_ null_co_ source_co_ true)_sm_\n\n        if (!materialsRootDir) { materialsRootDir _eq_ _qt_./_qt__sm_ }\n        defineMaterials(scene_co_ materialsRootDir)_sm_ //embedded version check\n        var cloning _eq_ source &amp_sm_&amp_sm_ source !_eq__eq_ null_sm_\n        this.position.x  _eq_ 0_sm_\n        this.position.y  _eq_ 0_sm_\n        this.position.z  _eq_ 0_sm_\n        this.rotation.x  _eq_ 0_sm_\n        this.rotation.y  _eq_ 0_sm_\n        this.rotation.z  _eq_ 0_sm_\n        this.scaling.x   _eq_ 1_sm_\n        this.scaling.y   _eq_ 1_sm_\n        this.scaling.z   _eq_ 1_sm_\n        this.ChildPlane _eq_ cloning ? child_ChildPlane(scene_co_ this_co_ source.ChildPlane) _dd_ child_ChildPlane(scene_co_ this)_sm_\n\n        this.id _eq_ this.name_sm_\n        this.billboardMode  _eq_ 0_sm_\n        this.isVisible  _eq_ false_sm_ //always false_sm_ evaluated again at bottom\n        this.setEnabled(true)_sm_\n        this.checkCollisions _eq_ false_sm_\n        this.receiveShadows  _eq_ false_sm_\n        this.castShadows  _eq_ false_sm_\n        this.isPickable _eq_ true_sm_\n        this.initComplete _eq_ false_sm_\n        if (!cloning){\n            this.setVerticesData(_B.VertexBuffer.PositionKind_co_ new Float32Array([\n                1_co_-1_co_-1_co_-1_co_-1_co_1_co_1_co_-1_co_1_co_-1_co_1_co_1_co_1_co_1_co_-1_co_1_co_1_co_1_co_-1_co_-1_co_-1_co_-1_co_1_co_-1\n            ])_co_\n            false)_sm_\n\n            var _i_sm_//indices &amp_sm_ affected indices for shapekeys\n            _i _eq_ new Uint32Array([0_co_1_co_2_co_3_co_4_co_5_co_5_co_0_co_2_co_4_co_6_co_0_co_6_co_3_co_1_co_2_co_3_co_5_co_0_co_6_co_1_co_3_co_7_co_4_co_5_co_4_co_0_co_4_co_7_co_6_co_6_co_7_co_3_co_2_co_1_co_3])_sm_\n            this.setIndices(_i)_sm_\n\n            this.setVerticesData(_B.VertexBuffer.NormalKind_co_ new Float32Array([\n                .577_co_-.577_co_-.577_co_-.577_co_-.577_co_.577_co_.577_co_-.577_co_.577_co_-.577_co_.577_co_.577_co_.577_co_.577_co_-.577_co_.577_co_.577_co_.577_co_-.577_co_-.577_co_-.577_co_-.577_co_.577_co_-.577\n            ])_co_\n            false)_sm_\n\n            this.setMaterialByID(_qt_Layout.Material_qt_)_sm_\n            this.subMeshes _eq_ []_sm_\n            new _B.SubMesh(0_co_ 0_co_ 8_co_ 0_co_ 36_co_ this)_sm_\n            if (scene._selectionOctree) {\n                scene.createOrUpdateSelectionOctree()_sm_\n            }\n        }\n        if (this.postConstruction) this.postConstruction()_sm_\n        this.initComplete _eq_ true_sm_\n        if (matLoaded &amp_sm_&amp_sm_ !_sceneTransitionName){\n            if (typeof this.grandEntrance _eq__eq__eq_ _qt_function_qt_) this.grandEntrance()_sm_\n            else makeVisible(this)_sm_\n\n        } else waitingMeshes.push(this)_sm_\n    }\n\n    dispose(doNotRecurse) {\n        super.dispose(doNotRecurse)_sm_\n        if (this.skeleton) this.skeleton.dispose()_sm_\n    }\n}\nLayout.Cube _eq_ Cube_sm_\n\nfunction child_ChildPlane(scene_co_ parent_co_ source){\n    var ret _eq_ new BABYLON.Mesh(parent.name + _qt_.ChildPlane_qt__co_ scene_co_ parent_co_ source)_sm_\n    var cloning _eq_ source &amp_sm_&amp_sm_ source !_eq__eq_ null_sm_\n    ret.position.x  _eq_ 1.0001_sm_\n    ret.position.y  _eq_ .2351_sm_\n    ret.position.z  _eq_ -.2684_sm_\n    ret.rotation.x  _eq_ 0_sm_\n    ret.rotation.y  _eq_ 0_sm_\n    ret.rotation.z  _eq_ 0_sm_\n    ret.scaling.x   _eq_ 1_sm_\n    ret.scaling.y   _eq_ 1_sm_\n    ret.scaling.z   _eq_ 1_sm_\n\n    ret.id _eq_ ret.name_sm_\n    ret.billboardMode  _eq_ 0_sm_\n    ret.isVisible  _eq_ false_sm_ //always false_sm_ evaluated again at bottom\n    ret.setEnabled(true)_sm_\n    ret.checkCollisions _eq_ false_sm_\n    ret.receiveShadows  _eq_ false_sm_\n    ret.castShadows  _eq_ false_sm_\n    ret.isPickable _eq_ true_sm_\n    ret.initComplete _eq_ false_sm_\n    if (!cloning){\n        ret.setVerticesData(_B.VertexBuffer.PositionKind_co_ new Float32Array([\n            1_co_0_co_-1_co_-1_co_0_co_1_co_-1_co_0_co_-1_co_1_co_0_co_1\n        ])_co_\n        false)_sm_\n\n        var _i_sm_//indices &amp_sm_ affected indices for shapekeys\n        _i _eq_ new Uint32Array([0_co_1_co_2_co_0_co_3_co_1])_sm_\n        ret.setIndices(_i)_sm_\n\n        ret.setVerticesData(_B.VertexBuffer.NormalKind_co_ new Float32Array([\n            0_co_1_co_0_co_0_co_1_co_0_co_0_co_1_co_0_co_0_co_1_co_0\n        ])_co_\n        false)_sm_\n\n        ret.subMeshes _eq_ []_sm_\n        new _B.SubMesh(0_co_ 0_co_ 4_co_ 0_co_ 6_co_ ret)_sm_\n        if (scene._selectionOctree) {\n            scene.createOrUpdateSelectionOctree()_sm_\n        }\n    }\n    if (this.postConstruction) this.postConstruction()_sm_\n    ret.initComplete _eq_ true_sm_\n    return ret_sm_\n}\n_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"lst60916","Date":"2018-06-15T04:16:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/8492-jcpalmer/?do_eq_hovercard_qt_ data-mentionid_eq__qt_8492_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/8492-jcpalmer/_qt_ rel_eq__qt__qt__gt_@JCPalmer_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Thanks for your great instruction! These are good points!_lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_u_gt_Sorry for the late reply_co_ I spent some time following your implementation._lt_/u_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_u_gt_Gladly_co_ the memory heap decreases!_lt_/u_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tRecently I still find that during rendering the high-poly mesh_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthe _lt_strong_gt_cpu_lt_/strong_gt__lt_strong_gt_ heats up and _lt_/strong_gt__lt_strong_gt_fan_lt_/strong_gt__lt_strong_gt_ runs fast and loudly._lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf the memory is controlled in a good way_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\twill it reduce the CPU heat problem ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you again_co_ have a nice day !!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]