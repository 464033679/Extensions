[{"Owner":"Bigus","Date":"2014-09-25T07:24:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_HI All_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m a 3D and Babylon newbie and am struggling with normals. I understand the concept of them (I think) and that in Babylon terms a normal is defined for each vertex_co_ but I don_t_t know what values to use to define those normals or how to calculate them._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Here is what I_t_ve been working on (a way of extruding an object from a 2d face)_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//jsbin.com/noquwehujudi/1/edit_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//jsbin.com/noquwehujudi/1/edit_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The object is meant to be like a rectangular box with a rebate cut out of it and each _qt_face_qt_ of that object is composed of 2 polygons but only one of which is _qt_facing_qt_ the right way._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I basically set all the normals to 1 _ I don_t_t know what that 1 means_co_ it_t_s just a value used in one of the playground demos. I don_t_t understand why some polygons are facing the right way (outwards) and some are facing inwards._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Could someone tell me what I should be doing_co_ in not too mathematical terms?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt__lt_p_gt_Bigus_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-09-25T21:50:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_You need to consider two things_dd__lt_/p_gt__lt_p_gt_- Normals are vector perpendicular to the surface so you have to point them to the right direction _lt_/p_gt__lt_p_gt_- Face order creation_dd_ You should either use right order of creation (Counter clock wise) or use a material with mat.backFaceCulling _eq_ false_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Bigus","Date":"2014-09-26T07:21:03Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Thanks for the reply. I did wonder about the order of the faces as there seemed to be no other logical explanation for it. I_t_ll have a look at backFaceCulling too._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_With normals_co_ what are the actual values expressed in? That is_co_ are they radians or something else? Do they need recalculating when you rotates the object?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-09-26T15:16:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Well_co_ I am having problems with normals myself_co_ trying to re-calculate them on the fly after each frame of deforming / morphing a mesh.  I do know places to look though_co_ for a better understanding. _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_First_co_ a normal is a direction vector_co_ values -1 to 1.  In Babylon it is stored as a flatten array of x0_co_y0_co_z0_co_x1_co_y1_co_z1 …  _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_See a short section on it in the OpenGL equivalent _qt_Blue/Red_qt_ book_co_ _qt_WebGL Programming Guide_qt__co_ pgs 299-301._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also look at source for Mesh.convertToFlatShadedMesh()_co_  maybe run it on your mesh to see what happens. (Might be in AbstractMesh instead)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Finally_co_ I was using code converted to BabylonJS from this page_co_ though since I am having problems_co_ maybe to do not take as perfect._lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//stackoverflow.com/questions/18519586/calculate-normal-per-vertex-opengl_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//stackoverflow.com/questions/18519586/calculate-normal-per-vertex-opengl_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Hope that helps._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Jeff_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2014-09-26T15:21:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi Bigus... welcome to the forum._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_First_co_ here_t_s some links to some forum posts where i first learned about _qt_plotting_qt_._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry31117_qt__gt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry31117_lt_/a_gt__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry31179_qt__gt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry31179_lt_/a_gt__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry32156_qt__gt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry32156_lt_/a_gt__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry32321_qt__gt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-13#entry32321_lt_/a_gt__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-14#entry34152_qt__gt_http_dd_//www.html5gamedevs.com/topic/2571-the-wingnut-chronicles/page-14#entry34152_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_All of those contain SOME kind of demented plotting demo._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But for now_co_ lets take a look at this...  _lt_a href_eq__qt_http_dd_//urbanproductions.com/wingy/babylon/walls/js/wall01.js_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//urbanproductions.com/wingy/babylon/walls/js/wall01.js_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Find the section near the bottom... BABYLON.Wall.prototype.makeplane _eq_ function (width_co_ height) {_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I remarked out the counter-clockwise plotting of the 4 vertex positions_co_ and went with the clockwise method.  Since my camera was mainly looking in a +z direction_co_ I wanted all my normals FOR those 4 points... to face -z... toward the camera. So..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_var normals _eq_ [_lt_br_gt_   0_co_ 0_co_ -1_co__lt_br_gt_   0_co_ 0_co_ -1_co__lt_br_gt_   0_co_ 0_co_ -1_co__lt_br_gt_   0_co_ 0_co_ -1_lt_br_gt_]_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Those are _t_directions_t_.  You could imagine them as..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_var normals _eq_ [_lt_br_gt_   new BABYLON.Vector3(0_co_ 0_co_ -1)_co__lt_br_gt_   new BABYLON.Vector3(0_co_ 0_co_ -1)_co__lt_br_gt_   new BABYLON.Vector3(0_co_ 0_co_ -1)_co__lt_br_gt_   new BABYLON.Vector3(0_co_ 0_co_ -1)_lt_br_gt_]_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now _lt_u_gt__lt_strong_gt_IF_lt_/strong_gt__lt_/u_gt_ I would have used counter-clockwise plotting and the same normals as above_co_ the plane would NOT have been visible from the current camera position.  BUT... with counter-clockwise plotting_co_ and camera positioned same +z looking_co_ I could switch the z-direction of all the normals... like this..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_var normals _eq_ [_lt_br_gt_   0_co_ 0_co_ 1_co__lt_br_gt_   0_co_ 0_co_ 1_co__lt_br_gt_   0_co_ 0_co_ 1_co__lt_br_gt_   0_co_ 0_co_ 1_lt_br_gt_]_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(no negative z factors anymore.  All positive z)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_... and then the plane_t_s face would become visible again._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_u_gt__lt_strong_gt_About indices order_lt_/strong_gt__lt_/u_gt_..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In this demo_co_ I kept the indices the same for both clockwise and counterclockwise plotting._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But I could have simply done a single plotting of ANY kind... like this..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_// clockwise plotting - front face is -z_lt_br_gt_  var positions _eq_ [_lt_br_gt_     hw_co_ -hh_co_ 0_co__lt_br_gt_     hw_co_ hh_co_ 0_co__lt_br_gt_     -hw_co_ hh_co_ 0_co__lt_br_gt_     -hw_co_ -hh_co_ 0_lt_br_gt_  ]_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(hw _eq_ half width_co_ hh _eq_ half-height)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_And then simply switched the _lt_u_gt_order_lt_/u_gt_ of THE INDICES of those... like this..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_  var indices _eq_ []_sm__lt_br_gt_  indices.push(2)_sm__lt_br_gt_  indices.push(1)_sm__lt_br_gt_  indices.push(0)_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_  indices.push(3)_sm__lt_br_gt_  indices.push(2)_sm__lt_br_gt_  indices.push(0)_sm__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(connected the dots of each triangle... in the opposite direction)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So to be brief (yeeeah)... the order of plotting the _lt_u_gt_positions_lt_/u_gt_ is really not important.  It_t_s the order of the indices (the order you connect the dots together with index lines)... that determines clockwise/counter-clockwise.  In other words_co_ I did not need to change the positions data... to attain clockwise and counter-clockwise plotting.  I could have simply reversed the order of _qt_connecting the dots_qt_  (indices)... like shown just above._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So never concern yourself with the order of placing your positions (like I did).  Concern yourself with the order of the indices.  And no recalculating necessary.  We let the framework do lighting FOR us (once we have our lighting normals facing in a direction that the light can see them).  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Have I explained this to the point of confusing you?  Probably.  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_  Hope this helps._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Bigus","Date":"2014-09-27T06:46:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_THanks guys for the responses._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Wingnut_co_ that_t_s a great explanation. Between that_co_ and reading those pages Jeff suggested in the WebGL book_co_ the relationship between points_co_ normals and indices makes sense now._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Initially_co_ I was also wondering what was meant by [counter-]clockwise plotting_co_ i.e_dd_ clockwise in relation to what? But I see now_co_ in the case of my object (and the cube example in that OpenGL book) the plotting (or order of points as specified by the indices) is done clockwise round each face. Applying that_co_ I now have whole faces looking OK (not sorted normals yet)_dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//jsbin.com/noquwehujudi/2/_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//jsbin.com/noquwehujudi/2/_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m not sure I understand why it_t_s necessary to plot the vertices in a particular order though. They just create a triangular polygon between 3 vertices in 3D space_co_ so why does the order matter?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Jeff_co_ on that stackoverflow page_co_ did you manage to translate that response from Shabbi into Javascript/Babylon?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_co_ Bigus_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"chg","Date":"2014-09-27T07:17:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_56200_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_9446_qt_ data-ipsquote-username_eq__qt_Bigus_qt_ data-cite_eq__qt_Bigus_qt_ data-ipsquote-timestamp_eq__qt_1411800389_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_I_t_m not sure I understand why it_t_s necessary to plot the vertices in a particular order though. They just create a triangular polygon between 3 vertices in 3D space_co_ so why does the order matter?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Jeff_co_ on that stackoverflow page_co_ did you manage to translate that response from Shabbi into Javascript/Babylon?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_co_ Bigus_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The order dependence is a old trick to avoid drawing triangles that won_t_t be seen. You don_t_t have to use it (you can turn it off) but but gfx hardware does it for you for free and it saves you from wasting rending time drawing pixels that will never be seen!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The idea is is that if you have a closed mesh_co_ the triangles facing away from the camera at any given instant won_t_t be seen as they will be 100% covered by those that are facing the camera._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It turns out that checking the order of the points_co_ in screen space(!)_co_ is an efficient way to track which way a triangle (or quad_co_ or convex polygon) is facing_co_ as the ordering is preserved by translation_co_ rotation and (positive) scaling so long as that triangle is still ends up with the side you care about facing the camera_co_ and the order is flipped if the triangle doesn_t_t!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This trick works so well in fact that if you just have the odd mesh that_t_s not closed (ie. has tris that need to show either way) it can be more efficient just to duplicate those faces with the reverse winding that to turn face culling off even temporarily._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-09-29T15:12:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yes_co__lt_/p_gt__lt_p_gt_I have also overridden Mesh.setIndices() to determine / store all the faces a given vertex is a member of for performance reasons.  It is in an unreleased BABYLON.Automation sub-class.  Some of the stuff I am doing applies equally to the parent class BABYLON.Mesh_co_ but I am developing in a vacuum_co_ since it was easier._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_That said_co_ it still needs debugging_co_ and I plan on moving at least the caller of the calculation of down to a class called BABYLON.ShapeKeyGroup.  There I store all the final positions of each shape key in the group (A mesh can have multiple groups_co_ MOUTH &amp_sm_ LEGS).  The animation interpolates the correct position of each vertex in the group for a given frame.  Interpolating the normals the same way would be much faster that calc every frame.  If one computes the end point normals when either loading a key from Blender or computes a derived key_co_ higher frame rates can sustained._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_FYI_co_ everything is in native arrays_co_ e.g. Float32Array &amp_sm_ Int16Array.  I also bypass that BABYLON_co_VertexData class and go directly to BABYLON.Engine_co_ except for the initial load._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-10-02T19:30:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have encounter many problems_co_ which I think I have worked through.  Have come up against an issue that I believe is related to how the Blender exporter processes vertices.  I end up with some faces where 2 of the points are identical.  To make sure I was not screwed up_co_ I wrote a separate function to count them_co_ without doing anything._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_function findZeroAreaFaces(meshID) {    var mesh _eq_ scene.getMeshByID(meshID)_sm_    var indices _eq_ mesh.getIndices()_sm_    var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind)_sm_    var nFaces _eq_ indices.length / 3_sm_    var nZeroAreaFaces _eq_ 0_sm_    var faceOffset_sm_    var p1 _eq_ BABYLON.Vector3.Zero()_sm_    var p2 _eq_ BABYLON.Vector3.Zero()_sm_    var p3 _eq_ BABYLON.Vector3.Zero()_sm_    for (var f _eq_ 0_sm_ f &lt_sm_ nFaces_sm_ f++) {        faceOffset _eq_ f * 3_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ indices[faceOffset    ]_co_ p1)_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ indices[faceOffset + 1]_co_ p2)_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ indices[faceOffset + 2]_co_ p3)_sm_        if (p1.equals(p2) || p1.equals(p3) || p2.equals(p3)) {            nZeroAreaFaces++_sm_        }    }\tconsole.log(_qt_# of zero area faces_dd_  _qt_ + nZeroAreaFaces)_sm_}_lt_/pre_gt__lt_p_gt_I point it at most of the Blender meshes I have access to_co_ and it reports &gt_sm_ 0.  This results in a NaN for the sin_alpha calc_co_ since there will be a division by 0.  Somebody have a clue?  My detection is correct_co_ right?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"chg","Date":"2014-10-02T20:23:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Are you sure the Blender meshes you tried weren_t_t just like that? Presuming you have Blender yourself_co_ have you tried cleaning the meshes to remove degenerate geometry?_lt_/p_gt__lt_p_gt_eg. as per _lt_a href_eq__qt_http_dd_//wiki.blender.org/index.php/Doc_dd_2.6/Manual/Modeling/Meshes/Cleanup_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//wiki.blender.org/index.php/Doc_dd_2.6/Manual/Modeling/Meshes/Cleanup_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Or maybe confirming comparing the triangle count Blender gives for the mesh to the raw count (including degenerates) you see from the exporter?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-10-02T21:18:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have full access to the .blends and exporter.  Since posting have implemented similar test code inside the python export.  Get 0 there for a .blend that get 54 in JS. Am sure python test works as I already had a same_vertex() &amp_sm_ also tested with same_vertex(pos1_co_ pos1) and got a numZeroFaces which equalled total faces._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_pos0 _eq_ mesh.vertices[face.vertices[0]].copos1 _eq_ mesh.vertices[face.vertices[1]].copos2 _eq_ mesh.vertices[face.vertices[2]].coif same_vertex(pos0_co_ pos1) or same_vertex(pos0_co_ pos2) or same_vertex(pos1_co_ pos2)_dd_ numZeroAreaFaces +_eq_ 1_lt_/pre_gt__lt_p_gt_Have written my own exporter_co_ Tower of Babel_co_ but it is a re-write of original_co_ especially in this area.  I also tested .babylons out of the original exporter in JS_co_ same result.  Total triangle count exactly matches the number in the banner for Blender for the .blend with 54 issues._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This python code is complicated in two ways_dd__lt_/p_gt__lt_p_gt_-  It processes faces in material order for the benefit of the fragment shader_lt_/p_gt__lt_p_gt_-  Allows for large Blender meshes to be broken into multiple BabylonJS meshes_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Neither come into play for my test blend._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-10-02T21:36:41Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I moved the down test down after the values are stored in the python class members_co_ close to what is going to be written out.  Not getting any zero areas_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_ # just finished a face pos0 _eq_ self.positions[self.indices[indicesCount - 3]] pos1 _eq_ self.positions[self.indices[indicesCount - 2]] pos2 _eq_ self.positions[self.indices[indicesCount - 1]] if same_vertex(pos0_co_ pos1) or same_vertex(pos0_co_ pos2) or same_vertex(pos1_co_ pos2)_dd_ numZeroAreaFaces +_eq_ 1_lt_/pre_gt__lt_p_gt_Am going do 1 more test_co_ where I actually run through the entire self.positions &amp_sm_ self.indices in a separate method.  Exactly the same as the JS above.  Not sure why_co_ but sometimes testing pointless things prove you wrong in important ways._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-10-02T22:14:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ran the python method before_co_ no zero area faces.  That is as close to the output as you can get.  Must be on JS side._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_    def find_zero_area_faces(self)_dd_        nFaces _eq_ int(len(self.indices) / 3)        nZeroAreaFaces _eq_ 0        for f in range(0_co_ nFaces)_dd_            faceOffset _eq_ f * 3            p1 _eq_ self.positions[self.indices[faceOffset    ]]            p2 _eq_ self.positions[self.indices[faceOffset + 1]]            p3 _eq_ self.positions[self.indices[faceOffset + 2]]                        if same_vertex(p1_co_ p2) or same_vertex(p1_co_ p3) or same_vertex(p2_co_ p3)_dd_ nZeroAreaFaces +_eq_ 1                   TowerOfBabel.warn(_t_WARNING_dd_ # of 0 area faces found_dd_  _t_ + str(nZeroAreaFaces)_co_ 2)        _lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-10-03T01:54:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I love it when an error crops up a very short distance from when it was correct.  Get one instance of when it was wrong in JS_co_ find what it should be in python_co_ then mentally _qt_Interpolate_qt_.  In this case_co_ need also multiple value out of indices by 3.  Now can start work forward.  Final JS test code_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_function findZeroAreaFaces(meshID) {    var mesh _eq_ scene.getMeshByID(meshID)_sm_    var indices _eq_ mesh.getIndices()_sm_    var positions _eq_ mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind)_sm_    var nFaces _eq_ indices.length / 3_sm_    var nZeroAreaFaces _eq_ 0_sm_    var faceOffset_sm_    var p1 _eq_ BABYLON.Vector3.Zero()_sm_    var p2 _eq_ BABYLON.Vector3.Zero()_sm_    var p3 _eq_ BABYLON.Vector3.Zero()_sm_    for (var f _eq_ 0_sm_ f &lt_sm_ nFaces_sm_ f++) {        faceOffset _eq_ f * 3_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ 3 * indices[faceOffset    ]_co_ p1)_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ 3 * indices[faceOffset + 1]_co_ p2)_sm_        BABYLON.Vector3.FromArrayToRef(positions_co_ 3 * indices[faceOffset + 2]_co_ p3)_sm_        if (p1.equals(p2) || p1.equals(p3) || p2.equals(p3)) {            nZeroAreaFaces++_sm_        }    }\tconsole.log(_qt_# of zero area faces_dd_  _qt_ + nZeroAreaFaces)_sm_}_lt_/pre_gt__lt_p_gt_It_t_s always obvious once you know why.  Write that down._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]