[{"Owner":"ua4192","Date":"2017-06-13T09:21:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am still figthing with scene optimization. My problem is that the scene I want to manage is very complex.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have used many BABAYLON optimization features.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Disabled from scene all non needed things_dd_ Physics_co_ animations_co_ fog_co_ lensflares_co_ paritcles_co_ postprocesses_co_ textures_co_probes_co_ renderTargets_co_ shadows_co_ skeletons_co_ sprites\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- null mesh AUTOLOD based on bounding box size of each meshes included in the GLTFS I import in the scene and computing the distance\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Instances for using HW accelerated\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- _lt_em_gt__lt_span style_eq__qt_color_dd_#272a34_sm__qt__gt_SceneOptimizerOptions_lt_/span_gt__lt_/em_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_em_gt__lt_span style_eq__qt_color_dd_#272a34_sm__qt__gt_- freeWorldMatrix_lt_/span_gt__lt_/em_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAll my meshes are opaque_co_ no transparency. I wonder if would it be possible to apply a _lt_code_gt_sortObjects_lt_/code_gt_ like it is available in Threejs like a occussion culling\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_em_gt__lt_span style_eq__qt_color_dd_#272a34_sm__qt__gt_Best regards_lt_/span_gt__lt_/em_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-13T23:49:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDo you think this will help? Where are you losing performance? On the CPU side? (you can check it with the profiler_dd_ Which function is the more expensive?)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf the fillrate is the issue then occlusion won_t_t help but you can think about sorting your meshes from front to back to leverage the depth buffer\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-15T13:26:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tNot sure at all_co_ but I guess by reading your answer that maybe makes not sense.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat about serializing the scene?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have been reading that is also posible to stream the scene_co_ do you have any example about how to do it?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany thanks\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-15T15:45:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSerializing the scene to a file?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have no example of a scene streamed to another computer (not supported out of the box)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-16T07:41:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSorry for my lack of explanations about why I am wondering to use serialize.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy point is that I want to use the mesh.simplify feature but the problem is that the simplifications have to be computed each time the user loads the scene.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs there any other way to save these mesh simplifications?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf not_co_ could you describe how to serialize a complex scene (many GLTFS imported with all the optimizations I described in my previous mail) to a JSON file?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany thanks in advanced\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-16T15:25:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo yes you can serialize a scene with BABYLON.SceneSerializer.Serialize(scene)_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#1AGCWP%239_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#1AGCWP#9_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-23T07:38:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSorry for insisting in this topic but I think occlusion culling is one of the main lacks of this wonderful product.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am thinking in a solution based on launching a matrix of rays.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe idea is to split the canvas in a matrix of rays for instance of (160 x 120 )\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe point is that for me_co_ every mesh smaller than the cell set in the matrix is so small that it doesn_t_t need to be rendered.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe idea is to take on the first mesh selected by each ray.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOf course if the camera is no moving no need to do anything.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI can have the list of meshes in frustrum stored in an array and hide all meshes not picked by the ray matrix.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy main problem is that I don_t_t know if in terms of performance this will be possible or not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat do you think about?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2017-06-23T11:54:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tDo not do any optimizations until you know where the bottleneck is.   Invest some time in learning how to use the profiler.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-26T10:29:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere the implementation of my idea using a matrix of ray-cast dividing the screen in cells (in my example 10 x 10).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#FZJRWJ%2383_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#FZJRWJ#83_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn order to trigger the occlusion culling just do a double click with left mouse button and you will see.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy main problem is the time spend by scene.pick and number of cells in canvas.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn this example I am using  a matrix 10 x 10 of rays_co_ the time spent is about 0.5 secs_co_ but if I increase thi number (line 81)_co_ the the time increases dramtically.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor a matrix of 100 x 100 (c_eq_100)  takes nearly 40 secs. It is inviable. My idea was to launch a 500x500 matrix.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt is really a pity that this function could not be executed by GPU.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWe have the mechanism to implement famous occlusion culling but it is really too slow to be practicable.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest regards\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-27T10:31:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs there any difference in performance if I use raycast class instead of scene.pick method?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs raycast processed by GPU or by CPU?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf I am correct_co_ the scene.pick method is processed by CPU.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf it was possible to execute the same method by GPU by any trick it would be wonderfull.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest regards\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2017-06-27T13:42:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tListen to Adam!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can_t_t speed up a scene unless you know where the bottleneck is. If your scene just has too many vertices_co_ then culling objects might help_co_ but if the problem is on the CPU side (and it usually is)_co_ adding more CPU work before rendering won_t_t to help. Things also depend on  mobile vs desktop_co_ etc.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you have a lot of meshes_co_ frustrum culling may be a huge issue - it certainly was for me. Using octrees and merging meshes (with SPS and with submeshes/multimaterials) helped this enormously. But it could be problems with materials_co_ or something else - you have to know what_t_s slow.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-27T14:08:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI confirm _dd_ before making probably useless attempts in every directions_co_ just find where the time is consumed in your scene.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSome leads _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- freeze the world matrix of all meshes that won_t_t move_co_ rotation nor scale\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- set to alwaysActive all the meshes that you sure they always will be in the frustum (no culling computation for them)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- you could also add your own pre-culling depending on your scene and your logic (example _dd_ if a mesh reaches some position where you know it_t_s not visible anymore_co_ deactivate it to sort it out the culling process)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- group_co_ merge everything possible with instances_co_ sps_co_ multimaterial or per mesh UVs_co_ etc to reduce the draw call numbers_co_ use octree else\n_lt_/p_gt_\n\n_lt_p_gt_\n\tetc\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut the point is to find first WHAT and WHERE to optimize.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-27T14:49:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am already using all these techniques.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- LOD based on distance\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- HW instances in combination with LOD (4 levels + null)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Octrees\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Freeze the world matrix of all meshes\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- I have also disabled from scene Collisions_co_ Textures_co_ Physics Engine_co_ Animations_co_ LensFlared_co_ Fog_co_ Particles_co_ Skeletons_co_ Sprites_co_ RenderTarget_co_ PostProcesses and probes\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have also disabled camera collisions.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- I have also tried with scene optimization techniques_co_ but no positive feedback at all.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAbout setting to alwaysActive all the meshes that you sure they always will be in the frustum_co_ it is not an option for me. The camera can move at any direction.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy solution is based on first load the different parts in scene (with LODS) and when all them are loaded then I start to build the scene by instantiating them.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPlease_co_ don_t_t tell me that I am going in all directions_co_ I have tried everything and Occlusion Culling is the only solution I see. In fact if this is not posible then my only option is to replace the scene by its bounding box_co_ twhen changing camera position and then when camera will be aging static make the scene visible again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere you can see the numbers from stats provided by Debug Layer in one of my scenes_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTotal Meshes_dd_ 80289\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDraw Calls_dd_ 1737\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTotal Lights_dd_ 1\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTotal Vertices_dd_ 77477904\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTotal Materials_dd_4817\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTotal Textures_dd_ 0\n_lt_/p_gt_\n\n_lt_p_gt_\n\tActive Meshes_dd_ 21998\n_lt_/p_gt_\n\n_lt_p_gt_\n\tActive Indices_dd_ 1732170\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs you can see the scene is very complex_co_ and this is the reason why I am thinking in performing a kind of occlusion culling technique. I am making an intensive usage of instancing to reduce the number of drawcalls.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI don_t_t need any tool to see where the problem is_co_ (numbers of drawcalls and vertices) As you can guess_co_ if you try to rotate the camera you will see that this is un-handleable by BABYLONJS.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI would really appreciate if you could answer to my question and tell me if it is possible to use GPU to mesh picking in anyway. I continue thinking that my idea is good but not achievable due that this method is computed by CPU and not by GPU.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany thanks in advanced.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest regards\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"SvenFrankson","Date":"2017-06-27T15:27:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAre you sure there is no way of avoiding Raycasting ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCould some algorithm like\n_lt_/p_gt_\n\n_lt_ul_gt__lt_li_gt_\n\t\tEach frame\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tPick N meshes\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tCompute their size on screen (squared distance from Camera could be enough if they have the same size)\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tIF small enough (far enough if you computed squared distance) _dd_ _lt_strong_gt_Hide_lt_/strong_gt_\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tELSE _dd_ _lt_strong_gt_Show_lt_/strong_gt_\n\t_lt_/li_gt_\n_lt_/ul_gt__lt_p_gt_\n\tDo the job ? For this kind of case (many meshes)_co_ I_t_ve seen it working pretty well...\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2017-06-27T15:53:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_179829_qt_ data-ipsquote-contentid_eq__qt_31040_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1498574967_qt_ data-ipsquote-userid_eq__qt_26724_qt_ data-ipsquote-username_eq__qt_ua4192_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t1 hour ago_co_ ua4192 said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tI am already using all these techniques [LOD/instances/octrees]   ... _lt_span style_eq__qt_color_dd_#272a34_sm__qt__gt_I don_t_t need any tool to see where the problem is_lt_/span_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tThis is a kind of dangerous way to do things. All those techniques can slow down a scene as well as speed it up_sm_ if you_t_re not profiling often it_t_s hard to know if they_t_re helping.\n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_179829_qt_ data-ipsquote-contentid_eq__qt_31040_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1498574967_qt_ data-ipsquote-userid_eq__qt_26724_qt_ data-ipsquote-username_eq__qt_ua4192_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t1 hour ago_co_ ua4192 said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tI would really appreciate if you could answer to my question and tell me if it is possible to use GPU to mesh picking in anyway. I continue thinking that my idea is good but not achievable due that this method is computed by CPU and not by GPU.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI don_t_t think there_t_s any general thing that can be done automatically for occlusion culling - if there was every engine would do it already. There are apparently GPU culling techniques (I_t_m not familiar with them)_co_ but they need to be designed around the content.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo I think your best bet for culling is what Jerome said - it will help if it can be done manually based on unchanging things in your scene. For example if there_t_s a building in the middle of the scene_co_ and you can know that when the player is on one side of it then things on the other side are occluded_co_ etc. Or more generally_co_ you could take some kind of approach of choosing the most complex geometries in the scene and pre-caclucating some data structure of where they_t_re visible from.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut any kind of general occlusion testing that_t_s done per-frame is going to cost more than it saves.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2017-06-27T16:09:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tFollow up - in looking at the sorting feature Three does_co_ I don_t_t thing BJS does this but I_t_ve no idea if it would help. You could try it easily enough - AFAIK if you manually sort the _qt_scene.meshes_qt_ list by distance every N frames it ought to have the same effect.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-27T18:20:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt seems that there is some kind of technique to pick meshes by using GPU is possible_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/22471-gpu-picking-system/_qt_ rel_eq__qt__qt__gt_http_dd_//www.html5gamedevs.com/topic/22471-gpu-picking-system/_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy problem is I am totally new with GPU system and to be frank I don_t_t catch the code.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn fact the solution I did was using the method scene.pick in order to apply my own occlussion culling function. Of course the time spent by this function depends directly on the amount of rays launched in each iteration.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t10*10 --&gt_sm_ 0.3 secs\n_lt_/p_gt_\n\n_lt_p_gt_\n\t25 * 25 --&gt_sm_ 3.5 secs\n_lt_/p_gt_\n\n_lt_p_gt_\n\t50 * 50 --&gt_sm_ 30 secs\n_lt_/p_gt_\n\n_lt_p_gt_\n\t100*100 --&gt_sm_ 90 secs\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI will continue investigating.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany many thanks for your support.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-27T21:11:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tQuote\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\t \n\t\t_lt_/p_gt_\n\n\t\t_lt_p style_eq__qt_color_dd_#272a34_sm__qt__gt_\n\t\t\tTotal Meshes_dd_ 80289\n\t\t_lt_/p_gt_\n\n\t\t_lt_p style_eq__qt_color_dd_#272a34_sm__qt__gt_\n\t\t\tDraw Calls_dd_ 1737\n\t\t_lt_/p_gt_\n\n\t\t_lt_p style_eq__qt_color_dd_#272a34_sm__qt__gt_\n\t\t\tTotal Vertices_dd_ 77477904\n\t\t_lt_/p_gt_\n\n\t\t_lt_p style_eq__qt_color_dd_#272a34_sm__qt__gt_\n\t\t\tTotal Materials_dd_4817\n\t\t_lt_/p_gt_\n\n\t\t_lt_p style_eq__qt_color_dd_#272a34_sm__qt__gt_\n\t\t\tActive Meshes_dd_ 21998\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\t \n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tOuch !\n_lt_/p_gt_\n\n_lt_p_gt_\n\tImho_co_ you should reduce every number from this list for several reasons _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- 22K meshes in the frustum is more than the human eyes can distinguish on the screen. Imagine that you could manage only 8-12K instances (what is already huge)_co_ recycle them to display all of them as if they were 22K instead (say_co_ you paste a texture in the background with just images of your distant meshes far away or any other trick). Handling 10K of things compared to 22K makes a real difference for the CPU.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Actually_co_ your scene has 80K meshes !!! Well... JS is monothreaded_co_ you know_co_ and you will probably have to iterate 80K times to process the logic of all your meshes. Even for the latest V8 engine_co_ with the latest CPU model_co_ this is a long computation compared to the small delay of 16ms between two frames if you want to keep 60 fps. As an example_co_ just try to compute 80K times the multiplication of two 4x4 float matrices_co_ then with a vector4_co_ then normalize the result (something what is done dozen of times for any little 3D maths operation inside the engine) and check the elapsed time. No logic_co_ no rendering_co_ just a standard 3D calculation. You might be surprised _sm_-)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tRemember that the iterations of your logic are followed by the same iterations by the engine to compute the culling_co_ then the world matrices and the rendering ... much work for the CPU.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo here again_co_ I would suggest that you manage far less meshes. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMaybe could you manage 80K logical representations or data structures and only the really lowest number of meshes. As they can_t_t be seen all at once_co_ neither distinguished_co_ you probably don_t_t need to instanciate such a high number of things that will then be injected and processed by the whole 3D workflow.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Same advice for the number of materials_co_ especially if you don_t_t use any texture !\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- At last_co_ try also to reduce the total number of draw calls _dd_ well_co_ this would automatically decrease with less managed meshes_co_ less visible meshes and less materials.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo_co_ before trying to investigate the GPU occlusion_co_ if I were you_co_ I would rather rethink the global approach and decouple the logic (maybe you need 80K occurrences of something anyway) from what would really have to be currently depicted by meshes (3D representation of the logic_co_ what is to be passed to the engine) and then how to reduce/optimize/fake the final render of this representation (the meshes in the frustum at the lower cost).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-28T14:58:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am afraid I am not able to apply these techniques.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI will try to explain briefly.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy framework is a CAD visualization system.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe ASSETS are extracted from  an Oracle DB_co_ basically for each record in the DB I have the  following information_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Filename\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Row_ID\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Transformation matrix (position and rotation)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have no idea about occlusion culling logic of my CAD data. The goal is to be able to see the scene moving the camera in any direction_co_ so this is the reason I am thinking in this approach to limit the number of meshes in the frustrum. The reason you see so many active meshes is that 80% of them are occluded by other meshes. Think in a plane fuselage and parts inside..\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf scene.pickmesh was executed by GPU_co_ I am quite sure my solution run fine.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor me launching a matrix of 30x30 should be enough (900 meshes at maximum) at any moment.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOf course if the camera is not moving_co_ no need to launch the function to occlude meshes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf the camera only pans_co_ a % of already computed occluded meshes could be still valid_co_ for zooming in and out_co_ maybe not so easy to resuse.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDo you understand my problem now and why I am thinking in deploying this technique?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest regards\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-28T18:30:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI understand what you mean but if you want to pass 80K meshes to the GPU (or 77 million vertices !)_co_ before any selection CPU side to reduce drastically this order of magnitude_co_ I_t_m afraid you will still encounter performance issues anyway_co_ even with a good GPU occlusion algo.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThat_t_s the reason why I was suggesting to rethink the global approach and to decouple the data extracted from your DB from their 3D representations (the meshes) in order to manage far less 3D representations than the total data. Just my humble opinion.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut I_t_m really curious to discover a decent working GPU occlusion algo that would achieve to handle so many meshes. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"reddozen","Date":"2017-06-28T19:08:45Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI couldn_t_t find a good occlusion method either _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5453_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/_qt_ rel_eq__qt__qt__gt_@jerome_lt_/a_gt_ I ended up subdividing my scene into dynamic regions and calculating _t_neighbor_t_ cubes and dropping the visibility of those meshes not in my local regions. Every so many frames I recalc what region the camera is in and reevaluate what regions are loaded and what regions need to be hidden or loaded. When you call this evaluation can probably still be greatly optimized. This is just something I_t_m playing with as I have time....\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_m loading lists of models dynamically from a database too.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can see the region functions I wrote here and the fully built scene load call_dd__lt_br /_gt__lt_a href_eq__qt_http_dd_//www.red12.studio/Demos/Web/Include/Loaders/map_loader.php?region_eq_1&amp_sm_zone_eq_1_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.red12.studio/Demos/Web/Include/Loaders/map_loader.php?region_eq_1&amp_sm_zone_eq_1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis is the PHP for the actual load builder (creates a javascript function to call _qt_load map_qt_ from the main scene)\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_&lt_sm_?php\necho _qt_\n// build all the map objects\nvar load_map _eq_ function(scene_co_ offset_co_ DBObj_co_ REGIONS)\n{_qt__sm_\n\t$last_obj_eq__qt__qt__sm_\n\tlist($res) _eq_ get_query(_qt_SELECT MIN( px ) AS min_px_co_ MAX( px ) AS max_px_co_ MIN( pz ) AS min_pz_co_ MAX( pz ) AS max_pz_co_ MIN( py ) AS min_py_co_ MAX( py ) AS max_py FROM `map_info` WHERE `region`_eq__qt_. $region ._qt_ &amp_sm_&amp_sm_ `zone`_eq__qt_. $zone ._qt__sm__qt_)_sm_\n\t$SR _eq_ mysql_fetch_array($res)_sm_\n\n\t$min_x _eq_ $SR[_t_min_px_t_]_sm_\n\t$max_x _eq_ $SR[_t_max_px_t_]_sm_\n\t$min_z _eq_ $SR[_t_min_pz_t_]_sm_\n\t$max_z _eq_ $SR[_t_max_pz_t_]_sm_\n\t$min_y _eq_ $SR[_t_min_py_t_]_sm_\n\t$max_y _eq_ $SR[_t_max_py_t_]_sm_\n\n\tif ($min_x &lt_sm_ 0) { $min_x _eq_ floor($min_x)_sm_ } else { $min_x _eq_ ceil($min_x)_sm_ }\n\tif ($max_x &lt_sm_ 0) { $max_x _eq_ floor($max_x)_sm_ } else { $max_x _eq_ ceil($max_x)_sm_ }\n\tif ($min_y &lt_sm_ 0) { $min_y _eq_ floor($min_y)_sm_ } else { $min_y _eq_ ceil($min_y)_sm_ }\n\tif ($max_y &lt_sm_ 0) { $max_y _eq_ floor($max_y)_sm_ } else { $max_y _eq_ ceil($max_y)_sm_ }\n\tif ($min_z &lt_sm_ 0) { $min_z _eq_ floor($min_z)_sm_ } else { $min_z _eq_ ceil($min_z)_sm_ }\n\tif ($max_z &lt_sm_ 0) { $max_z _eq_ floor($max_z)_sm_ } else { $max_z _eq_ ceil($max_z)_sm_ }\n\n\t$x_levels _eq_ ceil((abs($max_x) + abs($min_x)) / $sub_region_size)_sm_\n\t$y_levels _eq_ ceil((abs($max_y) + abs($min_y)) / $sub_region_size)_sm_\n\t$z_levels _eq_ ceil((abs($max_z) + abs($min_z)) / $sub_region_size)_sm_\n\n\t$region_id _eq_ 1_sm_\n\tfor ($ix_eq_1_sm_ $ix&lt_sm__eq_$x_levels_sm_ $ix++)\n\t{\n\t\t$min_x_t _eq_ $min_x + ($sub_region_size * ($ix-1))_sm_\n\t\t$max_x_t _eq_ $min_x_t + $sub_region_size_sm_\n\t\t$min_y_t _eq_ $min_y_sm_\n\t\t$max_y_t _eq_ $min_y_t + $sub_region_size_sm_\n\t\t$min_z_t _eq_ $min_z_sm_\n\t\t$max_z_t _eq_ $min_z_t + $sub_region_size_sm_\n\n\t\tfor ($iz_eq_1_sm_ $iz&lt_sm__eq_$z_levels_sm_ $iz++)\n\t\t{\n\t\t\t$min_z_t _eq_ $min_z + ($sub_region_size * ($iz-1))_sm_\n\t\t\t$max_z_t _eq_ $min_z_t + $sub_region_size_sm_\n\n\t\t\tfor ($iy_eq_1_sm_ $iy&lt_sm__eq_$y_levels_sm_ $iy++)\n\t\t\t{\n\t\t\t\t$min_y_t _eq_ $min_y + ($sub_region_size * ($iy-1))_sm_\n\t\t\t\t$max_y_t _eq_ $min_y_t + $sub_region_size_sm_\n\n\t\t\t\t$region_info[$region_id][_t_min_x_t_] _eq_ $min_x_t_sm_\n\t\t\t\t$region_info[$region_id][_t_max_x_t_] _eq_ $max_x_t_sm_\n\t\t\t\t$region_info[$region_id][_t_min_y_t_] _eq_ $min_y_t_sm_\n\t\t\t\t$region_info[$region_id][_t_max_y_t_] _eq_ $max_y_t_sm_\n\t\t\t\t$region_info[$region_id][_t_min_z_t_] _eq_ $min_z_t_sm_\n\t\t\t\t$region_info[$region_id][_t_max_z_t_] _eq_ $max_z_t_sm_\n\n\t\t\t\techo _qt_\n\tREGIONS[_qt_. $region_id ._qt_] _eq_ {\n\t\tmin_x_dd_ _qt_. $min_x_t ._qt__co_\n\t\tmax_x_dd_ _qt_. $max_x_t ._qt__co_\n\t\tmin_y_dd_ _qt_. $min_y_t ._qt__co_\n\t\tmax_y_dd_ _qt_. $max_y_t ._qt__co_\n\t\tmin_z_dd_ _qt_. $min_z_t ._qt__co_\n\t\tmax_z_dd_ _qt_. $max_z_t ._qt__co_\n\t\tregion_x_dd_ _qt_. $ix ._qt__co_\n\t\tregion_y_dd_ _qt_. $iy ._qt__co_\n\t\tregion_z_dd_ _qt_. $iz ._qt__co_\n\t\tneighbors_dd_ []_co_\n\t\tinside_dd_ []\n\t}_sm__qt__sm_\n\n\t\t\t\t$region_id++_sm_\n\t\t\t}\n\t\t}\n\t}\n\n\n\techo _qt_\n\n\tcalculate_neighbors(REGIONS)_sm_\n\n\n\t// lights\n\tvar sun _eq_ new BABYLON.HemisphericLight(\\_qt_Hemi0\\_qt__co_ new BABYLON.Vector3(0_co_ 1_co_ 0)_co_ scene)_sm__qt__sm_\n\n\n\tif (!$inside)\n\t{\n\t\techo _qt_\n\n\n\t// skybox\n\tvar skybox _eq_ BABYLON.Mesh.CreateBox(\\_qt_skyBox\\_qt__co_ 170.0_co_ scene)_sm_\n\tvar skyboxMaterial _eq_ new BABYLON.StandardMaterial(\\_qt_skyBox\\_qt__co_ scene)_sm_\n\tskyboxMaterial.backFaceCulling _eq_ false_sm_\n\tskyboxMaterial.reflectionTexture _eq_ new BABYLON.CubeTexture(\\_qt_Include/Skybox/skybox\\_qt__co_ scene)_sm_\n\tskyboxMaterial.reflectionTexture.coordinatesMode _eq_ BABYLON.Texture.SKYBOX_MODE_sm_\n\tskyboxMaterial.diffuseColor _eq_ new BABYLON.Color3(0_co_ 0_co_ 0)_sm_\n\tskyboxMaterial.specularColor _eq_ new BABYLON.Color3(0_co_ 0_co_ 0)_sm_\n\tskybox.material _eq_ skyboxMaterial_sm_\n\tskybox.infiniteDistance _eq_ true_sm_\n\tskybox.isPickable _eq_ true_sm_\n\tskybox.name_eq_ \\_qt_skybox\\_qt__sm_\n\n\tDBObj[skybox.name] _eq_ {\n\t\tID_dd_ \\_qt_999999999\\_qt__co_\n\t\tName_dd_  \\_qt_Skybox\\_qt__co_\n\t\tpx_dd_ \\_qt_0\\_qt__co_\n\t\tpy_dd_ \\_qt_0\\_qt__co_\n\t\tpz_dd_ \\_qt_0\\_qt__co_\n\t\trx_dd_ \\_qt_0\\_qt__co_\n\t\try_dd_ \\_qt_0\\_qt__co_\n\t\trz_dd_ \\_qt_0\\_qt__co_\n\t\tsx_dd_ \\_qt_0\\_qt__co_\n\t\tsy_dd_ \\_qt_0\\_qt__co_\n\t\tsz_dd_ \\_qt_0\\_qt__co_\n\t\twx_dd_ \\_qt_0\\_qt__co_\n\t\twy_dd_ \\_qt_0\\_qt__co_\n\t\twz_dd_ \\_qt_0\\_qt__co_\n\t\tvisible_dd_ \\_qt_1\\_qt__co_\n\t\tinside_dd_ \\_qt_0\\_qt__co_\n\t\tallvisible_dd_ \\_qt_1\\_qt__co_\n\t\tmaxview_dd_ \\_qt_0\\_qt__co_\n\t\tcollision_dd_ \\_qt_0\\_qt_\n\t}_sm__qt__sm_\n\t}\n\n\n\t// build all the water textures and babylon meshes...\n\t$water_count_eq_0_sm_\n\t$water_id_eq_999991000_sm_\n\tunset($water_name)_sm_\n\tlist($res) _eq_ get_query(_qt_SELECT * FROM `water` WHERE `region`_eq__qt_. $region ._qt_ &amp_sm_&amp_sm_ `zone`_eq__qt_. $zone ._qt__sm__qt_)_sm_\n\twhile ($water _eq_ mysql_fetch_array($res))\n\t{\n\t\t$water_name[$water[_t_water_id_t_]] _eq_ $water[_t_name_t_]_sm_\n\t\t$water_count +_eq_ 1_sm_\n\t\t$water_id +_eq_ 1_sm_\n\t\techo _qt_\n\n\n\tvar _qt_. $water[_t_name_t_] ._qt__tex _eq_ new BABYLON.WaterMaterial(\\_qt_water_material_qt_. $water_count ._qt_\\_qt__co_ scene)_sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.bumpTexture _eq_ new BABYLON.Texture(\\_qt_Include/Textures/Bawssump/_qt_. $water[_t_bump_t_] ._qt_\\_qt__co_ scene)_sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.bumpHeight _eq_ 0.1_sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.windForce _eq_ _qt_. $water[_t_wind_force_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.windDirection _eq_ new BABYLON.Vector2(_qt_. $water[_t_wind_dir1_t_] ._qt__co_ _qt_. $water[_t_wind_dir2_t_] ._qt_)_sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.waveHeight _eq_ _qt_. $water[_t_wave_height_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.waveLength _eq_ _qt_. $water[_t_wave_length_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.waterColor _eq_ new BABYLON.Color3(_qt_. $water[_t_red_t_] ._qt__co_ _qt_. $water[_t_green_t_] ._qt__co_ _qt_. $water[_t_blue_t_] ._qt_)_sm_\n\t_qt_. $water[_t_name_t_] ._qt__tex.colorBlendFactor _eq_ _qt_. $water[_t_color_blend_t_] ._qt__sm__qt__sm_\n\n\t\tif (!$inside)\n\t\t{\n\t\t\techo _qt_\n\t_qt_. $water[_t_name_t_] ._qt__tex.addToRenderList(skybox)_sm__qt__sm_\n\t\t}\n\n\n\t\tif (!$water[_t_texture_only_t_])\n\t\t{\n\n\t\t\techo _qt_\n\n\tvar _qt_. $water[_t_name_t_] ._qt__mesh _eq_ BABYLON.Mesh.CreateGround(\\_qt_ground\\_qt__co_ _qt_. $water[_t_length_t_] ._qt__co_ _qt_. $water[_t_width_t_] ._qt__co_ _qt_. $water[_t_depth_t_] ._qt__co_ scene)_sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.name _eq_ \\_qt__qt_. $water[_t_name_t_] ._qt_\\_qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.position.y +_eq_ _qt_. $water[_t_x_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.position.y +_eq_ _qt_. $water[_t_y_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.position.y +_eq_ _qt_. $water[_t_z_t_] ._qt__sm_\n// need to add in rotation for the water later...\n\t//_qt_. $water[_t_name_t_] ._qt__mesh.rotation.y _eq_ _qt_. $water[_t_r_t_] ._qt__sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.backFaceCulling _eq_ true_sm_\n\t_qt_. $water[_t_name_t_] ._qt__mesh.material _eq_ _qt_. $water[_t_name_t_] ._qt__tex_sm_\n\n\tDBObj[_qt_. $water[_t_name_t_] ._qt__mesh.name] _eq_ {\n\t\tID_dd_ \\_qt__qt_. $water_id ._qt_\\_qt__co_\n\t\tName_dd_  \\_qt__qt_. $water[_t_name_t_] ._qt_\\_qt__co_\n\t\tpx_dd_ \\_qt_0\\_qt__co_\n\t\tpy_dd_ \\_qt_0\\_qt__co_\n\t\tpz_dd_ \\_qt_0\\_qt__co_\n\t\trx_dd_ \\_qt_0\\_qt__co_\n\t\try_dd_ \\_qt_0\\_qt__co_\n\t\trz_dd_ \\_qt_0\\_qt__co_\n\t\tsx_dd_ \\_qt_0\\_qt__co_\n\t\tsy_dd_ \\_qt_0\\_qt__co_\n\t\tsz_dd_ \\_qt_0\\_qt__co_\n\t\twx_dd_ \\_qt_0\\_qt__co_\n\t\twy_dd_ \\_qt_0\\_qt__co_\n\t\twz_dd_ \\_qt_0\\_qt__co_\n\t\tvisible_dd_ \\_qt_1\\_qt__co_\n\t\tinside_dd_ \\_qt_0\\_qt__co_\n\t\tallvisible_dd_ \\_qt_1\\_qt__co_\n\t\tmaxview_dd_ \\_qt_0\\_qt__co_\n\t\tcollision_dd_ \\_qt_0\\_qt_\n\t}_sm__qt__sm_\n\n\t\t}\n\n\n\t}\n\n\tif ($water_count)\n\t{\n\t\techo _qt_\n\n\n\t\t_qt__sm_\n\t}\n\n\t\n\t//$sub\n\t$count_eq_0_sm_\n\tlist($res) _eq_ get_query(_qt_SELECT * FROM `objects` LEFT JOIN `map_info` ON `objects`.`name`_eq_`map_info`.`name`  WHERE `region`_eq__qt_. $region ._qt_ &amp_sm_&amp_sm_ `zone`_eq__qt_. $zone ._qt_ &amp_sm_&amp_sm_ `disabled`_eq_0 ORDER BY `package`_co_ `objects`.`name`_sm__qt_)_sm_\n\twhile ($objects _eq_ mysql_fetch_array($res))\n\t{\n\t\tif ($last_package!_eq_$objects[_t_package_t_])\n\t\t{\n\t\t\tif ($last_package!_eq__qt__qt_)\n\t\t\t{\n\t\t\t\techo _qt_]_sm__qt__sm_\n\t\t\t\t$count_eq_0_sm_\n\t\t\t}\n\n\t\t\techo _qt_\n\n\n\t// package meshes\n\tvar package__qt_. $objects[_t_package_t_] ._qt_ _eq_ [_qt__sm_\n\t\t}\n\n\t\tif ($last_obj!_eq_$objects[_t_name_t_])\n\t\t{\n\t\t\tif ($count&gt_sm_0)\n\t\t\t{\n\t\t\t\techo _qt__co_ _qt__sm_\n\t\t\t}\n\n\t\t\techo _qt_\\_qt__qt_. $objects[_t_name_t_] ._qt_\\_qt__qt__sm_\n\t\t\t$count++_sm_\n\t\t}\n\n\t\t$last_package _eq_ $objects[_t_package_t_]_sm_\n\t\t$last_obj _eq_ $objects[_t_name_t_]_sm_\n\t}\n\n\n\techo _qt_]_sm__qt__sm_\n\n\n\t$last_package_eq__qt__qt__sm_\n\t$last_obj_eq__qt__qt__sm_\n\tmysql_data_seek($res_co_ 0)_sm_\n\twhile ($objects _eq_ mysql_fetch_array($res))\n\t{\n\t\tif ($last_package!_eq_$objects[_t_package_t_])\n\t\t{\n\t\t\tif ($last_package!_eq__qt__qt_)\n\t\t\t{\n\t\t\t\techo _qt_\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t)_sm_\n\n\n\n_qt__sm_\n\t\t\t}\n\n\t\t\techo _qt_\n\n\n\tBABYLON.SceneLoader.ImportMesh(package__qt_. $objects[_t_package_t_] ._qt__co_ \\_qt__qt_. $home_path . $objects[_t_dir_t_] . $file_type ._qt_/_qt_. $objects[_t_package_t_] ._qt_/\\_qt__co_ \\_qt__qt_. $objects[_t_package_t_] ._qt_.babylon\\_qt__co_ scene_co_ \n\t\tfunction(mapZone_co_ particleSystems_co_ skeletons)\n\t\t{\n\t\t\tfor (var i_eq_0_sm_ i&lt_sm_mapZone.length_sm_ i++)\n\t\t\t{\n_qt__sm_\n\t\t}\n\n\n\t\tif ($last_obj!_eq_$objects[_t_name_t_])\n\t\t{\n\n\t\t\tif ($last_obj!_eq__qt__qt_ &amp_sm_&amp_sm_ $last_package_eq__eq_$objects[_t_package_t_])\n\t\t\t{\n\t\t\t\techo _qt_\n\t\t\t\t}_qt__sm_\n\t\t\t}\n\n\t\t\techo _qt_\n\n\t\t\t\tif (mapZone[i].name _eq__eq_ \\_qt__qt_. $objects[_t_name_t_] ._qt_\\_qt_)\n\t\t\t\t{\n\t\t\t\t\t////////////////////////////////////////////////////////\n\t\t\t\t\t// Parent Mesh\n\t\t\t\t\t// Due to issues when hiding the parent mesh_co_ making the \n\t\t\t\t\t// parent it_t_s own thing and dropped below where it\n\t\t\t\t\t// would ever be viewed.\n\t\t\t\t\t////////////////////////////////////////////////////////\n\n\t\t\t\t\tmapZone[i].visiblity_eq_true_sm_\n\t\t\t\t\tmapZone[i].isVisible_eq_true_sm_\n\t\t\t\t\tmapZone[i].name _eq_ \\_qt__qt_. $objects[_t_name_t_] ._qt_\\_qt__sm_\n\t\t\t\t\tmapZone[i].position _eq_ new BABYLON.Vector3(0_co_ -100000_co_ 0)_sm_\n\t\t\t\t\tmapZone[i].scaling _eq_ new BABYLON.Vector3(_qt_. $objects[_t_sx_t_] ._qt__co_ _qt_. $objects[_t_sy_t_] ._qt__co_ _qt_. $objects[_t_sz_t_] ._qt_)_sm_\n\t\t\t\t\tmapZone[i].rotationQuaternion _eq_ null_sm_\n\t\t\t\t\tmapZone[i].rotation _eq_ new BABYLON.Vector3(_qt_. $objects[_t_rx_t_] ._qt__co_ _qt_. $objects[_t_ry_t_] ._qt__co_ _qt_. $objects[_t_rz_t_] ._qt_)_sm_\n\t\t\t\t\tmapZone[i].backFaceCulling _eq_ false_sm_\n\t\t\t\t\tmapZone[i].isPickable _eq_ true_sm_\n\n\n\t\t\t\t\t////////////////////////////////////////////////////////\n\t\t\t\t\t// Instance Copies\n\t\t\t\t\t// Making every model an instance. Increases the verts_co_ \n\t\t\t\t\t// but there are issue with hiding the parent models.\n\t\t\t\t\t////////////////////////////////////////////////////////\n\n\t\t\t\t\titem_used_eq_1_sm_\n\t\t\t\t\tvar _qt_. $objects[_t_name_t_] ._qt__inst _eq_ 0_sm__qt__sm_\n\t\t}\n\n\t\techo _qt_\n\n\t\t\t\t\t_qt_. $objects[_t_name_t_] ._qt__inst++_sm_\n\t\t\t\t\tobjInstance _eq_ mapZone[i].createInstance(\\_qt__qt_. $objects[_t_name_t_] ._qt__inst_\\_qt_+ _qt_. $objects[_t_name_t_] ._qt__inst +\\_qt_\\_qt_)_sm_\n\t\t\t\t\tobjInstance.visiblity _eq_ true_sm__qt__sm_\n\n\t\tif ($objects[_t_always_visible_t_])\n\t\t{\n\t\t\techo _qt_\n\t\t\t\t\tobjInstance.isVisible_eq_true_sm__qt__sm_\n\t\t}\n\t\telse\n\t\t{\n\t\t\techo _qt_\n\t\t\t\t\tobjInstance.isVisible_eq_false_sm__qt__sm_\n\t\t}\n\n\t\techo _qt_\n\t\t\t\t\tobjInstance.position _eq_ new BABYLON.Vector3(_qt_. $objects[_t_px_t_] ._qt__co_ _qt_. $objects[_t_py_t_] ._qt__co_ _qt_. $objects[_t_pz_t_] ._qt_)_sm_\n\t\t\t\t\tobjInstance.scaling _eq_ new BABYLON.Vector3(_qt_. $objects[_t_sx_t_] ._qt__co_ _qt_. $objects[_t_sy_t_] ._qt__co_ _qt_. $objects[_t_sz_t_] ._qt_)_sm_\n\t\t\t\t\tobjInstance.rotationQuaternion _eq_ null_sm_\n\t\t\t\t\tobjInstance.rotation _eq_ new BABYLON.Vector3(_qt_. $objects[_t_rx_t_] ._qt__co_ _qt_. $objects[_t_ry_t_] ._qt__co_ _qt_. $objects[_t_rz_t_] ._qt_)_sm_\n\t\t\t\t\tobjInstance.backFaceCulling _eq_ false_sm_\n\t\t\t\t\tobjInstance.isPickable _eq_ true_sm_\n\t\t\t\t\tobjInstance.freezeMatrix()_sm_\n\t\t\t\t\tobjInstance.freezeMaterials()_sm_\n\t\t\t\t\tDBObj[objInstance.name] _eq_ {\n\t\t\t\t\t\tID_dd_ _qt_. $objects[_t_object_id_t_] ._qt__co_\n\t\t\t\t\t\tName_dd_  \\_qt__qt_. $objects[_t_name_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tpx_dd_ \\_qt__qt_. $objects[_t_px_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tpy_dd_ \\_qt__qt_. $objects[_t_py_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tpz_dd_ \\_qt__qt_. $objects[_t_pz_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\trx_dd_ \\_qt__qt_. $objects[_t_rx_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\try_dd_ \\_qt__qt_. $objects[_t_ry_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\trz_dd_ \\_qt__qt_. $objects[_t_rz_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tsx_dd_ \\_qt__qt_. $objects[_t_sx_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tsy_dd_ \\_qt__qt_. $objects[_t_sy_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tsz_dd_ \\_qt__qt_. $objects[_t_sz_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\twx_dd_ \\_qt__qt_. $objects[_t_wx_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\twy_dd_ \\_qt__qt_. $objects[_t_wy_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\twz_dd_ \\_qt__qt_. $objects[_t_wz_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tvisible_dd_ \\_qt__qt_. $objects[_t_visible_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tinside_dd_ \\_qt__qt_. $objects[_t_inside_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tallvisible_dd_ \\_qt__qt_. $objects[_t_always_visible_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tmaxview_dd_ \\_qt__qt_. $objects[_t_max_distance_t_] ._qt_\\_qt__co_\n\t\t\t\t\t\tcollision_dd_ \\_qt__qt_. $objects[_t_collision_t_] ._qt_\\_qt__qt__sm_\n\n\n\t\t\tfor ($FR_eq_1_sm_ $FR&lt_sm__eq_sizeof($region_info)_sm_ $FR++)\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\t($region_info[$FR][_t_min_x_t_]&lt_sm__eq_$objects[_t_wx_t_] &amp_sm_&amp_sm_ $region_info[$FR][_t_max_x_t_]&gt_sm__eq_$objects[_t_wx_t_])\n\t\t\t\t\t&amp_sm_&amp_sm_ ($region_info[$FR][_t_min_y_t_]&lt_sm__eq_$objects[_t_wy_t_] &amp_sm_&amp_sm_ $region_info[$FR][_t_max_y_t_]&gt_sm__eq_$objects[_t_wy_t_])\n\t\t\t\t\t&amp_sm_&amp_sm_ ($region_info[$FR][_t_min_z_t_]&lt_sm__eq_$objects[_t_wz_t_] &amp_sm_&amp_sm_ $region_info[$FR][_t_max_z_t_]&gt_sm__eq_$objects[_t_wz_t_])\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\techo _qt__co_\n\t\t\t\t\t\tregion_dd_ _qt_. $FR ._qt__qt__sm_\n\t\t\t\t\tbreak_sm_\n\t\t\t\t}\n\t\t\t}\n\n\t\t\techo _qt_\n\t\t\t\t\t}_sm_\n\t\t\t\t\tBABYLON.Tags.AddTagsTo(objInstance_co_ \\_qt_region\\_qt_+ _qt_. $FR ._qt_ +\\_qt_\\_qt_)_sm__qt__sm_\n\n\n\t\t// any mesh that is water needs the material added\n\t\tif ($objects[_t_water_t_])\n\t\t{\n\t\t\techo _qt_\n\t\t\t\t\tobjInstance.material _eq_ null_sm_\n\t\t\t\t\tobjInstance.material _eq_ _qt_. $water_name[$objects[_t_water_t_]] ._qt__tex_sm__qt__sm_\n\t\t}\n\n\t\t// add water reflection / refractions\n\t\tlist($w_res) _eq_ get_query(_qt_SELECT `water`.`name` FROM `map_info_reflect` LEFT JOIN `water` ON `map_info_reflect`.`water_id` _eq_ `water`.`water_id` WHERE `map_info_reflect`.`object_id`_eq__qt_. $objects[_t_object_id_t_] ._qt__qt_)_sm_\n\t\twhile ($reflect _eq_ mysql_fetch_array($w_res))\n\t\t{\n\t\t\techo _qt_\n\t\t\t\t\t_qt_. $reflect[_t_name_t_] ._qt__tex.addToRenderList(objInstance)_sm__qt__sm_\n\t\t}\n\n\t\t$last_package_eq_$objects[_t_package_t_]_sm_\n\t\t$last_obj_eq_$objects[_t_name_t_]_sm_\n\t}\n\n\n\techo _qt_\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t)_sm_\n}_qt__sm_\n\n?&gt_sm_ _lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-29T11:57:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThinking back to your huge amount of meshes ...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI notice that you said you froze the mesh World matrices. This implies your mesh won_t_t move in the scene_co_ right ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWell_co_ if your meshes are positioned at their final location forever_co_ you could pre-compute (before entering the render loop) some areas to sort you meshes in (kind of octree or_co_ better said_co_ a space partitioning with blocks). Then according to the camera position_co_ you can decide to de/activate the meshes in the distant partition sections.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis is a bit similar to what reddozen just proposed.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe partitioning from the feature _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_facetdata_qt_ rel_eq__qt_external nofollow_qt__gt_FacetData_lt_/a_gt_ works this way. It_t_s quite light_co_ easy to implement with a single flat array_co_ easy to set and fast to access then _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2335_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2335_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-06-29T13:13:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany many thanks to everybody for your answers.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis portal is wonderful.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYes my CAD is static_co_ no animations at all.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI will have a look to your answers and come back yo you in short.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWould it be possible for you to put ans example in PG?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnd again_co_ many many thanks.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBest regards\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"reddozen","Date":"2017-06-30T14:21:18Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_180085_qt_ data-ipsquote-contentid_eq__qt_31040_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1498737421_qt_ data-ipsquote-userid_eq__qt_5453_qt_ data-ipsquote-username_eq__qt_jerome_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tOn 6/29/2017 at 6_dd_57 AM_co_ jerome said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tThis is a bit similar to what reddozen just proposed.\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\tThe partitioning from the feature _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_facetdata_qt_ rel_eq__qt_external nofollow_qt__gt_FacetData_lt_/a_gt_ works this way. It_t_s quite light_co_ easy to implement with a single flat array_co_ easy to set and fast to access then _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2335_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.vertexData.ts#L2335_lt_/a_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI_t_ll have to look at that... may be able to simplify mine some.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tua4192_co__lt_br /_gt_\n\tI forgot to mention that mine uses the _qt_tags_qt_ feature to group objects in their regions. But you can see that from looking at it. That simplified my organized lists by letting Babylon keep up with it instead of me. Not sure if that_t_s more or less process heavy_co_ but it works well.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"MackeyK24","Date":"2018-01-24T22:39:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYo _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ or _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/10310-raananw/?do_eq_hovercard_qt_ data-mentionid_eq__qt_10310_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/10310-raananw/_qt_ rel_eq__qt__qt__gt_@RaananW_lt_/a_gt_ ...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo does this mean the Babylonjs DOES support occlusion culling... I dont hav to do anything right... if the mesh is NOT part of the VIEW frustum BJS will automatically cull that mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo if I have a terrain ground mesh that is a grid of 3 x 3 sections (I am still trying to effectively split a large terrain mesh into smaller chunks) if I am facing forward in the middle top section (say grid sort 0_co_ 2... the second square at top) then the rest of the meshes in the grid behind my camera view SHOULD not rendered... That is occlusion culling... Right ???\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]