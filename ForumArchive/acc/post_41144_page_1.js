[{"Owner":"entropy","Date":"2018-11-09T04:46:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI have a project where I have a collection of solid particles that I need to test if they intersect. I have a simplified demo of the project here_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//playground.babylonjs.com/#C7K3Q1_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//playground.babylonjs.com/#C7K3Q1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe particles themselves will have a box shape (as in the example) and I need to know if they physically overlap. According to the documentation for SPS_co_ \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_particle.intersectsMesh﻿(otherParticle﻿﻿) _lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tuses less precise metrics to establish whether meshes intersect. Indeed_co_ in the above playground_co_ a collision is registered (red color) even if the actual meshes do not overlap.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo I found the following line in babylon.solidParticle.ts located at _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticle.ts#L173_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticle.ts#L173_lt_/a_gt__dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_return this._boundingInfo.intersects(target._boundingInfo_co_ false)_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tIn my local version of the script_co_ I tried changing the _qt_false_qt_ to _qt_true_qt_ to force the more precise collision detection_co_ but that seems to have no effect (I can_t_t demo that in the playground_co_ obviously). Is there a way to force the more precise calculation (even if it_t_s on my local copy of babylon.js)? Or_co_ perhaps there_t_s some better way of achieving this?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tP.S. I realize this is an expensive CPU operation_co_ but I only need to test for collisions once since the particles are stationary.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-11-09T08:04:03Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tYou did exactly what should be expected when dealing with a mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSolid particles actually aren_t_t real meshes because they don_t_t have each a world matrix for memory and performance reasons. When you want to check precise collisions between two meshes (so when you set the parameter _lt_em_gt_precise_lt_/em_gt_ to _lt_em_gt_true_lt_/em_gt_)_co_ each mesh bounding box is updated according to its world matrix in order to compute the Bbox rotated axes in the world. This can_t_t be achieved for solid particles not having a world matrix.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you still want to do this_co_ you_t_ll have to _lt_span_gt__dd__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- get the stored rotation matrix of each particle (note _dd_ it_t_s a dedicated light implementation_co_ not a real BJS matrix object_co_ just a 9 float array) _lt_span_gt__dd_ _lt_/span_gt__lt_/span_gt__lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticle.ts#L96_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticle.ts#L96_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- rotate manually the Bbox directions according to this matrix_co_ a bit like you would update the Bbox according to some mesh world matrix. Once this done_co_ you may consider the particle Bbox is updated according to the particle rotation_co_ so the _lt_em_gt_direction_lt_/em_gt_ values are now right _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Culling/babylon.boundingInfo.ts#L233_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Culling/babylon.boundingInfo.ts#L233_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- then apply the precision intersection test\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis should work. But it_t_s quite a big work to do. Maybe could you consider another simpler approach _lt_span_gt__dd__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- create some nodeTransform objects in order to just compute some maths on them_co_ one per particle to be checked. Apply each one the same rotation than its matching particle. Update its world matrix and its Bbox_lt_/span_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//doc.babylonjs.com/how_to/transformnode_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//doc.babylonjs.com/how_to/transformnode_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- then check precise intersections directly on these nodeTransform Bboxes and apply your wanted behavior to the related particles. In this case_co_ no need for particle intersections within the SPS_co_ the collisions are computed apart in a dedicated logic on pure math objects_co_ a bit like a physics engine works actually.  _lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_An even simpler approach is to use a real physics engine and to associate each particle to an impostor. This works also quite well._lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"entropy","Date":"2018-11-09T17:36:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThose are some excellent suggestions. I didn_t_t even consider the physics engine approach! I_t_m slowly but surely learning...\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"entropy","Date":"2018-11-09T22:19:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5453_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/_qt_ rel_eq__qt__qt__gt_@jerome_lt_/a_gt_ One (hopefully quick) question. I think the transform node method is the most promising_co_ but I can_t_t seem to associate a bounding box to a node. E.g._co_ look at lines 33 and following_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//playground.babylonjs.com/#FL6VBL%231_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//playground.babylonjs.com/#FL6VBL#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCould you elaborate a bit how to make that association?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-11-10T07:05:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI can_t_t remember if the transfomNode holds a Bbox or not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf not _lt_span_gt__dd__lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- create a transformNode_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- create an independant BoundingInfo objects besides_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span_gt_- each time you rotate the transformNode_co_ get its updated world martix_co_ then update the BoundingInfo by passing it the transformNode world matrix. This will update the Bbox directions._lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"entropy","Date":"2018-11-11T02:03:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/?do_eq_hovercard_qt_ data-mentionid_eq__qt_5453_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/5453-jerome/_qt_ rel_eq__qt__qt__gt_@jerome_lt_/a_gt_ Here_t_s the solution that I employed. Instead of using transformNode_co_ I just used BoundingInfo and directly set its world matrix. Fortunately_co_ the Matrix class has all the functionality needed to generate the necessary information. Here_t_s the PG_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//playground.babylonjs.com/#C7K3Q1%231_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//playground.babylonjs.com/#C7K3Q1#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLines 60 through 62 contain the relevant new code. Everything works great...thanks for the help!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-11-11T05:55:18Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tglad to hear this\n_lt_/p_gt_\n\n_lt_p_gt_\n\tmy transformNode suggestion was just to avoid you to compute the matrix by your own_co_ but I can see that this is something you_t_re conformtable with _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]