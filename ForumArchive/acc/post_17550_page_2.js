[{"Owner":"fenomas","Date":"2015-10-04T16:43:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The main point is to pass a fixed value to _lt_span style_eq__qt_font-family_dd__t_courier new_t__co_ courier_co_ monospace_sm__qt__gt_tick()_lt_/span_gt__co_ rather than the _qt_actual_qt_ time between ticks. How you drive the function shouldn_t_t make a big difference. I think the library I_t_m using actually uses both an interval and a RAF loop_co_ but I haven_t_t looked closely._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_At a guess_co_ I_t_d imagine if you use a plain setInterval the actual tick rate be somewhat slower over the long run_co_ and vary a little by browser._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-10-04T17:19:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Actually_co_ your implementation is quite elegant because there is only one callback_co_ assuming the render treatment is light and always faster than the logic/tick part._lt_/p_gt__lt_p_gt_So one loop only embedding the render and the logic but running each at its own frequency._lt_/p_gt__lt_p_gt_Each relative code is decoupled from each other_co_ nice !  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_However I don_t_t know if a mechanism with two separated callbacks/loops (render/RAF and logic/Interval) is better (in terms of what ?) althought I think both have quite a similar performance._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I like yours  _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ alt_eq__qt__sm_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2015-10-05T04:21:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Note well that in both methods (Fenomas single callback or separates setInterval callback) we set a fixed delay so the logic engine (ie physics) may evolve at its own clocking different from the render clocking... say here 40 ms vs 16 ms_lt_/p_gt__lt_p_gt_But_co_ because of JS monothreaded process_co_ we know that only one function is run at a given moment._lt_/p_gt__lt_p_gt_So if the logical engine treatment lasts almost 40 ms_co_ the render engine will have to wait to display the next frame_co_ it is to say that every 40 ms_co_ at least two 16 ms frames won_t_t be displayed. Not that important ..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This just gave me an idea to slice an hypothecal long during logical engine (staying in the single process world_co_ so without web worker here although I truly think they are a good lead). We could imagine to keep on calling the logical engine at a fixed frequency but to get its final result only after it has really finished its computations._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Not clear ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Imagine the particle system (or the SPS) as our logical engine and the _lt_em_gt_registerBeforeRender_lt_/em_gt_ function as the Fenomas _lt_em_gt_RAF_lt_/em_gt_ function depicted in his former post. Ok ?_lt_/p_gt__lt_p_gt_If now we try to manage_co_ say_co_ 10 millions particles_co_ what will happen ? (I know we can_t_t build a mesh with 10M vertices_co_ it_t_s just for the example)._lt_/p_gt__lt_p_gt_Each 40 ms the _lt_em_gt_updateParticles_lt_/em_gt_ loop will start to iterate from 1 to 10 millions to compute each particle new status and coordinates. This may last some time_co_ nope ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_So imagine that_co_ instead of iterating on 10 millions particles_co_ it is called more often but it is said to only compute about 10K new particles each call_co_ and finally only  to update the newly computed mesh to render. Wouldn_t_t it be better ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_ll try to implement a PG example with the SPS_co_ what has a lower performance limit than the BJS PS_co_ so it will be more understandable_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]