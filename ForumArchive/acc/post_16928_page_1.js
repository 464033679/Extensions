[{"Owner":"Hagop","Date":"2015-09-03T22:43:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_ok_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I am trying to create a loop using javascript _lt_em_gt__lt_strong_gt_for function _lt_/strong_gt__lt_/em_gt_in order to import the same mesh multiple times but with different XYZ coordinates._lt_/p_gt__lt_p_gt_The outcome of my code below shows only one instance of the mesh._lt_/p_gt__lt_p_gt_What am i doing wrong ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Here is the code_dd_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_&lt_sm_body&gt_sm__lt_br_gt_    &lt_sm_canvas id_eq__qt_renderCanvas_qt_&gt_sm_&lt_sm_/canvas&gt_sm__lt_br_gt_    &lt_sm_script&gt_sm__lt_br_gt_        window.addEventListener(_t_DOMContentLoaded_t__co_ function(){_lt_br_gt_            // get the canvas DOM element_lt_br_gt_            var canvas _eq_ document.getElementById(_t_renderCanvas_t_)_sm__lt_br_gt__lt_br_gt_            // load the 3D engine_lt_br_gt_            var engine _eq_ new BABYLON.Engine(canvas_co_ true)_sm__lt_br_gt__lt_br_gt_            var createScene _eq_ function () {_lt_br_gt_                    var scene _eq_ new BABYLON.Scene(engine)_sm__lt_br_gt_                _lt_br_gt_                    //Adding a light_lt_br_gt_                    var light _eq_ new BABYLON.PointLight(_qt_Omni_qt__co_ new BABYLON.Vector3(20_co_ 20_co_ 100)_co_ scene)_sm__lt_br_gt_                _lt_br_gt_                    //Adding an Arc Rotate Camera_lt_br_gt_                    var camera _eq_ new BABYLON.ArcRotateCamera(_qt_Camera_qt__co_ 0_co_ 0.8_co_ 100_co_ BABYLON.Vector3.Zero()_co_ scene)_sm__lt_br_gt_                    camera.attachControl(canvas_co_ false)_sm__lt_br_gt_                _lt_br_gt_                  for (i_eq_0_sm_ i&lt_sm_5_sm_ i++)_lt_br_gt_                    {_lt_br_gt_                    BABYLON.SceneLoader.ImportMesh(_qt__qt__co_ _qt__qt__co_ _qt_pantene_low.babylon_qt__co_ scene_co_ function (newMeshes) {_lt_br_gt_                        // Set the target of the camera to the first imported mesh_lt_br_gt_                        if(i_eq__eq_4)_lt_br_gt_                        {_lt_br_gt_                        camera.target _eq_ newMeshes[0]_sm__lt_br_gt_                        }_lt_br_gt_                        newMeshes[0].position.x _eq_ i+10_sm__lt_br_gt_                        })_sm__lt_br_gt_                    _lt_br_gt_                    }_lt_br_gt_                    // Move the light with the camera_lt_br_gt_                    scene.registerBeforeRender(function () {_lt_br_gt_                        _lt_br_gt_                        light.position _eq_ camera.position_sm__lt_br_gt_                    })_sm__lt_br_gt_                _lt_br_gt_                _lt_br_gt_                _lt_br_gt_                    return scene_sm__lt_br_gt_                }_lt_br_gt__lt_br_gt_            // call the createScene function_lt_br_gt_            var scene _eq_ createScene()_sm__lt_br_gt__lt_br_gt_            // run the render loop_lt_br_gt_            engine.runRenderLoop(function(){_lt_br_gt_                scene.render()_sm__lt_br_gt_            })_sm__lt_br_gt__lt_br_gt_            // the canvas/window resize event handler_lt_br_gt_            window.addEventListener(_t_resize_t__co_ function(){_lt_br_gt_                engine.resize()_sm__lt_br_gt_            })_sm__lt_br_gt_        })_sm__lt_br_gt_    &lt_sm_/script&gt_sm__lt_br_gt_&lt_sm_/body&gt_sm__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2015-09-03T23:08:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_My guess is that it could be a scope issue.  Add console.log(i)_sm_  after newMeshes[0].position.x _eq_ i+10_sm_ to see what the value of i is._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Or maybe the other meshes are completely out of view._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ChrisR","Date":"2015-09-04T04:03:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The problem is that the variable i has already incremented to 5 before each of the models has completed loading. Then when the models load they using i_eq_5.. add a counter outside that only gets updated when the mesh is loaded and has used the counter_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_             var GlobalCounter _eq_ 0_sm_             for (i_eq_0_sm_ i&lt_sm_5_sm_ i++)                    {                    BABYLON.SceneLoader.ImportMesh(_qt__qt__co_ _qt__qt__co_ _qt_pantene_low.babylon_qt__co_ scene_co_ function (newMeshes) {                        // Set the target of the camera to the first imported mesh                        if(GlobalCounter _eq__eq_4)                        {                            camera.target _eq_ newMeshes[0]_sm_                        }                        newMeshes[0].position.x _eq_ GlobalCounter +10_sm_                        })_sm_                       GlobalCounter ++_sm_                    }_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Temechon","Date":"2015-09-04T06:21:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello_co_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Can I ask why you want to import the same mesh several times ? You can only import it once_co_ and clone it wherever you want. _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Hagop","Date":"2015-09-04T07:55:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Temechon_lt_/p_gt__lt_p_gt_The reason I am importing the same mesh several times_co_ is that I want to test the memory limit of the _qt_system_qt_ on low internet connections and low ram (ie_dd_ 2GB RAM). The reason being we want to create a virtual 3D store with thousands of products (www.ardzan.com)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Anyhow_co_ how does cloning work? should I assume that cloning a products several times would use less GPU memory than loading the the mesh the same number of times?_lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Temechon","Date":"2015-09-04T08:11:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Indeed_co_ cloning will use less GPU memory than loading several times the same model_co_ and it won_t_t use the bandwidth (as you don_t_t have to load it another time)._lt_/p_gt__lt_p_gt_You win in total number of draw call (better performance) and in memory_dd_ it_t_s a win-win!_lt_/p_gt__lt_p_gt_In order to use clone_co_ you can do something like this_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#GK7FK%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#GK7FK#2_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I challenge you to do faster by loading 10 times the same model _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"reddozen","Date":"2015-09-06T15:21:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_And instances will use even less than cloning._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Hagop","Date":"2015-09-07T07:29:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Reddozen &amp_sm_ Temechon_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Than you for your feedback.Since I will be loading thousands of products into the scene each with unique texture and mesh_co_ _lt_strong_gt_cloning _lt_/strong_gt_and _lt_strong_gt_instances _lt_/strong_gt_is not helpful for my scenario_co_ right?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Hagop","Date":"2015-09-07T07:32:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_ChrisR_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Same problem with _lt_span_gt_GlobalCounter_lt_/span_gt__lt_span_gt_ _lt_/span_gt__lt_span_gt_++_sm_  It increases before the meshes are loaded._lt_/span_gt__lt_/p_gt__lt_p_gt__lt_span_gt_This is how I solved the problem_lt_/span_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span_gt_ var createScene _eq_ function () {_lt_br_gt_                    var scene _eq_ new BABYLON.Scene(engine)_sm__lt_br_gt_                 _lt_br_gt_                    //Adding a light_lt_br_gt_                    var light _eq_ new BABYLON.PointLight(_qt_Omni_qt__co_ new BABYLON.Vector3(20_co_ 20_co_ 100)_co_ scene)_sm__lt_br_gt_                _lt_br_gt_                    //Adding an Arc Rotate Camera_lt_br_gt_                    var camera _eq_ new BABYLON.ArcRotateCamera(_qt_Camera_qt__co_ 0_co_ 0.8_co_ 100_co_ BABYLON.Vector3.Zero()_co_ scene)_sm__lt_br_gt_                    camera.attachControl(canvas_co_ false)_sm__lt_br_gt_                _lt_br_gt_                    var loadMeshes _eq_ function(x) {_lt_br_gt_                    _lt_br_gt_                    BABYLON.SceneLoader.ImportMesh(_qt__qt__co_ _qt_scenes/_qt__co_ _qt_pantene_low.babylon_qt__co_ scene_co_ function (newMeshes) {_lt_br_gt_                            // Set the target of the camera to the first imported mesh_lt_br_gt_                            //camera.target _eq_ newMeshes[0]_sm__lt_br_gt_                            //alert(_qt_i _qt_ +i)_sm__lt_br_gt_                            newMeshes[0].position _eq_ new BABYLON.Vector3(x_co_ 0_co_ 0)_sm_ })_sm__lt_br_gt_                    }_lt_br_gt_                _lt_br_gt_                    for (i_eq_1_sm_i&lt_sm_4_sm_i++)_lt_br_gt_                    {_lt_br_gt_                    var x _eq_ i*10_sm__lt_br_gt_                    var loadedMeshes _eq_ loadMeshes(x)_sm__lt_br_gt_                    }_lt_br_gt_                                   _lt_br_gt_                    _lt_br_gt_                 _lt_br_gt_                    // Move the light with the camera_lt_br_gt_                    scene.registerBeforeRender(function () {_lt_br_gt_                        _lt_br_gt_                        light.position _eq_ camera.position_sm__lt_br_gt_                    })_sm__lt_br_gt_                _lt_br_gt_                _lt_br_gt_                _lt_br_gt_                    return scene_sm__lt_br_gt_                }//end createScene_lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]