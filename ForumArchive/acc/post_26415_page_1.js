[{"Owner":"AussieKSU","Date":"2016-11-16T00:47:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI have observed that sub meshes can solve many issues for dynamically changing materials for parts of meshes. _qt_Dynamic_qt_ changing of materials is meant to mean changing the material of parts of the scene content on demand while the application is running._lt_br /_gt__lt_br /_gt_\n\tIt is understood by me that in order to increase general performance of the BABYLON engine_co_ one should reduce the total number of meshes in the scene. This has certainly been an observed truth in my implementation of BABYLON for our application. We see that this truth_co_ however can become problematic when several large meshes exist_co_ and then many sub meshes are created for assigning materials to parts of the mesh. As I understand from forum research_co_ empirical analysis_co_ and reviewing BABYLON source code_co_ the number of sub meshes is directly linked to the number GL draw calls. If the scene is organized with several large meshes_co_ you will still see inferior FPS performance if many sub meshes are added to each mesh. This is true_co_ even if many of the sub meshes reference a small number of materials. _lt_br /_gt__lt_br /_gt_\n\tTo visualize this problem_co_ I will use the example of a large horse (metaphorically) being the entire contents of the scene. In this case_co_ we will have a single mesh_co_ containing all the vertices to draw this horse. Dynamically_co_ we wish to change this horse to a zebra - where the vertices are identical to the horse_co_ but instead we add black and white stripes to the horse. I have explored two options to accomplish this _qt_zebra-fication_qt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\t1) (Non-submesh solution) Manipulating the index and vertex arrays themselves_co_ it is possible to _qt_pull_qt_ apart all the white parts of the zebra into a single mesh_co_ and all the black parts of the zebra into a separate mesh. This performs wonderfully from a FPS perspective_co_ but is not wonderful for the array manipulation itself. This is also NOT using the concept of sub meshes whatsoever. The problem_co_ once again with this solution is not the render performance_co_ but the operation of creating the two meshes. It can also be considered that once indexes are manipulated_co_ we could retain the use of a single mesh_co_ and since the indexes are reorganized and are concurrent with respect to their materials_co_ we could also use 2 submeshes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t2) (Submesh solution) An elegant solution in terms of performance of the _qt_zebra-fication_qt_ is to cut up the horse mesh into white and black stripes with sub meshes. The performance of creating these sub meshes is very good - as expected. The problem with this solution_co_ as I introduced in the beginning paragraph_co_ is that for each _qt_stripe/submesh_qt_ we see a separate GL draw call. _lt_br /_gt__lt_br /_gt_\n\tMy post is intended to firstly inquire if there is a way to bridge the gap between the low cost for the zebra-fication with submeshes while also keeping GL draw calls low and therefore FPS high. As I understand it_co_ I cannot currently have my cake and eat it too._lt_br /_gt__lt_br /_gt_\n\tMy post is also intended to inquire about a possible enhancement to the BABYLON engine_co_ which I am more than happy to code_co_ test_co_ and post to the BABYLON source. This would be an optional structure to pass multiple sub meshes to the rendering manager_co_ where these sub meshes share the same material index. It should also be noted that these sub meshes do not need to have consecutive start/end indexes. Therefore_co_ one could still enjoy the excellent sub mesh performance while _qt_zebrafying_qt__co_ and also enjoy great FPS performance. I am more than happy to discuss design details with this enhancement if this enhancement would be allowed to the source code._lt_br /_gt__lt_br /_gt_\n\tIt may also be possible to enhance the submesh class so that non sequential ranges of indexes could be added. This may be an easier and more elegant solution. With this solution_co_ one could create two submeshes (one white_co_ one black)_co_ and specify the various index ranges for each white and black stripe respectively.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThank you for your time\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-11-16T08:42:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHave you explored the SPS what can be handled as mesh subpart API _dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/overviews/Solid_Particle_System_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/overviews/Solid_Particle_System_lt_/a_gt_ ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWith the SPS_co_ you_t_re not obliged to consider the particles as animated particles... you can simply consider them as subparts of a mesh if you just want to set their UV_co_ colors_co_ scalings or rotations\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-11-16T18:53:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co_ _lt_br /_gt__lt_br /_gt_\n\tThank you very much for the suggestion. I had not considered SPS. My hour or so of research into the code leads me to come to a few worries/comments_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPlease note_co_ my brief research into SPS certainly makes me no expert. Please correct my worries/comments if you think they are not accurate.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_br /_gt_\n\t1) SPS seems to be a management structure around a collection of meshes. In the end_co_ the meshes that have been added to the scene that are part of the SPS are still rendered via the RenderManager_co_ and will therefore experience the same performance problems in my OP. SPS seems to be a handy structure for collecting meshes in a system_co_ and acting upon these meshes - I just fear that the performance will not change_co_ or will be worse because of point 2._lt_br /_gt_\n\t2) SPS does not like to use merged meshes? As far as I understand my cursory review of the code_co_ things might go awry if we consolidate the meshes in the SPS via BABYLON.Mesh.MergeMeshes(...). This comment may not be entirely accurate_co_ but nevertheless_co_ this is certainly weighed into my final complaint below._lt_br /_gt_\n\t3) My last complaint about SPS is not meant to be a sound argument to dissuade the usage of SPS for other BABYLON developers_co_ but it is still a point that many of us devs must take to heart. Our application is rather mature_co_ complete with some cool performance tweaks for loading scenes on web workers from JSON data provided by services_co_ special picking logic_co_ etc_co_ etc. I would very much rather not touch this code_co_ even if the ripple effect of changes is _qt_theoretically_qt_ small. Therefore_co_ due to the maturity of our application_co_ I am very hesitant to switch to something dramatically different - SPS - in order to solve my problem. _lt_br /_gt__lt_br /_gt_\n\tEdit _dd_ _lt_br /_gt__lt_br /_gt_\n\t1) Jerome has pointed out through demos that this is not true. SPS uses a single draw call for the mesh_co_ and does not use multiple materials_co_ but instead uses color buffers. Performance is very good_co_ regardless of number of colors._lt_br /_gt_\n\t2) Incorrect. SPS could very well use a merged mesh.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-11-16T19:18:13Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDraw calls with non-sequential ranges may not be possible. Looking at how the WebGLRenderContext works_co_ it seems it only supports drawing consecutive indeces.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tdrawElements(mode_dd_ number_co_ count_dd_ number_co_ type_dd_ number_co_ offset_dd_ number)_dd_ void_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI think my proposed solution may be infeasible. I could not draw multiple parts of the bound gemetry with a single draw call _dd_(._lt_br /_gt_\n\tI don_t_t know if this invalidates my proposed solution entirely. We could still reduce the need to (re)bind the geometry buffers for each sub mesh. Not sure what this would mean for render performance. This would require more analysis before I could definitely comment. Intuitively_co_ it seems that the overhead is in the draw call_co_ since sub meshes after all_co_ do a single bind and I have already mentioned the degradation of FPS when many of these are used.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tEdit _dd_ Binding the vertex context is not a performance issue. Even so_co_ there is only one bind for the mesh as it stands today_co_ regardless how many sub meshes it contains.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-11-16T19:26:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWell_co_ to shorten _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe SPS is a mesh_co_ so it_t_s rendered with one draw call only_co_ so quite fast.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIts subparts_co_ called particles_co_ can be accessed one by one and you can set their color and texture (actually uvs from a global texture_co_ think about a texture atlas). This can be done dynamically as many times you need.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe best you could do would be to produce a PG example with what you intend to do_co_ or even a simple prototype showing the principle (say_co_ 300 meshes that need to be textured and colored dynamically or anythng else) and we_co_ this lovely communtiy_co_ would be happy to try to solve your problem or at least to show you some leads to follow to fit your needs\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2016-11-16T19:35:41Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tUse option _qt_3_qt__co_ which is submeshes_co_ but not one for each strip.  Just 2 total.  Assign each sub their own material.  When a horse_co_ the diffuseColor will match.  To zebra_co_ change diffuse color of the material(s).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI think where you are messed up is thinking sub-meshes are contiguous vertices.  They are not_co_ but they must be grouped / defined together.  If you built your geometry in Blender_co_ 3D Max_co_ then this ordering game is automatic.  Doing this by hand is near impossible though.  You have to have duplicate vertices on the borders.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-11-16T19:54:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\thave a look at this example _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#HDHQN%239_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#HDHQN#9_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tno matter how the SPS is built _dd_ here_co_ from a digested torus knot with 128 rings_co_ but the way it_t_s built is not important. What_t_s matter is the way you can access its subpart.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn this example a random color is given to each torus ring_co_ then the color is passed each frame to the next ring _eq_&gt_sm_ one draw call only\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthe same with 800 rings _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#HDHQN%2310_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#HDHQN#10_lt_/a_gt_   (30 fps on my not that good laptop)\n_lt_/p_gt_\n\n_lt_p_gt_\n\tand 60 fps if I lower the tubular segment number _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#HDHQN%2312_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#HDHQN#12_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tor with bigger rings _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#HDHQN%2313_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#HDHQN#13_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t(change the facetNb value at the line 32)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tRemember that the torus knot is really a heavy geometry (have a look at the vertice number in the debug layer)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-11-16T23:11:40Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co__lt_br /_gt__lt_br /_gt_\n\tThank you for the demos. There are a few observations I have after playing with SPS. It is important to note that the size of geometry that is typical for us is 3_co_000_co_000 vertices.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am sure many of these observations are known by you_co_ but I will post and explain them for anyone else reading along_dd__lt_br /_gt__lt_br /_gt_\n\tIf I crank your SPS example up to ~3_co_000_co_000 vertices (removing the animation as well) - _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#%232AZKAH%230_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/##2AZKAH#0_lt_/a_gt_ - we can see the fps plummet. No surprising_co_ considering your two demos with different tubular segments._lt_br /_gt__lt_br /_gt_\n\tIf I use the same example_co_ but instead_co_ reduce the number of particles to 1_co_ FPS is still poor. _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1ZXDGM%235_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1ZXDGM#5_lt_/a_gt_ (6fps on my machine). I assume this is because of the added color weight to the draw call? It seems the number of particles is not a major factor in the final FPS._lt_br /_gt__lt_br /_gt_\n\tConsider only using the meshes_co_ and not particle systems at all - the color is only set set at the beginning of the draw call. Therefore_co_ the draw data is much lighter to the GPU. Notice the FPS now _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#H4PD_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#H4PD_lt_/a_gt_ (60 FPS)._lt_br /_gt__lt_br /_gt_\n\tIf I would rip apart the geometry for the first example_co_ and build meshes based on similar material_co_ I would see very good FPS again. Forgive me_co_ I am not going to create a demo of this geometry manipulation. I have done it in my application_co_ but this requires quite a bit of code_co_ blood_co_ sweat_co_ and tears._lt_br /_gt__lt_br /_gt_\n\tEdit_dd_ The poor performance in my examples has to do with a gaff by me. Removing the line sps.setParticles()_sm_ resolves the performance issues. Jerome speaks more about this below.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-11-17T01:19:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_151314_qt_ data-ipsquote-contentid_eq__qt_26415_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1479324941_qt_ data-ipsquote-userid_eq__qt_8492_qt_ data-ipsquote-username_eq__qt_JCPalmer_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t5 hours ago_co_ JCPalmer said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tUse option _qt_3_qt__co_ which is submeshes_co_ but not one for each strip.  Just 2 total.  Assign each sub their own material.  When a horse_co_ the diffuseColor will match.  To zebra_co_ change diffuse color of the material(s).\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\tI think where you are messed up is thinking sub-meshes are contiguous vertices.  They are not_co_ but they must be grouped / defined together.  If you built your geometry in Blender_co_ 3D Max_co_ then this ordering game is automatic.  Doing this by hand is near impossible though.  You have to have duplicate vertices on the borders.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tSub meshes must be _lt_u_gt_consecutive indices_lt_/u_gt_. This is what I mean by array manipulation - to reorder the indices so that your option 3 could be implemented. To give an example_dd__lt_br /_gt__lt_br /_gt_\n\tIf the horse (for simplicity sake) is made up some _qt_groupings_qt_ of indices 1_co_ 2_co_ 3_co_ 4_co_ 5_co_ 6 where each index _qt_grouping_qt_ is an abstraction of references to some vertices. If we want to colorize grouping 1-&gt_sm_white_co_ 2-&gt_sm_black_co_ 3-&gt_sm_white_co_ 4-&gt_sm_black_co_ 5-&gt_sm_white_co_ 6-&gt_sm_black we would need to define 6 sub meshes.  In order to reduce the needed sub meshes to 2_co_ we would need to reorder the groupings to 1_co_3_co_5_co_2_co_4_co_6. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-11-17T10:15:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tNot sure I was really clear when explaining how to use the SPS because you seem confused and duplicate many SPS what wasn_t_t the initial goal\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf you duplicate many SPS without any animation each frame_co_ it can still be as fastest as many meshes _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#1ZXDGM%237_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#1ZXDGM#7 _lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tor _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#2AZKAH%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#2AZKAH#2_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis has nothing to do with the number of color or particles_co_ but it_t_s related to what amount of vertices you try to update each frame.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe SPS is just a mesh. If you update_co_ say_co_ 50 meshes or submeshes each frame_co_ it will have a cost... and I guess that a scene with 3M updatable vertices will be heavy anyway for the couple JS/WebGL whatever the way you intend to deal with.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe SPS was usefull here to gather all what you needed to update in a single pool (and one draw call) and to use its API as a _qt_subpart API_qt__co_ what is generally easier than accessing consecutive indices in submeshes _dd_ it_t_s designed in this purpose.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t[EDIT] have a look at this SPS with more than 3M vertices _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#HDHQN%2343_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#HDHQN#43_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt_t_s not updated each frame_co_ so the FPS is better... even I still set the colors of the 3M vertices each update. But maybe you don_t_t need to update ALL the vertices each frame but only some of them at certain moment_co_ what could then be far more faster.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-11-17T18:59:33Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tJerome_co__lt_br /_gt__lt_br /_gt_\n\tThank you very much for the information. I think SPS is a very nice solution for the problem as I have described it._lt_br /_gt__lt_br /_gt_\n\tSPS however_co_ is not capable of setting a _lt_u_gt_material_lt_/u_gt_ per particle? Instead_co_ only a color may be applied to each particle. My zebra example was not entirely accurate for my purposes - each stripe should be considered a separate material_co_ not simply a separate rgb value. I guess getting to have my carrot cake_co_ and eat it too is better than no cake _dd_D._lt_br /_gt_\n\t \n_lt_/p_gt_\n_lt_iframe data-embedcontent_eq__qt__qt_ frameborder_eq__qt_0_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/22536-solid-particle-system-with-more-than-1-textures/?do_eq_embed_qt__gt__lt_/iframe_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2016-11-17T19:55:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tno you can_t_t set a material per particle... but you could define one material for the whole SPS with one texture atlas_co_ one file embbeding many different images like this one for instance _dd_ _lt_img alt_eq__qt_spriteAtlas.png_qt_ class_eq__qt_ipsImage_qt_ src_eq__qt_http_dd_//jerome.bousquie.fr/BJS/images/spriteAtlas.png_qt_ /_gt_ \n_lt_/p_gt_\n\n_lt_p_gt_\n\tFrom this single texture you can set a different image (subpart) to each particle _dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/overviews/Solid_Particle_System#uvs_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/overviews/Solid_Particle_System#uvs_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tex _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#2KSQ1R%2338_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#2KSQ1R#38_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tor course_co_ you can change the particle uvs (texture) dynamically _dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#2KSQ1R%23113_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#2KSQ1R#113_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t[EDIT] the principle detailed in these former examples is still the right one_co_ but the code is really old and uses the prototype of the SPS_co_ not the far more optimized BJS-core one_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNote _dd_ particle colors and material colors are mixed together_co_ if any.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn brief _dd_ one mesh_co_ one material_co_ one texture (so one draw call_co_ it_t_s its purpose) but a way to access to each subpart and to set its color and texture individually (and position_co_ rotation_co_ velocity also)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]