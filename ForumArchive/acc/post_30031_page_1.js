[{"Owner":"ua4192","Date":"2017-04-26T08:37:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDear all.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am a new in babylon.js and my problem is that when I try to load multiple meshes in the same scene the memory starts to increase in my browser until it gets hang.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am trying to load about 90 models in GLTF format converted from DAE. The total space of these meshes is about 200MB.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe idea is get the GLTF files information from DB and load these files in the browser on demand.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor model load I am using the function _qt_BABYLON.SceneLoader.ImportMesh_qt_. My first problem is that for each model I import I have to wait until it will be rendered  until continuing to the next one. I would want_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t1.- I want Load all models without rendering them until all them will have loaded and optimization will have finished\n_lt_/p_gt_\n\n_lt_p_gt_\n\t2.- I want to represent the imported mesh for each GLTF in a single mesh and visible in the mesh tree. Currently I am not able to see these meshes in the mesh-tree\n_lt_/p_gt_\n\n_lt_p_gt_\n\t3.- I would want to optimize the scene befor rendering it_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t         - Use  AUTO-LOD (I have different GLT files for each model with different quality\n_lt_/p_gt_\n\n_lt_p_gt_\n\t         - Use merge mesh funtionality\n_lt_/p_gt_\n\n_lt_p_gt_\n\t         - Use simplify mesh\n_lt_/p_gt_\n\n_lt_p_gt_\n\t         - Use octree\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere the function I am using for importing the GLTF models. I you want I can give you the full code _dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tfunction load_gltf2(scene_co_ parent_co_ dir_co_ filename_co_ mat) {_lt_br /_gt_\n\t                BABYLON.SceneLoader.ImportMesh([]_co_ dir_co_ filename_co_ scene_co_ function (newMeshes) {_lt_br /_gt_\n\t                    var dude _eq_ newMeshes[0]_sm__lt_br /_gt_\n\t                    dude.parent _eq_ parent_sm__lt_br /_gt_\n\t                    dude.position _eq_ new BABYLON.Vector3(mat[9]/1000_co_mat[10]/1000_co_mat[11]/1000)_sm__lt_br /_gt_\n\t                    axis1 _eq_ new BABYLON.Vector3(mat[0]/1000_co_mat[1]/1000_co_mat[2]/1000)_sm__lt_br /_gt_\n\t                    axis2 _eq_ new BABYLON.Vector3(mat[3]/1000_co_mat[4]/1000_co_mat[5]/1000)_sm__lt_br /_gt_\n\t                    axis3 _eq_ new BABYLON.Vector3(mat[6]/1000_co_mat[7]/1000_co_mat[8]/1000)_sm__lt_br /_gt_\n\t                    var rot _eq_ BABYLON.Vector3.RotationFromAxis(axis1_co_ axis2_co_ axis3)_sm__lt_br /_gt_\n\t                    dude.rotation _eq_ rot_sm__lt_br /_gt_\n\t                    dude.scaling_eq_ new BABYLON.Vector3(0.001_co_0.001_co_0.001)_sm__lt_br /_gt_\n\t                })_sm_                _lt_br /_gt_\n\t            }_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany many thanks in advanced.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Adrian3D","Date":"2017-04-27T13:20:47Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en-us_qt_ style_eq__qt_font-size_dd_10pt_sm_font-family_dd_Arial_co_ sans-serif_sm_color_dd_#404040_sm__qt_ xml_dd_lang_eq__qt_en-us_qt__gt_Maybe the _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_assetsmanager_qt_ rel_eq__qt_external nofollow_qt__gt_AssetsManager_lt_/a_gt_ can help you. At least regarding your first and potentially also second question?!?_lt_/span_gt__lt_/p_gt_\n_lt_p_gt__lt_/p_gt_\n\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en-us_qt_ style_eq__qt_font-size_dd_10pt_sm_font-family_dd_Arial_co_ sans-serif_sm_color_dd_#404040_sm__qt_ xml_dd_lang_eq__qt_en-us_qt__gt_There is also a playground example..._lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span lang_eq__qt_en-us_qt_ style_eq__qt_font-size_dd_10pt_sm_font-family_dd_Arial_co_ sans-serif_sm_color_dd_#404040_sm__qt_ xml_dd_lang_eq__qt_en-us_qt__gt__lt_/span_gt__lt_/p_gt_\n_lt_p_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-04-27T17:59:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tHello nothing force you to wait for a mesh to be loaded to start loading the next one\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-03T13:45:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi again.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have tried also with the assetmanager_co_ but it seems to have problems with GLTF files.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy other problem is that I want to use instances_co_ many times the same part (GLTF) is used many times and I don_t_t want to import the same mesh multiple times.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy problem is that as the Importmesh is run async_co_ then I cannot instanciate the meshes (GLTFS)_co_ because the importmesh has not yet finished and the instanciating fails.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have tried with BABYLON.GLTFFileLoader.IncrementalLoading _eq_ false_co_ but not enough.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy idea is to use the function var main_mesh_instances _eq_ scene.getMeshesByID(mesh_id)_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf value &gt_sm_ 0 --&gt_sm_ then instanciate\n_lt_/p_gt_\n\n_lt_p_gt_\n\telse importmesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut it doesn_t_t workl\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-05-03T17:30:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\timportMesh has a callback that you can use_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//doc.babylonjs.com/classes/2.5/sceneloader#static-importmesh-meshesnames-rooturl-scenefilename-scene-onsuccess-progresscallback-onerror-rarr-void_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/classes/2.5/sceneloader#static-importmesh-meshesnames-rooturl-scenefilename-scene-onsuccess-progresscallback-onerror-rarr-void_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSee the onsuccess callback.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-04T11:00:30Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI thought that I was already using this feature_co_ let me show my pieze of code for loading the assets_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI get the assets from file assets_csv and when all them will be imported then I start to instanciate them using the file query_csv_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe idea is first load all different meshes for gltf files and when all them will have been loaded then start to instanciate.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t$(document).ready(function() {_lt_br /_gt_\n\t            $.ajax({_lt_br /_gt_\n\t                type_dd_ _qt_GET_qt__co__lt_br /_gt_\n\t                url_dd_ assets_csv_co__lt_br /_gt_\n\t                dataType_dd_ _qt_text_qt__co__lt_br /_gt_\n\t                success_dd_ function(data1) {processData1(data1)_sm_}_lt_br /_gt_\n\t             })_sm__lt_br /_gt_\n\t        })_sm__lt_br /_gt_\n\t        function processData1(allText) {_lt_br /_gt_\n\t            var linecontent1 _eq_ allText.split(/\\n/)_sm__lt_br /_gt_\n\t            // For each line in csv file or query SQL_dd__lt_br /_gt_\n\t            for (var line1_eq_0_sm_ line1&lt_sm_linecontent1.length-1_sm_ line1++) {_lt_br /_gt_\n\t                var data1 _eq_ linecontent1[line1].split(_t__sm__t_)_sm__lt_br /_gt_\n\t                var part_number1 _eq_ data1[0]_sm__lt_br /_gt_\n\t                var part_version1 _eq_ data1[1]_sm__lt_br /_gt_\n\t                var part_id1 _eq_ part_number1 + _qt___qt_ + part_version1_sm__lt_br /_gt_\n\t                var gltf_filename _eq_ part_id1 + _qt_.gltf_qt__sm__lt_br /_gt_\n\t                BABYLON.Tools.Log(_qt_Loading asset for partnumber _qt_ + part_number1 + _qt___qt_ + part_version1)_sm__lt_br /_gt_\n\t                load_asset(part_number1_co_ scene_co_ gltf_folder_co_ gltf_filename_co_ linecontent1.length-2)_sm__lt_br /_gt_\n\t            }_lt_br /_gt_\n\t        }               \n_lt_/p_gt_\n\n_lt_p_gt_\n\t    function load_asset(mesh_id_co_ scene_co_ dir_co_ filename_co_ last_line) {_lt_br /_gt_\n\t        BABYLON.SceneLoader.ImportMesh(null_co_ dir_co_ filename_co_ scene_co_ function (newMeshes) {_lt_br /_gt_\n\t            var main_mesh3 _eq_ gltf.meshes[2]_sm__lt_br /_gt_\n\t            //BABYLON.Tools.Log(_qt_Loaded GLTF _qt_ + filename + _qt_ (_qt_ + mesh_counter + _qt_/_qt_ + last_line + _qt_)_qt_)_sm__lt_br /_gt_\n\t            BABYLON.Tools.Log(_qt_Afrter Append MESH NAME_dd__qt_ + main_mesh3.name + _qt__sm_ MESH ID_dd__qt_ + main_mesh3.name )_sm__lt_br /_gt_\n\t            // check if we have finished to load all assets_dd__lt_br /_gt_\n\t            if ( asset_counter _eq__eq_ last_line ){_lt_br /_gt_\n\t                BABYLON.Tools.Log(_qt_FINAL ASSET_qt_)_sm__lt_br /_gt_\n\t                //var main_mesh3 _eq_ scene.getMeshByName(mesh_id)_sm__lt_br /_gt_\n\t                BABYLON.Tools.Log(_qt_FINAL ASSET_dd__qt_ + main_mesh3.name)_sm__lt_br /_gt_\n\t                scene.render()_sm__lt_br /_gt_\n\t                // call to load instances function_lt_br /_gt_\n\t                $(document).ready(function() {_lt_br /_gt_\n\t                    /*_lt_br /_gt_\n\t                    # order    |    FIELDNAME            |    DESCRIPTION                                                    |    DB TYPE_lt_br /_gt_\n\t                    ---------------------------------------------------------------------------------------------------------_lt_br /_gt_\n\t                    # 0            |    PARTNUMBER_ARRAY     |    Acumulated from DS until previous_level                 |    VARCHAR(20) ARRAY[]_lt_br /_gt_\n\t                    # 1         |    DESCRIPTION            |    Descriptiption of Element                                |    VARCHAR(200)_lt_br /_gt_\n\t                    # 2         |    PARTTYPE            |    File Type                                                |    VARCHAR(15)_lt_br /_gt_\n\t                    # 3         |    ISSUE                |    ISSUE en PRIMES                                            |    VARCHAR(3)_lt_br /_gt_\n\t                    # 4         |    VERSION_ARRAY        |    VERSION en PRIMES                                        |    VARCHAR(10)_lt_br /_gt_\n\t                    # 5         |    MATURITY            |    MATURITY in PRIMES                                        |    VARCHAR(30)_lt_br /_gt_\n\t                    # 6         |    MATRIX_ARRAY        |    Conversion Matrix_co_ not transformed                          |    DOUBLE[12]_lt_br /_gt_\n\t                    # 7             |    LASTCHANGE            |    Date of last change                                        |    DATE_lt_br /_gt_\n\t                    # 8            |     LEVEL                |    Level                                                    |    INT_lt_br /_gt_\n\t                    # 9            |    UUID_ARRAY            |    Autocalculated ID                                        |    VARCHAR(32)_lt_br /_gt_\n\t                    */_lt_br /_gt_\n\t                    $.ajax({_lt_br /_gt_\n\t                        type_dd_ _qt_GET_qt__co__lt_br /_gt_\n\t                        url_dd_ query_result_co__lt_br /_gt_\n\t                        dataType_dd_ _qt_text_qt__co__lt_br /_gt_\n\t                        success_dd_ function(data2) {processData2(data2)_sm_}_lt_br /_gt_\n\t                     })_sm__lt_br /_gt_\n\t                     function processData2(allText) {_lt_br /_gt_\n\t                        var linecontent2 _eq_ allText.split(/\\n/)_sm__lt_br /_gt_\n\t                        // For each line in csv file or query SQL_dd__lt_br /_gt_\n\t                        for (var line2_eq_0_sm_ line2&lt_sm_linecontent2.length_sm_ line2++) {_lt_br /_gt_\n\t                            scene.render()_sm__lt_br /_gt_\n\t                            // Extract line from query and form an array_dd__lt_br /_gt_\n\t                            var data2 _eq_ linecontent2[line2].split(_t__sm__t_)_sm__lt_br /_gt_\n\t                            BABYLON.Tools.Log(_qt_Processing line_dd_ _qt_ + line2 + _qt_/_qt_ + linecontent2.length)_sm__lt_br /_gt_\n\t                            //Check  if line is well formed_dd_ 10 columns_lt_br /_gt_\n\t                            //BABYLON.Tools.Log(_qt_line_content_dd_ _qt_ + linecontent[line])_sm__lt_br /_gt_\n\t                            if (data2.length _eq__eq_ 12) {_lt_br /_gt_\n\t                                //BABYLON.Tools.Log(_qt_--- LINE WELL FORMED_qt_)_sm__lt_br /_gt_\n\t                                // Extract columns in variables_dd__lt_br /_gt_\n\t                                var partnumber_array _eq_ data2[0].split(_t__dd__t_)_sm__lt_br /_gt_\n\t                                var description  _eq_ data2[1]_sm__lt_br /_gt_\n\t                                var part_type  _eq_ data2[2]_sm__lt_br /_gt_\n\t                                var issue  _eq_ data2[3]_sm__lt_br /_gt_\n\t                                var version_array _eq_ data2[4].split(_t__dd__t_)_sm__lt_br /_gt_\n\t                                var maturity _eq_ data2[5]_sm__lt_br /_gt_\n\t                                var matrix_array _eq_ data2[6].split(_t__co__t_)_sm__lt_br /_gt_\n\t                                var lastchange _eq_ data2[7]_sm__lt_br /_gt_\n\t                                var level _eq_ data2[8]_sm__lt_br /_gt_\n\t                                var uuid_array _eq_ data2[9].split(_t__dd__t_)_sm__lt_br /_gt_\n\t                            _lt_br /_gt_\n\t                                // Get current uuid_path already done in variable uuid_array_lt_br /_gt_\n\t                                // Get get_common_level with function get_common_level(previous_uuid_path_co_current_uuid_path)_lt_br /_gt_\n\t                                var common_level _eq_ get_common_level(previous_uuid_path_co_uuid_array)_sm__lt_br /_gt_\n\t                                //BABYLON.Tools.Log(_qt_------ COMMON LEVEL bettwen _qt_ + previous_uuid_path + _qt_ and _qt_ + uuid_array + _qt_ ------ &gt_sm_ _qt_ + common_level)_sm__lt_br /_gt_\n\t                                // Generate tree product structure from common parent_dd__lt_br /_gt_\n\t                                for (var q_eq_common_level_sm_ q &lt_sm_ uuid_array.length_sm_ q++) {_lt_br /_gt_\n\t                                    // if we are at the end of the array_co_ then import gltf mesh_lt_br /_gt_\n\t                                    var part_number2 _eq_ partnumber_array[q]_sm__lt_br /_gt_\n\t                                    var version2 _eq_ version_array[q]_sm__lt_br /_gt_\n\t                                    var part_number2 _eq_ part_number2 + _qt___qt_ + version2_sm__lt_br /_gt_\n\t                                    var trans_mat _eq_ matrix_array[q].split(_t__dd__t_)_sm__lt_br /_gt_\n\t                                    if ( q _eq__eq_ uuid_array.length - 1 ){_lt_br /_gt_\n\t                                        //BABYLON.Tools.Log(_qt_------ &gt_sm_ PRELOADING GLTF (_qt_ + mesh_count + _qt_/_qt_ + linecontent.length + _qt_)_qt_ )_sm__lt_br /_gt_\n\t                                        var gltf_filename _eq_ part_number2 + _qt_.gltf_qt__sm__lt_br /_gt_\n\t                                        create_instance(part_number2_co_ part_number2 _co_ scene_co_ scene.getMeshByID(uuid_array[q-1])_co_ gltf_folder_co_ gltf_filename_co_ trans_mat_co_ linecontent2.length-1)_sm__lt_br /_gt_\n\t                                    // else if common_level_eq_0_co_ then  declare parent as main_mesh_scene_lt_br /_gt_\n\t                                    } else {_lt_br /_gt_\n\t                                        var mymesh _eq_ new BABYLON.Mesh.CreateBox(part_number2_co_ 0_co_ scene)_sm__lt_br /_gt_\n\t                                        mymesh.id _eq_ uuid_array[q]_sm__lt_br /_gt_\n\t                                        if ( common_level _eq__eq_ 0 ){_lt_br /_gt_\n\t                                            mymesh.parent _eq_ main_mesh_scene_sm__lt_br /_gt_\n\t                                        } else {_lt_br /_gt_\n\t                                            var mymesh_parent _eq_ scene.getMeshByID(uuid_array[q-1])_sm__lt_br /_gt_\n\t                                            //BABYLON.Tools.Log(_qt_------ &gt_sm_ mymesh.parent _eq_ _qt_ + mymesh_parent.id)_sm__lt_br /_gt_\n\t                                            mymesh.parent _eq_ mymesh_parent_sm__lt_br /_gt_\n\t                                        }_lt_br /_gt_\n\t                                        mymesh.position _eq_ new BABYLON.Vector3(trans_mat[9]_co_trans_mat[10]_co_trans_mat[11])_sm__lt_br /_gt_\n\t                                        axis1 _eq_ new BABYLON.Vector3(trans_mat[0]_co_trans_mat[1]_co_trans_mat[2])_sm__lt_br /_gt_\n\t                                        axis2 _eq_ new BABYLON.Vector3(trans_mat[3]_co_trans_mat[4]_co_trans_mat[5])_sm__lt_br /_gt_\n\t                                        axis3 _eq_ new BABYLON.Vector3(trans_mat[6]_co_trans_mat[7]_co_trans_mat[8])_sm__lt_br /_gt_\n\t                                        var rot _eq_ BABYLON.Vector3.RotationFromAxis(axis1_co_ axis2_co_ axis3)_sm__lt_br /_gt_\n\t                                        mymesh.rotation _eq_ rot_sm__lt_br /_gt_\n\t                                        mymesh.isVisible _eq_ false_sm__lt_br /_gt_\n\t                                        array_scene_meshes[mesh_count] _eq_ mymesh_sm__lt_br /_gt_\n\t                                    } // del if ( q _eq__eq_ uuid_array.length -1 ){_lt_br /_gt_\n\t                                } // del for (var q_eq_common_level_sm_ q &lt_sm_ uuid_array.length_sm_ q++) {_lt_br /_gt_\n\t                                previous_uuid_path _eq_ uuid_array_sm__lt_br /_gt_\n\t                            } // del if (data.length _eq__eq_ 10) {_lt_br /_gt_\n\t                        } // del for (var line_eq_0_sm_ line&lt_sm_linecontent.length_sm_ line++) {_lt_br /_gt_\n\t                        var camera _eq_ new BABYLON.ArcRotateCamera(_qt_camera_qt__co_ Math.PI/2_co_ Math.PI/2_co_ 10_co_ new BABYLON.Vector3(-37_co_-0.2_co_-0.1)_co_ scene)_sm__lt_br /_gt_\n\t                        camera.attachControl(canvas_co_ true)_sm_    _lt_br /_gt_\n\t                    } // del function processData(allText) {_lt_br /_gt_\n\t                }_lt_br /_gt_\n\t            }_lt_br /_gt_\n\t            asset_counter +_eq_ 1_sm__lt_br /_gt_\n\t        })_lt_br /_gt_\n\t        BABYLON.Tools.Log(_qt_REALLY LOADED?_qt_)_sm__lt_br /_gt_\n\t    }\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-05-04T22:00:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tHey I suggest that you create a PG and highlight the issue _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-05T08:18:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy problem is very simple_co_ I try to in a first phase load the different GLTF models with the importmesh function provided by Babylonjs. For doing this_co_ I provide the different GLTF models that will be used in the scene provided by a CSV file_co_ at the end the results will be provided by a SQL query launched from the server side.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy problem is that as importmesh works in async mode_co_ when I try to look for any mesh loaded with importmesh_co_ the search returns a null result.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am using the scene.getMeshByName(mesh_name) and  scene.getMeshByID(mesh_id)_sm_ \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAbout making a play ground_co_ it is really complex for me. For work I am not able to access (proxy policies).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI hope this will be enough to explain my problem. basically I want to avoid to load the same GLTF 1000 times_co_ I want to load it 1 time and instantiate it the next 999 times. I have tried to search any example using multiple GLTFS but I was not able to.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tMany thanks in advanced for your help.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-05-05T14:43:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThis is where I do not follow you. You know that ImportMesh is async so why not doing what you have to to with your mesh in the callback function?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#10FF4M%231_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#10FF4M#1_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-05T18:58:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst to thank you\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSee in _lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#10FF4M%233_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#10FF4M#3_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can see that I cannot access meshes from callback\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMaybe I am missing something.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-05T19:13:37Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSorry.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy mistake.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt works!!!!!!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany thanks for your support\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-05-08T15:16:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tlol cool _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-09T13:41:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have another question.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe GLTF models I am trying to instantiate have sub-meshes inside. This is the structure_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tcontainer_name_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t   - submesh_1\n_lt_/p_gt_\n\n_lt_p_gt_\n\t   - submesh_1\n_lt_/p_gt_\n\n_lt_p_gt_\n\t    ...\n_lt_/p_gt_\n\n_lt_p_gt_\n\t   - submesh_n\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy problem is that when I instantiate the container_co_ the sub-meshes inside are not instantiated. DO I have to instantiate all submeshes by separate?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMany many thanks in advanced\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-05-09T15:59:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tYes instantiation only take the current mesh. So you have to also instantiate the children as well\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ua4192","Date":"2017-05-09T16:16:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tmany thanks for your confirmation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_dd_ )\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]