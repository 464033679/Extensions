[{"Owner":"gwenael","Date":"2013-12-23T14:53:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi there_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I was reading the code for BABYLON.SceneLoader._ImportGeometry and I noticed that the following line calls internally the creation of a global subMesh_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_mesh.setVerticesData(parsedGeometry.positions_co_ BABYLON.VertexBuffer.PositionKind_co_ false)_sm__lt_/pre_gt__lt_p_gt_Later in this function_co_ there is the following part_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_if (parsedGeometry.subMeshes) {                mesh.subMeshes _eq_ []_sm_                for (var subIndex _eq_ 0_sm_ subIndex &lt_sm_ parsedGeometry.subMeshes.length_sm_ subIndex++) {                    var parsedSubMesh _eq_ parsedGeometry.subMeshes[subIndex]_sm_                    var subMesh _eq_ new BABYLON.SubMesh(parsedSubMesh.materialIndex_co_ parsedSubMesh.verticesStart_co_ parsedSubMesh.verticesCount_co_ parsedSubMesh.indexStart_co_ parsedSubMesh.indexCount_co_ mesh)_sm_                }            }_lt_/pre_gt__lt_p_gt_Thus mesh.subMeshes which previously contained the global suMesh is cleared and filled by subMeshes found in the .babylon file (or .babylonmeshdata file)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Is there always a global submesh provided for a mesh in the .babylon file (or .babylonmeshdata file)? If yes_co_ and if that the first one in the array_co_ I have the feeling that during importing geometry_co_ it would be possible not to empty mesh.subMeshes and to start the loop to 1. We_t_ll get this_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_if (parsedGeometry.subMeshes) {                for (var subIndex _eq_ 1_sm_ subIndex &lt_sm_ parsedGeometry.subMeshes.length_sm_ subIndex++) {                    var parsedSubMesh _eq_ parsedGeometry.subMeshes[subIndex]_sm_                    var subMesh _eq_ new BABYLON.SubMesh(parsedSubMesh.materialIndex_co_ parsedSubMesh.verticesStart_co_ parsedSubMesh.verticesCount_co_ parsedSubMesh.indexStart_co_ parsedSubMesh.indexCount_co_ mesh)_sm_                }            }_lt_/pre_gt__lt_p_gt_In the collision code_co_ I got confused too._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I understood that first the collision with the bounding sphere and the bounding box of the mesh is checked and then the collision for the subMeshes is checked. The globalSubMesh seems to be the first in the array of subMeshes_co_ so the collision with its bounding sphere and its bounding box is checked too. Its boundingInfo are the same as the mesh_co_ aren_t_t they?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_From these two examples_co_ I feel like we are computing twice the same thing. I may be wrong so please correct me so I could understand the use of this global submesh. Thank you._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2013-12-24T10:15:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_the global submesh is a the submesh that cover all the mesh. If there are submeshes in the .babylon file we have to remove the globalsubmesh because the file will provide more precise subdivisions_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_From the collisions point of view_co_ after checking bounding box and sphere_co_ we have to check submeshes one by one in order to optimize collisions (not against all the mesh but jsut against a specific submesh)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"gwenael","Date":"2013-12-24T10:23:51Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co_ thank you Deltakosh. So things are computed twice (for the mesh and the global submesh) only if no submeshes are provided in the babylon file. Is that right? I will test a new export (FBX to Babylon) because I have the impression that if I don_t_t have submeshes in 3ds max_co_ I have a submesh (corresponding to the global submesh) in the babylon file._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2013-12-25T11:10:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If we speak about collisions_co_ things are computed only once because there is a test to check if there is only one submesh_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"gwenael","Date":"2013-12-26T13:19:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_OK I found the code you_t_re talking about. Thank you._lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.Mesh.prototype._processCollisionsForSubModels _eq_ function (collider_co_ transformMatrix) {    for (var index _eq_ 0_sm_ index &lt_sm_ this.subMeshes.length_sm_ index++) {        var subMesh _eq_ this.subMeshes[index]_sm_        // Bounding test        if (this.subMeshes.length &gt_sm_ 1 &amp_sm_&amp_sm_ !subMesh._checkCollision(collider))            continue_sm_        this._collideForSubMesh(subMesh_co_ transformMatrix_co_ collider)_sm_    }}_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]