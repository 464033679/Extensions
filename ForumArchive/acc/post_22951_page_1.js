[{"Owner":"dungtm","Date":"2016-06-03T07:57:17Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI have a page that loads about 40K meshes with BabylonJS (run in Chrome). When I disposed the scene (by using scene.dispose())_co_ and deleted all the Javascript references to the meshes_co_ the Javascript memory for the tab was reduced (not very fast_co_ however)_co_ but the total memory occupied by the tab did not change (see the picture attached). The next time when I tried to recreate the scene_co_ the memory increased rapidly and the page crashed. Can anyone explain me what contributes to the total memory in Chrome (apart from Javascript memory) and why it was unchanged?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAnother question is why the GPU memory persists (in the Chrome tab process and GPU process)_co_ even when I dispose the scene and hide the canvas? (It reduced significantly when I closed the Chrome tab). Is there anyway to release GPU memory when the 3D graphics is no longer used?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks in advance for your help.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2016_06/BabylonJs_MemoryLeak.png.29f98191e6543fb58315f2f3765b39b5.png_qt_ data-fileid_eq__qt_7943_qt_ rel_eq__qt_external nofollow_qt__gt__lt_img alt_eq__qt_BabylonJs_MemoryLeak.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_7943_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2016_06/BabylonJs_MemoryLeak.thumb.png.a6dfb5b500b45b157294bbdd19fba7db.png_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2016-06-03T15:46:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHey!\n_lt_/p_gt_\n\n_lt_p_gt_\n\tChrome is known for his catastrophic memory management _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tcan you try engine.dispose()? and also try to remove canvas from the DOM\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ferat","Date":"2016-06-08T22:32:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI have a similar problem with my app (using NW.js to run in Desktop Mode) . When i click a button_co_ I call the code below_dd_ \n_lt_/p_gt_\n\n_lt_p_gt_\n\tresetScene_dd_ function(meshName) {_lt_br /_gt_\n\t            scene.dispose()_sm__lt_br /_gt_\n\t            return this.createNewScene(meshName)_sm_ //Creates a new scene\n_lt_/p_gt_\n\n_lt_p_gt_\n\t}\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe scene.dispose() works well_co_ but the memory is not released. And I have the same problem with material.dispose()_co_ always that i call it_co_ the memory is not released. When I create a new material_co_ the memory increases.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat can i do to solve this?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks a lot\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"dungtm","Date":"2016-06-09T10:25:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHey_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst of all_co_ thank you Deltakosh for your response and your time. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAfter many tests_co_ I found that the problems are related to the references that are not removed after the dispose() method. If you happen to have a reference to scene_co_ or camera_co_ or _lt_strong_gt_only one mesh_lt_/strong_gt_ somewhere_co_ a lot of memory will not be released. _lt_span_gt_@ferat_dd_ you should scan all your code and make sure that there is no reference to any object in the scene (including the camera and the scene itself). For example_co_ the scene reference should be deleted by _lt_strong_gt_scene _eq_ null._lt_/strong_gt_ _lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis is (partly?) due to the fact that object scene is still big after calling dispose(). I scanned the code and found that_co_ for example_co_ the _activeMeshes in scene are not cleared in dispose(). This array holds references to all active meshes. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe camera also has an array _activeMeshes which hold the same references. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAny mesh in the scene has reference to the scene. This means if you have one reference to _lt_strong_gt_only one mesh_lt_/strong_gt__co_ this will consequently keeps the scene in memory_co_ even when you deleted the scene by _lt_strong_gt_scene _eq_ null_lt_/strong_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis is quite tricky and non obvious because when we dispose a mesh or a scene_co_ we expect that its memory related to the 3D graphics be released_co_ even when we mistakenly_co_ or intentionally_co_ keep a reference. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI would propose some improvements to avoid unwanted memory leaks_dd_ 1) Clear all _activeMeshes at scene.dispose()_sm_ 2) Remove the reference to the scene in Node.dispose (or Mesh.dispose). 3) In general_co_ in the dispose() of an object_co_ clear all the references it keeps to the external objects_co_ ....\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn addition_co_ the more we remove references_co_ the easier and more rapid the job of the garbage collector. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tPls correct me if I am wrong. Again_co_ thanks for your help.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"ferat","Date":"2016-06-09T12:06:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tThanks _lt_span_gt_@dungtm. I will scan my code for references. Thanks a lot for your help!!_lt_/span_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"dbawel","Date":"2016-06-09T23:40:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/22047-dungtm/?do_eq_hovercard_qt_ data-mentionid_eq__qt_22047_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/22047-dungtm/_qt_ rel_eq__qt__qt__gt_@dungtm_lt_/a_gt_ - great post. I have found that GC management is poor in Chrome_co_ however_co_ there appears to be unknown issues with BJS scenes in most browsers. But this is a young framework comparatively_co_ and posts such as this help the _qt_team_qt_ building this to optimize in every release. I_t_ve taken a hard look (as much as my experience allows) at GC in Chrome_co_ and can hardly distinguish what is handled in minor GC and major GC_co_ although most of the latency and memory issues appear to be with major GC such as disposing of items such as textures and meshes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDB\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]