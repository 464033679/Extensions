[{"Owner":"Artem","Date":"2014-03-18T05:24:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Is it possible? I need to check if one cube touches a side (face) of another cube (it should be exactly its side/polygon_co_ not just a single point)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_font-size_dd_10px_sm__qt__gt_Off-topic_dd__lt_/span_gt__lt_/p_gt__lt_p_gt__lt_span style_eq__qt_font-size_dd_10px_sm__qt__gt_What_t_s _qt_isInFrustrum(frustumPlanes)_qt_?_lt_/span_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Artem","Date":"2014-03-18T06:33:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hm_co_ it looks like I figured it out myself. I used _qt_intersectsMinMax_qt__dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_player.getBoundingInfo().boundingBox.intersectsMinMax(box.getBoundingInfo().boundingBox.vectorsWorld[0]_co_ box.getBoundingInfo().boundingBox.vectorsWorld[6])_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"gwenael","Date":"2014-03-18T17:36:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.BoundingBox.prototype.intersectsMinMax _eq_ function (min_co_ max) {    if (this.maximumWorld.x &lt_sm_ min.x || this.minimumWorld.x &gt_sm_ max.x)        return false_sm_    if (this.maximumWorld.y &lt_sm_ min.y || this.minimumWorld.y &gt_sm_ max.y)        return false_sm_    if (this.maximumWorld.z &lt_sm_ min.z || this.minimumWorld.z &gt_sm_ max.z)        return false_sm_    return true_sm_}_sm_// can also be written like this_dd_BABYLON.BoundingBox.prototype.intersectsMinMax _eq_ function (min_co_ max) {    if (this.maximumWorld.x &gt_sm__eq_ min.x &amp_sm_&amp_sm_ this.maximumWorld.y &gt_sm__eq_ min.y &amp_sm_&amp_sm_ this.maximumWorld.z &gt_sm__eq_ min.z &amp_sm_&amp_sm_ this.minimumWorld.x &lt_sm__eq_ max.x &amp_sm_&amp_sm_ this.minimumWorld.y &lt_sm__eq_ max.y &amp_sm_&amp_sm_ this.minimumWorld.z &lt_sm__eq_ max.z)        return true_sm_    return true_sm_}_sm__lt_/pre_gt__lt_p_gt_intersectsMinMax allows you to check if there is an intersection (a common volume) between two bounding boxes_co_ the one specified while calling intersectsMinMax and the one defined by min and max which are the parameters of the function. This intersection can be a single point... Vector3(max.x_co_ max.y_co_ max.z) _eq_ minimumWorld for example._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]