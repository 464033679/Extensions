[{"Owner":"fenomas","Date":"2015-04-02T07:57:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_div_gt_Hi_co__lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt__lt_div_gt_I_t_m rendering a scene with a few hundred separate _t_chunks_t_ of terrain_co_ each of which contains several pieces of terrain. When constructed the naive way (one mesh for each piece of terrain)_co_ mesh selection got quite slow_co_ so I switched to merging each chunk into a single mesh with submeshes for pieces of terrain._lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt__lt_div_gt_However it would be _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/13427-batching-calls/?p_eq_77517_qt__gt_valuable_lt_/a_gt_ to keep everything as a separate mesh_co_ and I figured Octrees might solve the problem. So instead of merging each chunk into one mesh_co_ I made one OctreeBlock for each chunk and put them into a selection Octree. Since this means the same number of items to select from_co_ naively one might expect performance to be similar. But after coding it all up_co_ mesh selection (as reported in the debugLayer) was roughly twice as slow as when using submeshes._lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt__lt_div_gt_Is it to be expected that selecting submeshes is much faster than selecting in an octree_co_ or am I misunderstanding something?_lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt__lt_div_gt_(Side note_dd_ when testing my Octree scene I noticed that the debugLayer reported _qt_active vertices_qt_ as being much larger than _qt_total vertices_qt_. Bug in the debug layer maybe?)_lt_/div_gt__lt_br_gt__lt_div_gt_ _lt_/div_gt__lt_br_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-04-02T17:33:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If there is no octree on a mesh (_lt_span style_eq__qt_background-color_dd_transparent_sm__qt__gt_mesh.createOrUpdateSubmeshesOctree(capacity_co_ maxDepth)) _lt_/span_gt_then there is no selection_dd_ ALL submeshes are checked against the frustrum_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Mesh selection is the process of finding visible meshes (or submeshes). You can put a breakpoint there_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/babylon.scene.ts#L1181_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/babylon.scene.ts#L1181_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This will allow you to see if the octree is optimal (meaning how many meshes will be tested against the frustrum AFTER using the octree)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Octrees start to be optimal when there is more than 256 meshes (and this is an bold approximation_co_ because it really depends on the computer used)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_For your side note_co_ this is expected has active vertices is the number of vertices on the scene whereas total vertices is the number of vertices used by the GPU (so number of facesx3)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-02T18:32:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_77649_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_13592_qt_ data-ipsquote-username_eq__qt_Deltakosh_qt_ data-cite_eq__qt_Deltakosh_qt_ data-ipsquote-timestamp_eq__qt_1427995989_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_If there is no octree on a mesh (_lt_span style_eq__qt_background-color_dd_transparent_sm__qt__gt_mesh.createOrUpdateSubmeshesOctree(capacity_co_ maxDepth)) _lt_/span_gt_then there is no selection_dd_ ALL submeshes are checked against the frustrum_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Err.. maybe I_t_m loopy. I thought _qt_selection_qt_ was when something gets checked against the frustrum. I.e._co_ if I define scene._selectionOctree to be an octree with one block_co_ then that block_t_s bounding volume would get checked against the frustum_co_ and if it overlaps then all meshes in that block would be visible (without further checks). Is that not what_t_s going on?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(To be clear_co_ the case I_t_m asking about being slow does not use any submeshes. Although I_t_m surprised there too - I assumed that if a mesh has submeshes (but no octree)_co_ then whenever the mesh_t_s bounding volume is inside the frustum all its submeshes would be assumed to be visible without checks. You_t_re saying it checks the mesh_t_s bounding volume and then checks all the submesh bounding volumes too?)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-02T18:35:02Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_77649_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_13592_qt_ data-ipsquote-username_eq__qt_Deltakosh_qt_ data-cite_eq__qt_Deltakosh_qt_ data-ipsquote-timestamp_eq__qt_1427995989_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_For your side note_co_ this is expected has active vertices is the number of vertices on the scene whereas total vertices is the number of vertices used by the GPU (so number of facesx3)_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If _qt_total vertices_qt_ is the number of vertices on the GPU_co_ it should not go up and down just because the camera moves around_co_ right? That_t_s what I_t_m seeing when I use octrees._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-04-02T20:51:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_it *should* go up and down because it is the number of vertices SENT to the GPU for the rendering and not the number of vertices in GPU memory_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-03T01:56:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Okay_co_ got it. And octrees/selection?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-04-03T20:49:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_What do you mean?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-04T01:59:50Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I was wondering about the questions in the third post._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-04T05:18:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hurm. Well_co_ after more source diving_co_ I guess what I wasn_t_t understanding was that octree checks only exclude meshes from being rendered - if the octree check returns true_co_ then all meshes in the octree later get checked _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/babylon.scene.ts#L1217_qt_ rel_eq__qt_external nofollow_qt__gt_individually_lt_/a_gt_._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Is that correct? If so_co_ what_t_s the benefit of the second check? I thought the point of having an octree was to avoid checking each mesh individually?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-04-04T17:59:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_So _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt__gt__lt_div_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_Err.. maybe I_t_m loopy. I thought _qt_selection_qt_ was when something gets checked against the frustrum. I.e._co_ if I define scene._selectionOctree to be an octree with one block_co_ then that block_t_s bounding volume would get checked against the frustum_co_ and if it overlaps then all meshes in that block would be visible (without further checks). Is that not what_t_s going on?_lt_/span_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_All meshes will then be checked individually against the frustum_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt__gt__lt_div_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_Hurm. Well_co_ after more source diving_co_ I guess what I wasn_t_t understanding was that octree checks only exclude meshes from being rendered - if the octree check returns true_co_ then all meshes in the octree later get checked _lt_/span_gt__lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/Babylon/babylon.scene.ts#L1217_qt_ title_eq__qt_External link_qt_ rel_eq__qt_external nofollow_qt__gt_individually_lt_/a_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_._lt_/span_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_This is correct. The goal of the octree is to reduce the number of meshes to check. This is why an octree is useful when there is a lot of meshes_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2015-04-05T04:09:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok. So in general_co_ visible mesh selection is always O(n) then?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I had thought that the point of octrees was to select visible meshes in O(log n)... perhaps I need to override _lt_span style_eq__qt_color_dd_rgb(121_co_93_co_163)_sm_font-family_dd_Consolas_co_ _t_Liberation Mono_t__co_ Menlo_co_ Courier_co_ monospace_sm_font-size_dd_12px_sm__qt__gt__evaluateActiveMeshes_lt_/span_gt_ or something._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-04-06T00:19:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yes or we can also think about a boolean on the scene to disable per mesh testing (But we need to figure out if this is really better)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"AussieKSU","Date":"2016-04-21T21:51:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tFenomas_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tA solution that I_t_ve been using for mesh selection is to use a single mesh_co_ but keep a _qt_dictionary_qt_ of vertex ranges to your separate objects as they exist in the merged mega mesh. This way_co_ when a selection occurs_co_ you can derive from the face in the selection information to which object the selection occurred. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tThis allows me to reap the good performance of limited GPU pushes with a low amount of meshes in the scene_co_ while supporting _qt_single_qt_ mesh selection as well. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve gone so far as to support _qt_highlighting_qt_ of parts of the mega mesh. This involves pulling out the verteces (normals_co_ positions_co_ uvs) from the mega mesh_co_ and inserting them into a different mesh with the desired _qt_selection_qt_ material.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThere is a happy medium with the size of the mega mesh (with respect to vertex count)_co_ and the performance you want to achieve with the selection operation. The smaller the mega mesh_co_ the better selection performance you will see_co_ but the price will then be paid with a larger number of meshes in the scene (as you_t_ll need to break up into smaller mega meshes).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]