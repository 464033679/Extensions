[{"Owner":"timetocode","Date":"2018-05-10T10:55:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWhat are the ways of moving a rotated object in the direction that it is facing (or left_co_ or right_co_ or backwards_co_ up_co_ or down)? How much does this change if the game is a first person shooter (player_t_s head always points up to Y) versus a space ship game (where the spaceship can go upside down and even barrel roll) ?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI understand that I can take a vector such as BABYLON.Vector3.Up() and locallyTranslate it via a mesh that has a rotation... but how do I describe this direction as a Vector3 (instead of immediately applying it to the mesh) so that I can use moveWithCollisions(movementVector)?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHow hard is it to do this math manually?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tShould I be studying quaternions?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks _lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt_ \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s some of my movement code (which works_co_ ish) but is very indirect_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_// face player mesh to face the same direction as the camera\nthis.mesh.lookAt(\n    this.mesh.position.add(\n        new BABYLON.Vector3(\n            -command.rotationX_co_\n            -command.rotationY_co_\n            -command.rotationZ\n        )\n    )\n)\n\n// controls_dd_ forward_co_ backward_co_ left_co_ right\nlet unit _eq_ BABYLON.Vector3.Zero()\nif (command.forward) { unit.z +_eq_ 1 }\nif (command.backward) { unit.z -_eq_ 1 }\nif (command.left) { unit.x -_eq_ 1 }\nif (command.right) { unit.x +_eq_ 1 }\nunit.normalize() // to prevent diagonal movement being faster\n\n// full vector_co_ movement and magnitude\nlet velocityCoef _eq_ this.speed * command.delta\nthis.velocity.x +_eq_ unit.x * velocityCoef\nthis.velocity.y +_eq_ unit.y * velocityCoef\nthis.velocity.z +_eq_ unit.z * velocityCoef\n\n// no idea how to align the velocity vector with \n// the direction we_t_re facing... so locallyTranslate it\nlet temp _eq_ this.mesh.position.clone()\nthis.mesh.locallyTranslate(this.velocity)\n// but locallyTranslate doesnt do collisions.. so lets just\n// teleport back to where we were and calculate what vector\n// we just moved along\nlet diff _eq_ this.mesh.position.subtract(temp)\nthis.mesh.position.copyFrom(temp)\n// now we have the vector that we would_t_ve moved_co_ let_t_s\n// try it again with collisions\nthis.mesh.moveWithCollisions(diff)\n\nthis.velocity.x _eq_ 0\nthis.velocity.y _eq_ 0\nthis.velocity.z _eq_ 0_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2018-05-10T11:19:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tCheckout the mesh getDirection function.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-14T04:31:54Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWhat does one pass to getDirection?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-14T06:08:00Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIv_t_e been experimenting with a few things_co_ mostly centered around TransformCoordinates_co_ and Matrix.RotationAxis(axis_co_ mesh.rotation).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve been trying this for forward on a mesh_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let forward _eq_ BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward()_co_ mesh.getWorldMatrix())\nlet dir _eq_ forward.subtract(mesh.position).normalize()_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThen this for forward on a camera_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let cameraRay _eq_ camera.getForwardRay().direction_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tAnd then for multiplayer_co_ when moving a player on the server_co_ I send the cameraRay and the controls over the network and move forward/back and strafe left/right like this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let camVector _eq_ new BABYLON.Vector3(\n    command.cameraVectorX_co_\n    command.cameraVectorY_co_\n    command.cameraVectorZ\n)\n\n// rotates the player\nthis.mesh.lookAt(this.mesh.position.add(camVector.negate()))\n\nlet unit _eq_ BABYLON.Vector3.Zero()\nif (command.forward) { unit.z +_eq_ 1 }\nif (command.backward) { unit.z -_eq_ 1 }\nif (command.left) { unit.x -_eq_ 1 }\nif (command.right) { unit.x +_eq_ 1 }\nunit.normalize()\n\nlet matrix _eq_ BABYLON.Matrix.RotationAxis(BABYLON.Axis.Y_co_ this.mesh.rotation.y)\nlet heading _eq_ new BABYLON.Vector3(\n    unit.x * this.speed * command.delta_co_\n    unit.y * this.speed * command.delta_co_\n    unit.z * this.speed * command.delta_co_\n)\n\nlet movement _eq_ heading.clone() // no need to clone\nif (command.jump) {\n    // no-accel jetpack\n    movement.y +_eq_ 10 * command.delta\n} else {\n    // really fake no-accel gravity\n    movement.y -_eq_ 10 * command.delta\n}\n\nlet movementVector _eq_ BABYLON.Vector3.TransformCoordinates(movement_co_ matrix)\nthis.mesh.moveWithCollisions(movementVector)\n\n// and then for shooting_co_ _lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t^ `command` is the network object holding the data from the client\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt is getting a little better_co_ still not sure if these are good ways to do things or not\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-05-14T16:01:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tlooks great to me _lt_span_gt__lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt_true_qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt__gt__lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-14T19:50:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_ve added firing a Ray forward to the above logic and I_t_m running into a problem. I begin calculating the direction of the ray similarly to the forward-ish logic from above_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let f _eq_ BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward()_co_ mesh.getWorldMatrix())\nconsole.log(_t_f_t__co_ f)\nconsole.log(_t_mesh.position_t__co_ this.mesh.position)\nconsole.log(_t_mesh.rotation_t__co_ this.mesh.rotation)_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Problem_lt_/strong_gt__dd_ `f` is different on server and client_co_ even though mesh.position and mesh.rotation are the same. So I guess mesh.getWorldMatrix() is based off more than just position and rotation..is that correct? What other data do I need to synchronize? I think some part of the transform is out of sync.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tLog output from server_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_[1] f t {\n[1]   x_dd_ 87.71782332658768_co_\n[1]   y_dd_ 28.766663193702698_co_\n[1]   z_dd_ 39.23026758432388 }\n[1] mesh.position t {\n[1]   x_dd_ 87.25551778257102_co_\n[1]   y_dd_ 29.250780211047058_co_\n[1]   z_dd_ 38.58501679257934 }\n[1] mesh.rotation t { x_dd_ 0.6739999993520329_co_ y_dd_ 0.7990000362848866_co_ z_dd_ 0 }_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tLog output from client_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_f t {x_dd_ 87.81546431779861_co_ y_dd_ 28.62666380405426_co_ z_dd_ 39.12993723154068}\nmesh.position t {x_dd_ 87.25551778257102_co_ y_dd_ 29.250780211047058_co_ z_dd_ 38.58501679257934}\nmesh.rotation t {x_dd_ 0.6739999993520329_co_ y_dd_ 0.7990000362848866_co_ z_dd_ 0}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tAll there is to see amongst these numbers are that mesh.position and mesh.rotation are the same on server and client_co_  but calculating `f` via mesh.getWorldMatrix produces different results. I_t_ve attached a picture of the difference. Rays created on the clientside are rendered in white_co_ and rays created on the serverside on rendered in red. The correct result would be that the white and red rays overlap perfectly.\n_lt_/p_gt_\n\n_lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/chrome_2018-05-14_12-39-18.png.a760cb79a8a8b14ce7e7903c50131604.png_qt_ class_eq__qt_ipsAttachLink ipsAttachLink_image_qt__gt__lt_img data-fileid_eq__qt_18280_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/chrome_2018-05-14_12-39-18.thumb.png.4e09e896c85e132c11dbe7f1e802da4b.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ alt_eq__qt_chrome_2018-05-14_12-39-18.png_qt__gt__lt_/a_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-05-14T20:10:03Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo the world matrix is built from_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- position\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- rotation or rotationQuaternion\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- scaling\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- parent world matrix\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- pivotMatrix\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-14T20:35:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI *think* those are all the same for me. I_t_m not completely certain_co_ but I tried logging several things out and there were either the same_co_ close enough (floating point) or undefined.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI noticed that moving the shooting logic to after the movement logic produces a perfect synchronization. However_co_ while that does get the `forward vector` identical between server and client_co_ it is incorrect for gameplay reasons (the shot needs to occur before moving each frame_co_ not after). So I_t_ve tried moving 0_co_0_co_0 before shooting_co_ and it seems to fix everything_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_mesh.moveWithCollisions(BABYLON.Vector3.Zero())_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tFor some reason this fixes everything. I can just use that just fine... but is it indicating that I_t_ve done something else wrong?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s the full code_co_ if anyone is interested. Sorry its a bit much to read_co_ and all the key information is probably above somewhere.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_move(command_co_ tick) {\n    // primary attack\n    if (command.primary) {\n        if (this.weaponSystem.canFire()) {\n            this.weaponSystem.fire()\n            this.mesh.moveWithCollisions(BABYLON.Vector3.Zero()) // fix\n            let f _eq_ BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Forward()_co_ this.mesh.getWorldMatrix())\n            let d _eq_ f.subtract(this.mesh.position)\n            let v _eq_ d.normalize()\n            let ray _eq_ new BABYLON.Ray(this.mesh.position_co_ v_co_ 100)\n            var hit _eq_ this.scene.pickWithRay(ray_co_ (mesh) _eq_&gt_sm_ {\n                // don_t_t hit yourself\n                if (mesh _eq__eq__eq_ this.mesh) {\n                    return false\n                }\n                return true\n            })\n\n            v _eq_ hit.pickedPoint\n            if (v) {\n                // abstraction of firing logic_co_ b/c server and client do different things when they fire\n                // client_dd_ draws a debug ray\n                // server_dd_ registers damage against a player\n                this.wInterface.fire(this.id_co_ this.x_co_ this.y_co_ this.z_co_ v.x_co_ v.y_co_ v.z)\n            }\n        }\n    }\n\n    this.weaponSystem.update(command.delta)\n\n    let camVector _eq_ new BABYLON.Vector3(\n        // TODO_dd_ rename these variables to camVectorX_co_Y_co_Z_sm_ they are no longer rotations\n        command.rotationX_co_\n        command.rotationY_co_\n        command.rotationZ\n    )\n\n    this.mesh.lookAt(this.mesh.position.add(camVector.negate()))\n\n    let unit _eq_ BABYLON.Vector3.Zero()\n    if (command.forward) { unit.z +_eq_ 1 }\n    if (command.backward) { unit.z -_eq_ 1 }\n    if (command.left) { unit.x -_eq_ 1 }\n    if (command.right) { unit.x +_eq_ 1 }\n    unit.normalize()\n\n    let matrix _eq_ BABYLON.Matrix.RotationAxis(BABYLON.Axis.Y_co_ this.mesh.rotation.y)\n    let heading _eq_ new BABYLON.Vector3(\n        unit.x * this.speed * command.delta_co_\n        unit.y * this.speed * command.delta_co_\n        unit.z * this.speed * command.delta_co_\n    )\n\n    let movement _eq_ heading.clone()\n    if (command.jump) {\n        // jetpack\n        movement.y +_eq_ 10 * command.delta\n    } else {\n        // gravity-ish\n        movement.y -_eq_ 10 * command.delta\n    }\n\n    let movementVector _eq_ BABYLON.Vector3.TransformCoordinates(movement_co_ matrix)\n    this.mesh.moveWithCollisions(movementVector)\n\n    // collision against terrain\n    let y _eq_ this.scene.ground.getHeightAtCoordinates(this.mesh.position.x_co_ this.mesh.position.z)\n\n    // suspicious of this... it is movement that occurs *after* moveWithCollisions\n    // it can_t_t be 100% of the problem tho_co_ because this only occurs when resting on the ground\n    // and desync issues still occur while flying far above the mesh\n    if (this.mesh.position.y &lt_sm_ y + 0.5) {\n        this.mesh.position.y _eq_ y + 0.5\n    }\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAttached is now a picture of it working. It is a little hard to see but the red &amp_sm_ white debug-shot-tubes are overlapping perfectly now.\n_lt_/p_gt_\n\n_lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/chrome_2018-05-14_13-32-24.png.cb1986e1a82dc8441f0990f6faa341c5.png_qt_ class_eq__qt_ipsAttachLink ipsAttachLink_image_qt__gt__lt_img data-fileid_eq__qt_18282_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/chrome_2018-05-14_13-32-24.thumb.png.4cdc45449f88cdd116f382ec33093121.png_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ alt_eq__qt_chrome_2018-05-14_13-32-24.png_qt__gt__lt_/a_gt__lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-05-15T17:14:29Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tyou may be able to replace the moveWithCollisions with just mesh.computeWorldMatrix(true)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]