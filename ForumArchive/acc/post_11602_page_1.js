[{"Owner":"Ni fait ni à faire","Date":"2015-01-09T08:14:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m currently working on a _qt_fog of war_qt_ material _dd_ the standard material + a texture to keep track of once-lit areas_co_ and display them later event if they are not illuminated (because of the standard lighting model or shadowgenerator). It would produce the ~same effect as_lt_a href_eq__qt_http_dd_//static.giantbomb.com/uploads/original/0/24/10713-fog2.jpg_qt_ rel_eq__qt_external nofollow_qt__gt_ classical real-time strategy games FoW_lt_/a_gt__co_(with a moving light revealing the model) but based on actual lighting and on arbitrary UV-unwrapped models._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_However_co_ I can_t_t figure out how to write to a texture _dd_ when the shader gl_FragColor rgb component would be different from (0_co_0_co_0)_co_ it must modify the corresponding point on texture. From what I found_co_ Babylon.js_t_ DynamicTexture can be altered from the js part (as an HTML canvas)_co_ and I should rather use a Framebuffer Object_co_ but I don_t_t understand how to create and manage it from Babylon._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Sorry if this is a really noob question_co_ any clue or thought is welcome. Thanks for reading this _dd_-)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-01-09T13:57:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi!_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_m not very familiar with using render target textures (RTT) and frame buffer objects in BJS_co_ but I_t_ll try to help you nonetheless._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_First of all_co_ here is the documentation for the RTT class_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//doc.babylonjs.com/page.php?p_eq_24711_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/page.php?p_eq_24711_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_In order to achieve the FOW effet_co_ I think your best bet would be to save the _qt_hidden/shown_qt_ state of each part of the scene in a texture. Similarly to a shadow map that will tell you if the pixels rendered must be dark or clear_co_ your _qt_fog map_qt_ will tell if each pixel must be rendered or not. As such_co_ I guess the two methods will be similar._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This is what comes to my mind after thinking about it _dd__lt_/p_gt__lt_p_gt_0_dd_ initialize the fog of war map as a texture filled with black (hidden)_lt_/p_gt__lt_p_gt_1. compute the shadow map by placing the camera in place of the light source and rendering to a RTT_lt_/p_gt__lt_p_gt_2. compute the _qt_fog of war map_qt_ by rendering to a RTT using an orthographic camera facing down _dd_ every pixel seen by this camera and lit by the light source should be switched to white (visible)_co_ the others left as they are_lt_/p_gt__lt_p_gt_3. render the scene_co_ checking for each pixel if a/ it is marked as visible in the fog of war map (if no_dd_ skip) and if b/ it is lit by the light source (if no_dd_ darkens)_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The _qt_fog of war map_qt_ could then be saved and reloaded as an image with lossless compression._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_That_t_s very unrefined but I think this could work. Hope that helps to give you some ideas _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2015-01-09T19:22:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_RTT are here for this specific task _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var texture _eq_ scene.getEngine().createRenderTargetTexture(size_co_ generateMipMaps)_sm__lt_/pre_gt__lt_p_gt_Example_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#EEOWP_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#EEOWP_lt_/a_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Ni fait ni à faire","Date":"2015-01-09T19:49:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi jahow !_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_67088_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_11602_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1420811868_qt__gt__lt_div_gt__lt_p_gt_In order to achieve the FOW effet_co_ I think your best bet would be to save the _qt_hidden/shown_qt_ state of each part of the scene in a texture. Similarly to a shadow map that will tell you if the pixels rendered must be dark or clear_co_ your _qt_fog map_qt_ will tell if each pixel must be rendered or not._lt_/p_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_This is it. Although the _qt_fog map_qt_ must be permanent_co_ whereas the shadow map is regularly recreated (from what I understood_co_ may be wrong)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_67088_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_11602_qt_ data-ipsquote-username_eq__qt_jahow_qt_ data-cite_eq__qt_jahow_qt_ data-ipsquote-timestamp_eq__qt_1420811868_qt__gt__lt_div_gt__lt_div_gt__lt_br_gt__lt_p_gt_2. compute the _qt_fog of war map_qt_ by rendering to a RTT using an orthographic camera facing down _dd_ every pixel seen by this camera and lit by the light source should be switched to white (visible)_co_ the others left as they are_lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_This would be perfect for a surface (or plane model)_co_ but not for any 3D model (e.g. a sphere_co_ with a light revolving around - half the sphere would not be mapped by the orthographic camera). In my opinion_co_ the simplest (if possible) way would be to use a texture with uv coordinates (just like the diffuse texture) and write on it directly from the fragment shader. I forgot to say it doesn_t_t matter if non-visible illuminated areas are not updated on the _qt_fog map_qt_ (so the shader seems the place to do it)._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thank you for your ideas _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_(I keep scratching my head &amp_sm_ post whatever I may  find)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Ni fait ni à faire","Date":"2015-01-09T20:31:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt_ data-ipsquote-contentcommentid_eq__qt_67139_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentid_eq__qt_11602_qt_ data-ipsquote-username_eq__qt_Deltakosh_qt_ data-cite_eq__qt_Deltakosh_qt_ data-ipsquote-timestamp_eq__qt_1420831330_qt__gt__lt_div_gt__lt_div_gt__lt_p_gt_RTT are here for this specific task _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var texture _eq_ scene.getEngine().createRenderTargetTexture(size_co_ generateMipMaps)_sm__lt_/pre_gt__lt_p_gt_Example_dd__lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#EEOWP_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#EEOWP_lt_/a_gt__lt_/p_gt__lt_/div_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_! I never thought of RTT that way_co_ for me they were just _qt_additional displays_qt_ for another camera. As they can be used _qt_on_qt_ an UV-unwrapped model_co_ this is the way to go._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thank you very much to both of you._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jahow","Date":"2015-01-11T13:39:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Ok_co_ now I understand better what you want to achieve. It_t_s more complicated than what I first thought_co_ and I think it_t_s a bit out of my league..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_If I understand correctly_co_ what you_t_re actually looking to do is_dd_ for every object_co_ make a copy of the texture and replace the color (diffuse) information in it with the hidden/shown state of the texel. This would mean that you_t_d need to save_co_ for every texture used in your scene_co_ a copy of the texture with the hidden/shown data_co_ and you_t_ll be keeping and updating this new texture regularly during play._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I can_t_t think of a proper way to write the FOW data on an existing texture. Fragment shaders allow you to control &amp_sm_ modify each pixel of a rendered polygon_co_ so it will allow you to modify an existing texture_t_s color (by rendering it as a whole on a flat poly). But I don_t_t see how to fetch the _qt_lit/unlit_qt_ state of each of the texture_t_s pixels..._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ you need to take into account the fact that one pixel of the texture may be visible multiple times on a mesh._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_This may not be very helpful to you... _dd_/_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]