[{"Owner":"8Observer8","Date":"2017-06-01T10:23:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHow do you think why the attachControl doesn_t_t work in this code?\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_/// &lt_sm_reference path_eq__qt_../babylon.d.ts_qt_ /&gt_sm_\n\nnamespace LOADING\n{\n    export class LoadScene\n    {\n\t\t/*\n\t\t* Public members\n\t\t*/\n        public camera_dd_ BABYLON.ArcRotateCamera_sm_\n        public light_dd_ BABYLON.PointLight_sm_\n\n\t\t/*\n\t\t* Private members\n\t\t*/\n        private _canvas_dd_ HTMLCanvasElement_sm_\n        private _engine_dd_ BABYLON.Engine_sm_\n        private _scene_dd_ BABYLON.Scene_sm_\n\n        constructor(canvas_dd_ HTMLCanvasElement)\n        {\n            // Engine\n            this._engine _eq_ new BABYLON.Engine(canvas)_sm_\n\n            // Scene\n            this._scene _eq_ new BABYLON.Scene(this._engine)_sm_\n\n            // Camera\n            this.camera _eq_ new BABYLON.ArcRotateCamera(_qt_camera_qt__co_ 0_co_ 0_co_ 30_co_ BABYLON.Vector3.Zero()_co_ this._scene)_sm_\n            this.camera.attachControl(canvas_co_ true)_sm_\n\n            // Light\n            this.light _eq_ new BABYLON.PointLight(_qt_light_qt__co_ new BABYLON.Vector3(20_co_ 20_co_ 20)_co_ this._scene)_sm_\n            this.light.diffuse _eq_ new BABYLON.Color3(0_co_ 1_co_ 0)_sm_\n            this.light.specular _eq_ new BABYLON.Color3(1_co_ 0_co_ 1)_sm_\n            this.light.intensity _eq_ 1.0_sm_\n\n\t\t\t/**\n\t\t\t* Load an exported scene\n\t\t\t* This static method contains 6 parameters\n\t\t\t* 1_dd_ the directory of the scene file\n\t\t\t* 2_dd_ the scene file name\n\t\t\t* 3_dd_ the Babylon.js engine\n\t\t\t* 4_dd_ a success callback_co_ providing the new scene created by the loader\n\t\t\t* 5_dd_ progress callback_co_ empty as default (can be null)\n\t\t\t* 6_dd_ error callback_co_ providing the new scene created by the loader \n\t\t\t*/\n            BABYLON.SceneLoader.Load(_qt_./_qt__co_ _qt_awesome_scene.babylon_qt__co_ this._engine_co_\n                (scene_dd_ BABYLON.Scene) _eq_&gt_sm_\n                { // Success callblack\n                    this._scene _eq_ scene_sm_\n\n                    // We can now access the scene.meshes array etc.\n                    // Decal the meshes to 10 units on X\n                    for (var i _eq_ 0_sm_ i &lt_sm_ this._scene.meshes.length_sm_ i++)\n                    {\n                        console.log(this._scene.meshes[i].name)_sm_\n                        this._scene.meshes[i].position.addInPlace(new BABYLON.Vector3(10_co_ 0_co_ 0))_sm_\n                    }\n\n                    // Just append the same scene \n                    this._appendScene()_sm_\n\n                }_co_ () _eq_&gt_sm_\n                { // Progress callback\n                    // Do something with your web page _dd_)\n                }_co_ (scene_dd_ BABYLON.Scene) _eq_&gt_sm_\n                { // Error callback\n\n                })_sm_\n\n        }\n\n        /*\n        * Use graphs.The new parent of the light is the camera.\n        * Then_co_ the light_t_s position will be the same as the camera\n        */\n        public setCameraParentOfLight()_dd_ void\n        {\n            this.light.position _eq_ BABYLON.Vector3.Zero()_sm_\n            this.light.parent _eq_ this.camera_sm_\n        }\n\n\t\t/**\n\t\t* Runs the engine render loop\n\t\t*/\n        public runRenderLoop()_dd_ void\n        {\n            this._engine.runRenderLoop(() _eq_&gt_sm_\n            {\n                this._scene.render()_sm_\n            })_sm_\n        }\n\n\t\t/**\n\t\t* This method appends new scene with the already existing scene\n\t\t* Here_co_ we are appending the same scene at its original position\n\t\t*/\n        private _appendScene()_dd_ void\n        {\n            BABYLON.SceneLoader.Append(_qt_./_qt__co_ _qt_awesome_scene.babylon_qt__co_ this._scene_co_ (scene_dd_ BABYLON.Scene) _eq_&gt_sm_\n            {\n                // Do something you want\n            }_co_ () _eq_&gt_sm_\n                {\n                    // Progress\n                }_co_ (scene_dd_ BABYLON.Scene) _eq_&gt_sm_\n                {\n                    // Error\n                })_sm_\n        }\n\n\t\t/**\n\t\t* Import the skull mesh (available in the Babylon.js examples)\n\t\t* This methods imports meshes and only meshes.\n\t\t*/\n        private _importMesh()_dd_ void\n        {\n            BABYLON.SceneLoader.ImportMesh(_qt__qt__co_ _qt_./_qt__co_ _qt_skull.babylon_qt__co_ this._scene_co_\n                (meshes_co_ particles_co_ skeletons) _eq_&gt_sm_\n                { // Success callback\n                    // Here_co_ meshes contains only one mesh_dd_ the skull (meshes[0])\n                    // Particles array is empty\n                    // skeletons array is empty\n\n                }_co_ () _eq_&gt_sm_\n                { // Progress callback\n\n                }_co_ (scene_dd_ BABYLON.Scene_co_ e_dd_ any) _eq_&gt_sm_\n                {\n                    // Do something\n                    console.log(e.message)_sm_\n                })_sm_\n        }\n    }\n\n    window.onload _eq_ () _eq_&gt_sm_\n    {\n        let canvas _eq_ &lt_sm_HTMLCanvasElement&gt_sm_document.getElementById(_qt_renderCanvas_qt_)_sm_\n        let scene _eq_ new LoadScene(canvas)_sm_\n        scene.runRenderLoop()_sm_\n        scene.setCameraParentOfLight()_sm_\n    }\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"8Observer8","Date":"2017-06-01T11:23:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThis piece of code shows two cubes and a plane but not a camera_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_                    for (var i _eq_ 0_sm_ i &lt_sm_ this._scene.meshes.length_sm_ i++)\n                    {\n                        console.log(this._scene.meshes[i].name)_sm_\n                        this._scene.meshes[i].position.addInPlace(new BABYLON.Vector3(10_co_ 0_co_ 0))_sm_\n                    }\n_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"8Observer8","Date":"2017-06-01T12:16:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tA camera is not included in scene.mesh. It is because I don_t_t see it. But there is an another array where is the cameras in exported scene. The Blender is exported the cameras too. My problem is solved_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_this._scene.activeCamera _eq_ this.camera_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Wingnut","Date":"2017-06-01T12:26:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHiya 8o8... good to see you again.  Yep_co_ scene.cameras and scene.lights are where non-mesh scene items live.  Cameras and lights are _qt__lt_a href_eq__qt_http_dd_//doc.babylonjs.com/classes/2.5/node_qt_ rel_eq__qt_external nofollow_qt__gt_nodes_lt_/a_gt__qt__co_ but they are not mesh.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tGood job with self-solution!\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Fun experiment of the day_dd_  _lt_/strong_gt_When a MESH is the parent of another mesh_co_ the child _qt_inherits_qt_ all .position_co_ .rotation_co_ and .scaling values... from the parent.  But what about when the parent is a non-mesh node?  What values does the child mesh inherit... when its parent is a camera or light?  A fun and interesting experiment!  _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]