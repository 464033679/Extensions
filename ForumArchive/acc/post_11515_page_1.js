[{"Owner":"amorgan","Date":"2015-01-06T15:27:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_So_co_ where is it intended for the logic to be? I currently put my logic in the renderLoop_co_ but there is also the registerBeforeRender function. As a project gets bigger_co_ it seems like I don_t_t want to be performing all of the logic checks inside the renderLoop. Right now the way I_t_m getting around it is using the modulus of a loopCounter to acheive a different logic rate_co_ but this also has problems._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_With that_co_ where would Babylon JS like the logic to be? I kind of asked this before_co_ but felt like it should be a separate question._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Luaacro","Date":"2015-01-06T17:17:53Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Good question _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_All these functions exist for users that want to perform specific actions at specific moments._lt_/p_gt__lt_p_gt_To separate your code into different files and classes_co_ you should create one that will manage collections of specific actions._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Like_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_function Manager() {    this.beforeRenderFunctions _eq_ new Array()_sm_}Manager.prototype.runBeforeRenderFunctions _eq_ function() {    for (var i_eq_0_sm_ i &lt_sm_ this.beforeRenderFunctions.length_sm_ i++)        this.beforeRenderFunctions[i].execute()_sm_    // So_co_ each function in this.beforeRenderFunctions must implement the _qt_execute()_qt_ function}// And then somewhere in your codemyScene.registerBeforeRender(myManager.runBeforeRenderFunctions)_sm_[...]// You can use the same method for runRenderLoop by adding custom renderLoopFunctions in your// manager and then call myEngine.runRenderLoop(myManager.runRenderLoopFunctions)_sm_// Etc._lt_/pre_gt__lt_p_gt_It is a potential solution_co_ I think we can find better _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"amorgan","Date":"2015-01-06T18:35:57Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yea and that_t_s what I_t_m trying to understand_co_ is if there was a place in Babylon that was intended for taking care of _qt_game_qt_ logic. I understand the Babylone JS framework is really meant to be a 3D framework and not specifically a 3D Game framework_co_ but that is definitely a hot topic of usage. In the end I was debating on whether or not I needed to create my own manager_co_ as you suggested_co_ or if Babylon has provisions for it already_co_ that is scalable._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_My guess would be that it doesn_t_t and I should create my own._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Luaacro","Date":"2015-01-06T20:03:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Today_co_ BabylonJS doesn_t_t implement any game logic as you specify it. But it gives all the needed tools to create easily your_co_ like the manager for example._lt_/p_gt__lt_p_gt_Lets play your imagination and if you find a cool game logic_co_ you can share here and make a powerful framework _eq_D_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"amorgan","Date":"2015-01-08T15:42:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_So I_t_ve been thinking this through. I_t_m trying to understand where things should exist. I think I need to definitely create my own _qt_game_qt_ logic paradigm_co_ which I am going to try to acheive with event driven logic. Therefore_co_ thinking through what actually should go into the renderLoop_co_ besides scene.render()_co_ would be functions like moveWithCollisions. But I don_t_t know if that should live in the renderLoop function or the registerBeforeRender function. Is there a performance difference between the two? This main issue I could see is scalability._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_For example_co_ if I have 100 _qt_enemies_qt_ (meshes) that all need to be moveWithCollisions_co_ how can I loop through all of them withouth hindering the FPS? I have a current solution_co_ though I don_t_t like it. I am creating a loopCounter_co_ that increments by 1 on each pass of the renderLoop function and then I excute things on (loopCounter % x)_co_  x being the interval at which I want the condition to execute. Though_co_ with moveWithCollisions_co_ this has to be processed on each pass through the renderLoop_co_ otherwise it is choppy._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Here is a snippet of my code for what I am working_co_ this is inside the renderLoop function_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_switch (Game.engine.loopCounter) {   \tcase 1000_dd_\t\tGame.engine.loopCounter_eq_0_sm_\t\tbreak_sm_\tdefault_dd_\t\tGame.engine.loopCounter++_sm_\t\tbreak_sm_}if (Game.engine.loopCounter % 5 _eq__eq_ 0) {\t$(_t_#fps_t_).text(_t_FPS_dd_ _t_ + Game.engine.getFps().toFixed())_sm_\t//check what room the player is in\tthis.checkActiveRoom()_sm_}else if (Game.engine.loopCounter % (21 + this.enemyCounter) _eq__eq_ 0) {\tif (this.enemyCounter &gt_sm__eq_ this.activeRoom.enemy.length) { \t\tthis.enemyCounter _eq_ 0_sm_\t\t//open doors if all enemies are dead\t\tif (this.activeRoom.enemiesDead) {\t\t\tfor (var doorLoop_eq_0_sm_ doorLoop &lt_sm_ this.activeRoom.doors.length_sm_ doorLoop++) {\t\t\t\tif (this.activeRoom.doors[doorLoop].isOpen _eq__eq_ false) {\t\t\t\t\tthis.activeRoom.doors[doorLoop].mesh.checkCollisions _eq_ false_sm_\t\t\t\t\tthis.activeRoom.doors[doorLoop].mesh.isVisible _eq_ false_sm_\t\t\t\t\tthis.activeRoom.doors[doorLoop].isOpen _eq_ true_sm_\t\t\t\t\t//apply to matching door\t\t\t\t\tthis.activeRoom.doors[doorLoop].pairedDoor.mesh.checkCollisions _eq_ false_sm_\t\t\t\t\tthis.activeRoom.doors[doorLoop].pairedDoor.mesh.isVisible _eq_ false_sm_\t\t\t\t\tthis.activeRoom.doors[doorLoop].pairedDoor.isOpen _eq_ true_sm_\t\t\t\t}\t\t\t}\t\t}\t}\telse {\t\tif (this.enemyCounter _eq__eq_ 0 ) {\t\t\tthis.activeRoom.enemiesDead _eq_ this.activeRoom.enemy[this.enemyCounter].isDead_sm_\t\t}\t\telse {\t\t\tthis.activeRoom.enemiesDead _eq_ (this.activeRoom.enemiesDead &amp_sm_&amp_sm_ this.activeRoom.enemy[this.enemyCounter].isDead)_sm_\t\t}\t\tthis.activeRoom.enemy[this.enemyCounter].velocity _eq_ GetPathVector(this.activeRoom.enemy[this.enemyCounter].mesh.position_co_this.player.mesh.position_co_{speed_dd_ this.activeRoom.enemy[this.enemyCounter].speed_co_ tolerance_dd_ 12})_sm_\t\tthis.activeRoom.enemy[this.enemyCounter].mesh.rotation.y _eq_ -this.activeRoom.enemy[this.enemyCounter].velocity.angle_sm_\t\tif (this.activeRoom.enemy[this.enemyCounter].velocity.direction.x _eq__eq_ 0 &amp_sm_&amp_sm_ this.activeRoom.enemy[this.enemyCounter].mesh.enemyAnimations.animatable) {\t\t\tthis.activeRoom.enemy[this.enemyCounter].mesh.enemyAnimations.animatable.stop()_sm_\t\t\tthis.activeRoom.enemy[this.enemyCounter].mesh.enemyAnimations.animating_eq_0_sm_\t\t}\t\telse {\t\t\tthis.activeRoom.enemy[this.enemyCounter].mesh.enemyAnimations.move(this_co_this.activeRoom.enemy[this.enemyCounter])_sm_\t\t}\t\tthis.enemyCounter++_sm_\t}}processInput(this.player.mesh_co_ this.player.speed)_sm_//Need to update this every loop_co_ I guessfor (i_eq_0_sm_ i &lt_sm_ this.activeRoom.enemy.length_sm_i++) {\tthis.activeRoom.enemy[i].mesh.moveWithCollisions(this.activeRoom.enemy[i].velocity.direction)_sm_}//Render scene and any changesthis.render()_sm__lt_/pre_gt__lt_p_gt_I_t_m sure some things seems messy_co_ but definitely a work in progress._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Temechon","Date":"2015-01-08T18:30:36Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt__gt__lt_div_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_But I don_t_t know if that should live in the renderLoop function or the registerBeforeRender function. Is there a performance difference between the two? This main issue I could see is scalability._lt_/span_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It should be in registerBeforeRender. This function is here for that ! The render loop should be here only to render your scene_co_ and that_t_s it. Every other actions that should be executed all frames should be in registerBeforeRender._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Actually_co_ there is no difference between those two. registerBeforeRender is called in scene.render()._lt_/p_gt__lt_p_gt_But you can call registerBeforeRender every time you need it. The function that you gives in parameter is stored _dd_ _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_registerBeforeRender(func) {   // very simplified   actions.push(func)_sm_}_lt_/pre_gt__lt_p_gt_and then_co_ when you render your scene _dd_ _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_render() {   // very simplified again    actions.forEach(function(f) {     f()_sm_   }}_lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"amorgan","Date":"2015-01-08T18:46:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_This is very good to know! Does this method scale well? I don_t_t know enough about how the render() function and registerBeforeRender() function works_co_ I should probably dive into the code to understand it better. But it seems like it will perform all of the actions in registerBeforeRender before actually updating the screen?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Temechon","Date":"2015-01-08T19:49:44Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote data-ipsquote_eq__qt__qt_ class_eq__qt_ipsQuote_qt__gt__lt_div_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_But it seems like it will perform all of the actions in registerBeforeRender before actually updating the screen?_lt_/span_gt__lt_/div_gt__lt_/blockquote_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Exactly._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"amorgan","Date":"2015-01-08T19:52:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_That_t_s what I figured. I_t_m going to be rewriting the way I_t_m doing my logic then and see what I come up with. I would rather the mesh and logic lag_co_ then I would the render of the whole scene._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]