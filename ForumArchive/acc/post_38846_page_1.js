[{"Owner":"thrice","Date":"2018-07-14T21:43:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWondering if anyone has an example of using a spritesheet or texture atlas with instance meshes_co_ or if this could be added to the roadmap as it seems like a pretty core/important feature? (Or if it isn_t_t possible?) I_t_ve been having to do some pretty awful things in an attempt to work around the lack of support for that.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tCurrently all the examples of using a atlas/sheet that I_t_ve seen_co_ do not work with instanced meshes_co_ since when you createInstance on a mesh_co_ it is using/must use the same material. So if you modify the (uOffset_co_ vOffset_co_ uScale_co_ vScale)_co_ you are mutating the texture itself. - So I didn_t_t think it was possible_co_ but then I saw this post_dd_\n_lt_/p_gt_\n_lt_iframe allowfullscreen_eq__qt__qt_ data-controller_eq__qt_core.front.core.autosizeiframe_qt_ data-embedcontent_eq__qt__qt_ data-embedid_eq__qt_embed2725467652_qt_ scrolling_eq__qt_no_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/topic/34695-gui-performance/?do_eq_embed_qt_ style_eq__qt_height_dd_339px_sm_max-width_dd_502px_sm__qt__gt__lt_/iframe_gt_\n\n_lt_div style_eq__qt_background-color_dd_#fffffe_sm_color_dd_#000000_sm_font-size_dd_14px_sm__qt__gt_\n\tSo I thought maybe it was possible. However it looks like if you setVerticesData of an instanced mesh_co_ it mutates the source_co_ playground below for example.\n_lt_/div_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#IZACWJ%236_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#IZACWJ#6_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo is it even possible to have instanced meshes with different verticesData to benefit from the merged draw calls or not?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t--- ALSO_dd_ Does anyone happen to know if the math changed on setVerticesData calculations after babylon 2.3? I_t_ve copied code from the babylon-atlas library_co_ but it_t_s returning the wrong frame_co_ and it_t_s upside down (and the frame data is in the correct format). So hoping maybe just a simple change to get it working_co_ but math is hard.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/andyhall/babylon-atlas/blob/master/index.js#L198_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/andyhall/babylon-atlas/blob/master/index.js#L198_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-07-17T19:53:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHello! so instances in babylon.js must share everything but the world matrix with the source mesh. In your case_co_ you want to change UV so this will require specific work\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe core engine will be able to deal with that but you will have to use a custom shader as our inbox materials only support WM changes between instances.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tDoes it make sense?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tRegarding setVerticesData_co_ the only thing I remember is that we switched parameter order to make it clearer\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"thrice","Date":"2018-07-19T00:11:15Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi Delta -- it makes sense in theory_co_ however I am unsure how I would go about implementing/ tracking that. If I_t_m understanding correctly_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou are saying to use one shader material_co_ shared by many instances. In that case_co_ how would I let instance 1 know to use uOffset X and instance 2 use uOffset Y_co_ for example? Because if I_t_m using a shader material_co_ and I say for example_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tmaterial.setVector2(_t_uvOffset_t__co_ new BABYLON.Vector2(1_co_1)) \n_lt_/p_gt_\n\n_lt_p_gt_\n\tor whatever_co_ then I_t_m still going to end up modifying the shader material on all instances. Unless I am missing something?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t(also_co_ figured out the setVerticesData_co_ I didn_t_t copy over a false param from the constructor of texture as in library to invert it because I had no idea what it was doing (would love more named param constructors i.e. mesh builder style in future _lt_span_gt__lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt_ ))_lt_/span_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"thrice","Date":"2018-07-19T00:13:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\t-- That said ^_co_ I still think it would be really useful to have built in to the framework if it_t_s possible_co_ as an StandardInstancedMaterial or InstancedAtlasMaterial or something like that. Reasons being_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI tried using sprite manager_co_ but aside from the fact that I couldn_t_t use it anywhere where I wanted a non billboard mode mesh (which is probably 75% of the draw calls in my scene_co_ i.e. cards which need to be able to rotate)_co_ there were too many issues. Different (worse) rendering quality when sprites are far from camera_co_ having to track parent/position manually with onWorldMatrixUpdated_co_ translating parent size to scaling which is a hack in itself_co_ etc. But the main dealbreaker /reason I can_t_t use it at all_co_ in most places in my scene_co_ is because of lack of rotation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf there was a InstancedAtlasMaterial or whatever_co_ it would be hugely beneficial as not only could my draw calls be reduced by a huge amount (I would estimate my on average 100 draw calls I could cut in half easily_co_ and that_t_s without caching what would be really large textures like my card images at all). But the _lt_strong_gt_biggest_lt_/strong_gt_ benefit would be having a consistent API to work with_co_ i.e. not having to use a different mechanism entirely (i.e. SpriteManager_co_ or gui texture)_co_ to optimize things.\n_lt_/p_gt_\n\n_lt_p_gt_\n\talso almost all of the examples I_t_ve seen people post of using Atlases/sprites with meshes (i.e. this library _lt_a href_eq__qt_https_dd_//github.com/andyhall/babylon-atlas_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/andyhall/babylon-atlas_lt_/a_gt_ ) _co_  seem fairly pointless to me (at least for a great many use cases_co_ without something like ^)_co_ unless I am missing something. At least from my limited experience_co_ drawCalls (in general)_co_ seem like the #1 key performance indicator for optimizing speed_co_ and when using a library like the one above_co_ there is a good chance you can end up with the same number of drawCalls_co_ since you end up having to create a new mesh (or clone) for each use of the texture. (Which in almost all of my use cases_co_ creating an instanced mesh with a new texture instead of an atlas_co_ saves me way more draw calls than I would by using the atlas). -- Granted that_t_s not taking into consideration complexity of the mesh being rendered_co_ but in my scene 95% of my meshes are planes_co_ and I haven_t_t seen nearly the performance boosts from using clone+atlas compared to createInstance+nonAtlasTexture -- But point is_co_ having support for this would allow for best of both world / total draw call annihilation.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-07-19T16:32:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tFrom the point of view of a shader there is nothing to do to support instance except adding more attributes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is for isntance how we get data from mesh instances in the default shaders_dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/instancesDeclaration.fx_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/instancesDeclaration.fx_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs you can see_co_ I_t_m just adding 4 new attributes to store a matrix per instance.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe difference is in the way these attributes are added to the mesh_dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.ts#L1237_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.ts#L1237_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFirst you have to create a buffer to store the data_dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.ts#L1234_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Mesh/babylon.mesh.ts#L1234_lt_/a_gt_ and then you create vertex buffers on it.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo in your case nothing prevents us for adding a new option in this file_dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/instancesDeclaration.fx_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Shaders/ShadersInclude/instancesDeclaration.fx_lt_/a_gt_ to store more data (like uv?)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tDoes it make sense?\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"thrice","Date":"2018-07-21T16:19:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tConceptually_co_ it_t_s starting to make more sense after looking into the source code.I need to read more about shader attributes as I don_t_t think I really understood what they were doing until this point.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2018-07-21T16:42:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tBTW_co_ currently the spritesheet-like feature already works in the SPS that can be an alternative to instances _dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/how_to/solid_particle_system#colors-and-uvs_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/how_to/solid_particle_system#colors-and-uvs_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]