[{"Owner":"timetocode","Date":"2018-05-08T00:35:58Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think I may be using rotation incorrectly_co_ but I_t_m not sure what I_t_m doing wrong. I_t_d ask a more specific question_co_ but I truly have no idea how to narrow things down. So either I have a small stupid bug somewhere (could be...) or just a fundamental misunderstanding of something 3D_co_ in which case I hope someone in this forum can point it out.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI_t_ve got a multiplayer first person shooter where the game client sends its keystrokes and camera rotation to the server. This is used to rotate the player_t_s mesh (which is just a cube with a red face for forward) and then move the player around. The player is not limited to moving along the ground_co_ and can in fact just look up into the sky and press forward and fly around... so I guess they_t_re a little more like space ships that can strafe than  true first person shooter characters. Everything looked like it was working perfectly until I started comparing the client predicted positions to the server authoritative positions. Now I don_t_t mean to drag anyone down the rabbit hole of netcode_co_ and I strongly suspect my bug is something very basic relating to rotating a mesh and then trying to move it forward (or left_co_ or right_co_ or backwards).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo rotate the camera_co_ I_t_m just capturing mouse movement and multiplying by a mouseSensitivity\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_input.onmousemove _eq_ (e) _eq_&gt_sm_ {\n    if (input.isPointerLocked) {\n        camera.rotation.y +_eq_ e.movementX * mouseSensitivity\n        camera.rotation.x +_eq_ e.movementY * mouseSensitivity\n    }\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tI_t_m not sure if that is correct_co_ but it looks and feels like a first person shooter.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tEvery frame the client produces a command that looks like this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_{\n    forward_dd_ &lt_sm_Boolean&gt_sm_ input.frameState.forward_co_\n    backward_dd_ &lt_sm_Boolean&gt_sm_ input.frameState.backward_co_\n    left_dd_ &lt_sm_Boolean&gt_sm_ input.frameState.left_co_\n    right_dd_ &lt_sm_Boolean&gt_sm_ input.frameState.right_co_\n    rotationX_dd_ &lt_sm_Float32&gt_sm_ camera.rotation.x_co_\n    rotationY_dd_ &lt_sm_Float32&gt_sm_ camera.rotation.y_co_\n    rotationZ_dd_ &lt_sm_Float32&gt_sm_ camera.rotation.z_co_\n    delta_dd_ &lt_sm_Float32&gt_sm_ deltaTime\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThis contains the state of the movement-related keys_co_ and how long they_t_ve been held down (determinism note_dd_ holding _t_W_t_ for 0.187 seconds at speed 100 is a deterministic calculation which can be repeated by server and client to get the same result). It also contains the camera rotation_co_ which I_t_m wondering if this correct..? I_t_d like to note that I_t_ve used this type of command structure in several games and that it is truly deterministic_co_ but that I_t_ve never done this in 3D_co_ so perhaps my error is just the rotation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe actual movement logic\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_ move(command) {\n    // rotate the mesh to the same rotation as the camera\n    mesh.rotation.x _eq_ command.rotationX\n    mesh.rotation.y _eq_ command.rotationY\n    mesh.rotation.z _eq_ command.rotationZ\n\n    // unit vector of our movement\n    let unit _eq_ BABYLON.Vector3.Zero()\n    if (command.forward) { unit.z +_eq_ 1 }\n    if (command.backward) { unit.z -_eq_ 1 }\n    if (command.left) { unit.x -_eq_ 1 }\n    if (command.right) { unit.x +_eq_ 1 }\n    unit.normalize()\n    // rotating the unit vector to the context of this entity\n    let heading _eq_ mesh.getDirection(unit)\n\n    // full vector_co_ movement and magnitude\n    let velocityCoef _eq_ speed * command.delta\n    let velocity _eq_ heading.multiplyByFloats(velocityCoef_co_ velocityCoef_co_ velocityCoef)\n\n    // move\n    mesh.position.x +_eq_ velocity.x\n    mesh.position.y +_eq_ velocity.y\n    mesh.position.z +_eq_ velocity.z\n\n    let y _eq_ ground.getHeightAtCoordinates(mesh.position.x_co_ mesh.position.z)    \n\n    // added a little padding to keep the cube off of the ground\n    if (mesh.position.y &lt_sm_ y + 1) {\n        mesh.position.y _eq_ y + 1\n    }\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tSo the mesh gets rotated instantly to the rotation specified in the command. The command_t_s rotation is just the camera_t_s rotation. Is this a mistake..? Is copying the values of the camera_t_s rotation vector TO the player mesh rotation not in fact what I should be doing to get the player to face in the same direction as the camera?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAfter that I do that unit vector stuff which encompasses what I consider to be first person-style movement with strafes_dd_ forward_co_ backward_co_ left_co_ and right. The direction the mesh actually moves when all is said and done is calculated by mesh.getDirection_co_ and then multiplied by the velocity. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI worry about both the above ideas_co_ because I_t_ve been combing this forum looking for babylon first person shooter examples_co_ and they_t_re all different from this and from one another. None of them copy the camera_t_s rotation vector on the player_co_ and none of them use getDirection. I see other people using matrices_co_ local/global thingies_co_ getfrontposition_co_ and other properties of cameras. I feel like I_t_m missing something. And yet_co_ my game SEEMS to work pretty well. It wasn_t_t even until I started integrating the clientside prediciton layer that I started to notice that there were tiny inconsistencies with the positions of objects.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen moving the mouse and rotating the camera_co_ there are no clientside prediction errors. If the client predicts that rotationX is 0.1234_co_ the server always agrees. This is no surprise because the camera rotation is in fact client authoritative. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen hitting W A S D or the arrow keys in any combination without rotating the camera_co_ there are no clientside prediction errors. The length of any key press is known. The client produces its own local version of the movement. The server then receives the identical command and moves the player by an identical amount. At some point the client will receive a snapshot of server data that contains the state of the gameworld after having factored in the aforementioned command_co_ at which point the client will know if the movement it predicted a few frames ago lined up with the server authoritative movement. This is the actual hard part of clientside prediction and I_t_m pleased to say it is working and even supports collisions with the terrain mesh. It isn_t_t even the case that it sometimes has a mild error -- it literally never has an error_co_ and this should be expected given that there are no collisions between players_co_ so there_t_s never any unknown state to the client that could potentially cause it miscalculate a position.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHowever when moving the mouse AND holding any of the movement keys_co_ the predictions are incorrect every frame! Because of the way this engine is put together the position gets reconciled_co_ and it recovers. But what is throwing off the deterministic calculation? A.) rotate a mesh to a specific XYZ_co_ B.) find a forward vector C.) move a specific distance along that vector. I_t_m clearly not doing  A-&gt_sm_B-&gt_sm_C otherwise it would be deterministic and there would be no error.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI tried to recreate the movement code without a network_co_ and got even more confused because setting the xyz of a mesh.rotation and then using mesh.getDirection to attempt to move it forward produced no turning in the BJS playground_co_ the sphere just kept moving in one direction_dd_ _lt_a href_eq__qt_https_dd_//playground.babylonjs.com/#LD0IDK%232_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//playground.babylonjs.com/#LD0IDK#2_lt_/a_gt_. There are two spheres_co_ one remains stationary_co_ the other one is moved 3 steps by 3 commands each of which rotates the mesh before moving it forward. It ends up going straight_co_ which I don_t_t understand given that it is being rotated and that it moves in the direction it is facing (or that was my intention). So perhaps therein lines the issue_co_ though if this playground doesn_t_t work how does my game even do anything at all...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s a gif of what the camera controls and cube players look like (all of the visible cubes are bots that are sending random commands tho_co_ so never-mind they crazy directions that they_t_re facing).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a class_eq__qt_ipsAttachLink ipsAttachLink_image_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/2018-05-06_02-43-33.gif.ecab84e6d3608e175ece0a8603b5cbfc.gif_qt_ data-fileid_eq__qt_18168_qt_ rel_eq__qt__qt__gt__lt_img alt_eq__qt_2018-05-06_02-43-33.gif_qt_ class_eq__qt_ipsImage ipsImage_thumbnailed_qt_ data-fileid_eq__qt_18168_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/monthly_2018_05/2018-05-06_02-43-33.gif.ecab84e6d3608e175ece0a8603b5cbfc.gif_qt_ /_gt__lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t\t\t\n\n_lt_span class_eq__t_ipsType_reset ipsType_medium ipsType_light_t_ data-excludequote_gt_\n\t_lt_strong_gt_Edited _lt_time datetime_eq__t_2018-05-08T00_dd_44_dd_46Z_t_ title_eq__t_05/08/2018 12_dd_44  AM_t_ data-short_eq__t_May 8_t__gt_May 8_lt_/time_gt_ by timetocode_lt_/strong_gt_\n\t\n\t\n_lt_/span_gt_\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-05-08T08:27:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAfter trying multiple ways of expressing the camera direction and the movement of the player_co_ I think I_t_ve found a combination that allows for deterministic rotation+movement of the player.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSummary_dd_\n_lt_/p_gt_\n\n_lt_ul_gt_\n\t_lt_li_gt_\n\t\tcamera.getForwardRay().direction instead of camera.rotation\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tplayer mesh.lookAt a negative version of the camera forward ray instead of mesh.rotation _eq_ camera.rotation\n\t_lt_/li_gt_\n\t_lt_li_gt_\n\t\tmesh.locallyTranslate(velocity) where velocity is a representation of WASD/arrowkeys instead of mesh.getDirection\n\t_lt_/li_gt_\n_lt_/ul_gt_\n\n_lt_p_gt_\n\tThis produces something that looks and feels very similar to what I had above_co_ except that moving around while also changing direction now works without triggering any clientside prediction errors. I can_t_t say that I know why_co_ but I do suspect that what I had in my first post just sorta worked by accident_co_ possibly because the network layer was reconciling the small differences in client/server state before they got big enough to create a visual defect (maybe...)_co_ and that this new implementation is more technically correct and does not need any reconciliation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s the newer code\n_lt_/p_gt_\n\n_lt_p_gt_\n\tClientside camera and sending input to server_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_let cameraRay _eq_ this.renderer.camera.getForwardRay().direction\n\n// sending data from client to server\nthis.client.addCommand(\n    new PlayerInput(\n        input.w_co_ input.a_co_ input.s_co_ input.d_co_\n        cameraRay.x_co_ cameraRay.y_co_ cameraRay.z_co_\n        delta // this is the deltaTime for the frame in which the input occured\n    )\n)_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tThe movement code (used both for the clientside prediction_co_ and the server side movement)_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_this.mesh.lookAt(\n    this.mesh.position.add(\n        new BABYLON.Vector3(-command.rotationX_co_ -command.rotationY_co_ -command.rotationZ)_co_\n        0_co_ 0_co_ 0\n    )\n)\n// unit vector of our movement\nlet unit _eq_ BABYLON.Vector3.Zero()\nif (command.forward) { unit.z +_eq_ 1 }\nif (command.backward) { unit.z -_eq_ 1 }\nif (command.left) { unit.x -_eq_ 1 }\nif (command.right) { unit.x +_eq_ 1 }\nunit.normalize()\n\n// full vector_co_ movement and magnitude\nlet velocityCoef _eq_ this.speed * command.delta\nlet velocity _eq_ unit.multiplyByFloats(velocityCoef_co_ velocityCoef_co_ velocityCoef)\nthis.mesh.locallyTranslate(velocity)\n\nlet y _eq_ this.scene.ground.getHeightAtCoordinates(this.mesh.position.x_co_ this.mesh.position.z)\n\n// added a little padding to keep the cube off of the ground\nif (this.mesh.position.y &lt_sm_ y + 1) {\n    this.mesh.position.y _eq_ y + 1\n}_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tI_t_m going to be building two games out of this_co_ one where the player moves around a bit like a spaceship (xyz)_co_ and another where the player moves around in a standard first person way (xz). For the spaceship I_t_m just going to add controls that allow for z rotation of camera (pitch_co_yaw_co_ roll_co_ w/e its called). For the first person shooter I_t_m just going to zero out the y component of the movement and make sure the unit vector purely moves along x_co_ z with only the terrain and a jump affecting y. So if anyone has any general suggestions or tips about movement in general_co_ I_t_m all ears _lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt_.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]