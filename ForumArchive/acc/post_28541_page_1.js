[{"Owner":"BeanstalkBlue","Date":"2017-02-19T14:50:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI_t_m new to BabylonJS but one of the first things I notice is that almost all of the demos run slow (20-30 FPS is typical) on the same machine that is running three.js stuff fast.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt seems like update/draw is not being called as often as it could be_co_ as according to the debug overlay update and draw frame time is only 10ms in these same demos (so potential FPS is 100). \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAdditionally I think BabylonJS suffers from timing flaws that other JS engines do_co_ see this article_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//www.isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIn three.js I am using _lt_a href_eq__qt_https_dd_//github.com/IceCreamYou/MainLoop.js_qt_ rel_eq__qt_external nofollow_qt__gt_Mainloop.js_lt_/a_gt_ to control update/draw timing logic. I think I would like to do the same in babylon.js_co_ unless I am missing something.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo expand further_co_ physics should ideally be at a 30hz update rate in my game_co_ but draw calls and other update logic should be at 60hz. Also update logic should be called at a very consistent 60hz_co_ where draw can vary a bit from 40-60fps without real harm. (Draw lag spikes are permissible but update lag spikes should be dealt with by calling update twice to catch up and make game logic and especially physics have predictable behavior and equal time per step.)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_em_gt__lt_strong_gt_Is there a way without forking Babylon to override the update/draw timing logic?_lt_/strong_gt__lt_/em_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI notice the functions beginFrame() and endFrame() are public. Can I just call beginFrame_co_ do my render calls_co_ and then call endFrame? Will this break anything? What should _qt_do my render calls_qt_ look like?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAgain I would prefer to not modify babylon.js itself_co_ and instead just override its behavior because I don_t_t want to maintain a fork. \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2017-02-20T03:23:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tHi and welcome! Firstly_co_ BJS is a pretty mature library and the devs are quite active about adding missing features - so probably better to do forum searches and whatnot before you consider starting and maintaining a fork. _lt_img alt_eq__qt__sm_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_wink.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/wink@2x.png 2x_qt_ title_eq__qt__sm_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tAs for main loop timing_co_ yes_co_ you can ignore the default way (_lt_span style_eq__qt_color_dd_rgb(51_co_51_co_51)_sm_font-family_dd_Inconsolata_sm_font-size_dd_16px_sm_font-style_dd_normal_sm_font-weight_dd_300_sm_letter-spacing_dd_normal_sm_text-indent_dd_0px_sm_text-transform_dd_none_sm_white-space_dd_pre_sm_word-spacing_dd_0px_sm_background-color_dd_rgb(240_co_240_co_240)_sm_float_dd_none_sm__qt__gt_engine.runRenderLoop_lt_/span_gt_) and do \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    engine.beginFrame()\n    scene.render()\n    engine.endFrame()_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\taccording to any timing you like. I_t_m not sure it_t_s actually necessary for your purposes though_co_ since the default behavior drives itself from requestAnimationFrame_co_ which is what you_t_d probably want to do anyway.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tPhysics is a different matter. As far as I know BJS currently assumes that physics and rendering happen at the same rate - so it ticks the physics engine once per render_co_ and then updates all necessary mesh positions without any interpolation.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tTo decouple them_co_ I think your best be would be to ignore BJS_t_s built-in physics handling and manage your own physics world separately. In this case you_t_d want to just tick your physics engine at whatever interval_co_ and then add a scene.beforeRender() handler that moves necessary meshes to interpolated positions. (This is what I do in my project_co_ since I_t_m not using one of BJS_t_s default engines.)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-20T14:30:22Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDoes scene.render() do updating as well though?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tA big part of the problem is that I do not want update and render to tick 1_dd_1 at the exact same rate. Whenever there is a draw slowdown or update lag_co_ update needs to tick an extra time (or several times) while the game catches up. E.g._co_ if the user switches to another tab and back_co_ or if there was a garbage collection.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIf scene.render() doesn_t_t do the updating_co_ where/how do I do that?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor example in the Instances2 demo I see that animation of the meshes is done by registering a function with our animation logic into scene.registerBeforeRender()_co_ and it seems like that just gets called when we call scene.render().\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo is it safe to just make my own update() function and ignore registerBeforeRender()? Or are there other considerations to make sure updates aren_t_t happening that I don_t_t want.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tE.g. How about shadow map updating for example? I don_t_t want shadow maps to be generated every single update_co_ for some lights.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tRegarding physics decoupling_co_ I noticed actually that there is a physics setTimeStep() function that might accomplish setting physics to run at a different update rate (though I_t_m not sure if that just _qt_slows down time_qt_ in the physics sim).\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2017-02-20T16:08:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI read some of the article you reference.  I also did not like the _qt_frame based time scale_qt_ for animation.  I have built my own animation system_co_ primarily for highly integrated / choreographed animations &amp_sm_ sounds_co_ think speech.  I abandoned anything to do with  _qt_frames_qt__co_ like skeleton frame animation in favor of skeleton pose interpolation.  Everything is measured in millis.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI also have a master time control (implemented as a scene after renderer)_co_ so all participants both know _qt_when_qt_ this frame is &amp_sm_ can adjust timescale to speed up / slow down.  The master time control also detects / manages tab switches.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThink there have also been changes recently to allow some time scaling in BJS animation too.  The standard animation system_co_ I thought_co_ did adjust if it found it was running late though_co_ albeit coarse.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHave no extensive plans for physics nor knowledge. You may need to resort some kind of update loop for physics.  If you know Typescript_co_ there may alternatives to _qt_forking_qt_.  It is possible to sub-class both Scene &amp_sm_ Engine.  As long as you stick to referencing / overriding public methods &amp_sm_ properties_co_ you can use everything else without being responsible for an entire fork.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"BeanstalkBlue","Date":"2017-02-20T16:19:35Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tQuote\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\t_lt_span style_eq__qt_color_dd_rgb(39_co_42_co_52)_sm_font-family_dd__t_Helvetica Neue_t__co_ Helvetica_co_ Arial_co_ sans-serif_sm_font-size_dd_14px_sm_font-style_dd_normal_sm_font-weight_dd_normal_sm_letter-spacing_dd_normal_sm_text-indent_dd_0px_sm_text-transform_dd_none_sm_white-space_dd_normal_sm_word-spacing_dd_0px_sm_background-color_dd_rgb(255_co_255_co_255)_sm_float_dd_none_sm__qt__gt_did not like the _qt_frame based time scale_qt_ for animation_lt_/span_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tA lot of game logic can be greatly simplified by having a fixed time step for each frame. Animation of bones for example is something that is not really affected by this since generally you can just use whatever amount of time has passed to calculate current correct positions.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tSo perhaps you don_t_t like this since animation can actually be simpler using other methods_co_ but animation logic is a lot easier than physics/networking.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tFor things like physics and networking it isn_t_t so simple. Using the current amount of time since last frame to do game logic can take you deep into calculus land with challenging integrals to solve for current positions given only the amount of time since last frame.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt is much easier to keep players over the network in sync and keep physics predictable by having a fixed time step size and running update an extra time when needed to catch up_co_ if we fall behind briefly.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"fenomas","Date":"2017-02-20T19:00:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_164091_qt_ data-ipsquote-contentid_eq__qt_28541_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1487601022_qt_ data-ipsquote-userid_eq__qt_25751_qt_ data-ipsquote-username_eq__qt_BeanstalkBlue_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t3 hours ago_co_ BeanstalkBlue said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tDoes scene.render() do updating as well though?\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tAFAIK it updates everything BJS knows about - the physics engine if one is registered_co_ animations_co_ etc. And naturally it triggers frustum culling and matrix updates and all that stuff that you wouldn_t_t want to decouple from rendering. If you need to advance a particular subsystem without rendering (like ticking the physics engine several times in a row)_co_ the necessary APIs are probably there but it would depend what you_t_re trying to update.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_164091_qt_ data-ipsquote-contentid_eq__qt_28541_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1487601022_qt_ data-ipsquote-userid_eq__qt_25751_qt_ data-ipsquote-username_eq__qt_BeanstalkBlue_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t4 hours ago_co_ BeanstalkBlue said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tFor example in the Instances2 demo I see that animation of the meshes is done by registering a function with our animation logic into scene.registerBeforeRender()_co_ and it seems like that just gets called when we call scene.render().\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\tSo is it safe to just make my own update() function and ignore registerBeforeRender()? Or are there other considerations to make sure updates aren_t_t happening that I don_t_t want.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI_t_m not sure what you_t_re asking. registerBeforeRender() just does what it says on the tin - you pass it a function_co_ and that function will get called right before renders occur. Naturally you don_t_t have to put logic there_co_ you could call it right before you call render. Demos don_t_t normally drive renders manually_co_ so it_t_s easier for them to use an event.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_164091_qt_ data-ipsquote-contentid_eq__qt_28541_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1487601022_qt_ data-ipsquote-userid_eq__qt_25751_qt_ data-ipsquote-username_eq__qt_BeanstalkBlue_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t4 hours ago_co_ BeanstalkBlue said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tE.g. How about shadow map updating for example? I don_t_t want shadow maps to be generated every single update_co_ for some lights.\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI don_t_t know specifically_co_ but I strongly suspect this falls into the category of things that will by default get run every render_co_ and you_t_ll need to set a flag or something to disable them if you want to. (Naturally BJS will attempt to intelligently avoid doing unnecessary work though - so it would probably better to not worry about this until profiling shows that it_t_s affecting performance.)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_164091_qt_ data-ipsquote-contentid_eq__qt_28541_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1487601022_qt_ data-ipsquote-userid_eq__qt_25751_qt_ data-ipsquote-username_eq__qt_BeanstalkBlue_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t4 hours ago_co_ BeanstalkBlue said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tRegarding physics decoupling_co_ I noticed actually that there is a physics setTimeStep() function that might accomplish setting physics to run at a different update rate (though I_t_m not sure if that just _qt_slows down time_qt_ in the physics sim).\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tLike I said before_co_ Babylon t_lt_span style_eq__qt_color_dd_rgb(39_co_42_co_52)_sm_font-family_dd__t_Helvetica Neue_t__co_ Helvetica_co_ Arial_co_ sans-serif_sm_font-size_dd_14px_sm_font-style_dd_normal_sm_font-weight_dd_normal_sm_letter-spacing_dd_normal_sm_text-indent_dd_0px_sm_text-transform_dd_none_sm_white-space_dd_normal_sm_word-spacing_dd_0px_sm_background-color_dd_rgb(255_co_255_co_255)_sm_float_dd_none_sm__qt__gt_icks its physics engine once per render. setTimeStep sets the value Babylon passes to the engine_t_s tick() function._lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]