[{"Owner":"Feldspar","Date":"2014-04-09T16:01:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi there_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I_t_ve got some performance issues on the javascript (CPU) side. Chrome profiler gives me this _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//f.cl.ly/items/2H2W360t3A1r0K060I0n/Capture.PNG_qt_ alt_eq__qt_Capture.PNG_qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_It seems that as soon as I get some decent number of objects on my scene_co_ the bounding box computation is dominating the costs._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But since my scene is mostly static_co_ is there a way I can get things updated manually (boundingBoxes and world matrices)_co_ so when nothing moves I can get a decent framerate ?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Also_co_ it seems StandardMaterial.isReady is pretty significant in the CPU business. Any thoughts on how to cut it ? (I do exactly know when a material needs to be ready-tested) _lt_br_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-09T16:15:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_The boundingBox should not be updated if your object is not moving. There is a cache system preventing updates._lt_/p_gt__lt_p_gt_Could you check why boundingBox is updated?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_For your isReady question there are two ways_dd__lt_/p_gt__lt_p_gt_- mat.checkReadyOnEveryCall_dd_ you can set this value to true if you want to check the status of your material just once per frame (could be a good option here)_lt_/p_gt__lt_p_gt_- mat.checkReadyOnlyOnce_dd_ Once this is set_co_ the material is tested just once! Beware_co_ because materials are shared so if two objects use the StandardMaterial they can have differents options activated and if you do not check is ready for each object only the options of the first one will be taken in account._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-10T08:52:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_It seems that this.isSynchronizedWithParent always returns false whenever a mesh has a parent._lt_/p_gt__lt_div_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_    BABYLON.Node.prototype.isSynchronizedWithParent _eq_ function() {        return this.parent ? !this.parent._currentRenderId _eq__eq__eq_ this._currentRenderId _dd_ true_sm_    }_sm__lt_/pre_gt__lt_p_gt_Shouldn_t_t it be_lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_this.parent._currentRenderId _eq__eq__eq_ this._currentRenderId_lt_/pre_gt__lt_p_gt_?_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_I also fail to understand why this would work_co_ if the parent is updated before its children in a render pass_co_ _lt_em_gt_this.parent._currentRenderId _lt_/em_gt_will be higher than_lt_em_gt_ this._currentRenderId_co__lt_/em_gt_ right ?_lt_/p_gt__lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-10T15:43:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_You_t_re right it should be_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.Node.prototype.isSynchronizedWithParent _eq_ function() {        return this.parent ? this.parent._currentRenderId _eq__eq__eq_ this._currentRenderId _dd_ true_sm_    }_sm__lt_/pre_gt__lt_p_gt_I_t_ll fix it_lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_if the parent is updated before its children in a render pass_co_ _lt_/span_gt__lt_em_gt_this.parent._currentRenderId _lt_/em_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_will be higher than_lt_/span_gt__lt_em_gt_ this._currentRenderId and thus the children should be updated_lt_/em_gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-11T07:49:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Yes sure but_co_ in _lt_em_gt_computeWorldMatrix_co_ _lt_/em_gt_which is called every frame for every mesh_co_ you have this chunk of code _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_div_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_        if (!force &amp_sm_&amp_sm_ (this._currentRenderId _eq__eq_ this._scene.getRenderId() || this.isSynchronized(true))) {            this._currentRenderId _eq_ this._scene.getRenderId()_sm_            return this._worldMatrix_sm_        }_lt_/pre_gt__lt_p_gt_This implies_co_ even if the parent hasn_t_t moved_co_ its _currentRenderId will always match the current frame_t_s render id_co_ so the children will be forced to recompute their worldMatrix/bounding box even if they haven_t_t moved either (since this.isSynchronized will be false if they are updated after their parent). Am I right on this_co_ or am I missing something ?_lt_/p_gt__lt_/div_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-11T07:59:43Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I suggest this patch _dd__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_in BABYLON.Mesh.computeWorldMatrix _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_        if (!force &amp_sm_&amp_sm_ (this._currentRenderId _eq__eq_ this._scene.getRenderId() || this.isSynchronized(true))) {            return this._worldMatrix_sm_        }        this._currentRenderId _eq_ this._scene.getRenderId()_sm__lt_/pre_gt__lt_p_gt_And in BABYLON.Node.isSynchronizedWithParent _dd_ _lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_        return this.parent ? this.parent._currentRenderId &lt_sm__eq_ this._currentRenderId _dd_ true_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-11T15:41:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I published a patch for this one on the github. COuld you have a look? (This is almost the same thing as what you suggested _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_)_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-14T08:31:28Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I may be wrong but I still see a problem with your patch._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Say we update the parent on frame 100_co_ _lt_em_gt_parent._currentRenderId_lt_/em_gt_ will be set to 100._lt_/p_gt__lt_p_gt_Then we move the child on frame 200_co_ _lt_em_gt_this._currentRenderId_lt_/em_gt_ will be set to 200._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Now_co_ in all the subsequent render frames_co_ _lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt__lt_em_gt_BABYLON.Node.isSynchronizedWithParent_lt_/em_gt_ will return false_co_ and the child will be force updated in every frame_co_ setting its _lt_em_gt__currentRenderId _lt_/em_gt_to 201_co_ 202_co_ 203_co_ etc.._lt_/span_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_span style_eq__qt_color_dd_rgb(40_co_40_co_40)_sm_font-family_dd_helvetica_co_ arial_co_ sans-serif_sm__qt__gt_That was why I suggested _dd__lt_/span_gt__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_return this.parent ? this.parent._currentRenderId &lt_sm__eq_ this._currentRenderId _dd_ true_sm__lt_/pre_gt__lt_p_gt_- If the parent _lt_em_gt__currentRenderId _lt_/em_gt_is strictly greater than its children_co_ then the children MUST be updated to move along with the parent._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_- But if the parent _lt_em_gt__currentRenderId _lt_/em_gt_is lower the child_t_s _lt_em_gt__currentRenderId_co_ _lt_/em_gt_it just means that the parent has not moved for a certain amount of frames_co_ the synchronization is fine_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-14T16:59:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If you update the parent on frame 100 then the children will also be updated on frame 100 and then it will receive renderId_eq__eq_100_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-15T08:00:16Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I agree with that_co_ but what if you move the child on frame 200 without moving the parent ? Every render loop will then force update the children since 200 !_eq_ 100 then 201 !_eq_ 100 then 202 !_eq_ 100 etc...._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-15T20:16:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_You are right _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ I will update the code for 1.11_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"gwenael","Date":"2014-04-16T09:17:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I may able to go back to my code for _lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/3083-spaces-world-parent-pivot-local/?p_eq_25263_qt__gt_http_dd_//www.html5gamedevs.com/topic/3083-spaces-world-parent-pivot-local/?p_eq_25263_lt_/a_gt__lt_/p_gt__lt_p_gt_I had a bug and maybe it was relative to what you discuss on here._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-16T16:17:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I pushed a working version theoretically _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Feldspar","Date":"2014-04-17T12:34:11Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_That seems good _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt_ Thanks_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]