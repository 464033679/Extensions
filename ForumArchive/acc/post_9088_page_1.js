[{"Owner":"JCPalmer","Date":"2014-09-09T18:52:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have been working with Ludei support to get BabylonJS to work for Andoid &amp_sm_ iOS.  The basic problem is that Babylon ends up thinking the size to draw in is 0 by 0.  For the conversation see_dd_ _lt_a href_eq__qt_http_dd_//support.ludei.com/hc/communities/public/questions/200763155-Trying-to-get-BabylonJS-to-work_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//support.ludei.com/hc/communities/public/questions/200763155-Trying-to-get-BabylonJS-to-work_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_According to their software my devicePixelRatio must be 2.  There is code in Engine to define hardwareScalingLevel_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_this._hardwareScalingLevel _eq_ 1.0 / (window.devicePixelRatio || 1.0)_sm__lt_/pre_gt__lt_p_gt_Then client height &amp_sm_ width are divided by hardwareScalingLevel to define the size to draw to in Engine.resize().  If no one has ever run Babylon on a device where the devicePixelRatio !_eq_ 1_co_ we could have a bug on this side as well.  _lt_strong_gt_Should the clientWidth &amp_sm_ clientHeight be divided or multiplied by hardwareScalingLevel?_lt_/strong_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_clientWidth &amp_sm_ clientHeight both return 0_co_ which is another problem.  It does not seem that is supported there.  Using a hack they came up with_co_ I built a babylon.js where the sample scene worked fine.  We just to sort this out._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-09-10T00:25:26Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I think someone already tested this and had no issue but I cannot find the discussion anymore_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Did you try with Chrome or IE with woom set to 150%. This should be the same thing. _lt_br_gt_ _lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"JCPalmer","Date":"2014-09-14T18:07:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_No I did not zoom those_co_ but I do not think that zoom is the same thing_co_ if it works the same way as Safari does.  I have a non-Retina MacPro.   When I zoom a babylon canvas the whole page just magnifies and crops.  I do not think it is changing the device pixel ratio or babylon even knows about the change.  I thought device pixel ratio is for tablets and the newer Macs with retina display.  For those_co_ basically the browser clientWidth/height is returned as DIPs not pixels_co_ so stuff like text does not get sized too small to see well. _lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thinking about this_co_ Babylon is geared for the dynamic sizing that can occur on a desktop / laptop browser.  This achieved by using CSS styles which specify the canvas_t_s size in percentages.  When the user re-sizes the browser window a resize event occurs.  If a listener is put into the html_co_ babylon will recalculate the new size.  None of this ever occurs on a tablet.  There are no windows._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_CocoonJS does NOT use CSS for it_t_s accelerated Canvas+_co_ so right off the bat the same html as for a desktop cannot be used.  A good strategy might to limit all differences just to the launch html._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_The first thing to remove from the html_co_ in addition to the CSS % sizing_co_ should be the isSupported() test.  Ludei said only 1 canvas is ever actually created with the first getContext() call to a previously sized canvas.  I proved that was true by creating a context as _t_2d_t_ before creating an Engine &amp_sm_ the thing just crashed.  isSupported() is a test done by creating a _t_webgl_t_ context on an un-size canvas that get thrown away.  You are screwed if you call isSupported().  I also saw Engine has a _workingCanvas &amp_sm_ _workingContext.  The things this is used for like video textures &amp_sm_ cube textures are unlikely to ever work on CocoonJS as is._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_CocoonJS also does not look like it even supports clientWidth/height_co_ since after all there are no scrollbars with a canvas.  clientWidth/height result in zeros.  That means even if you called Engine.setHardwareScalingLevel(1)_co_ you will still end up with a 0 sized drawing area._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Rather than explicitly supporting CocoonJS_co_ maybe this is another job for the _t_Rename - Wrapper_t_ trick_co_ like I used to make SceneLoader.Append().  Take the existing Engine.resize()_co_ and change the name to setSize() giving it parameters width &amp_sm_ height.  Create a wrapper called resize() which does the same calc as before_co_ then calls setSize() to actually implement.  After you instance Engine_co_ just call setSize() &amp_sm_ pass it anything you want. (You need to do this correct for the resize() being called in the Engine constructor).  This takes care or any weird hardware you wish to support_co_ as discussed in this phaser thread._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt__lt_a href_eq__qt_http_dd_//www.html5gamedevs.com/topic/3980-common-phaser-cocoonjs-issues/?hl_eq_initial-scale_qt__gt_http_dd_//www.html5gamedevs.com/topic/3980-common-phaser-cocoonjs-issues/?hl_eq_initial-scale_lt_/a_gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Automaton is definately a higher priority for me.  (Ben from the Ludei thread_dd_  start _t_Gulping_t_ your own fork if this is a problem).  If setSize() is put in_co_ I_t_ll probably add a new .html output file to Tower of Babel_co_ xxx_cocoonjs.html.  It would use the inline .js not .babylon.   CocoonJS is the actual reason for TOB.  At the time_co_ a .babylon file would not even load without a web server.  There is also no need to do incremental loading or put up progress bars here.  All downloading occurred when it was gotten from the store.  It might make no difference on fast desktops_co_ but the javascript parser is C++.  There is no way a parser written in javascript is faster than C++._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]