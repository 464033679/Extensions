[{"Owner":"timetocode","Date":"2018-10-30T00:47:07Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tCould someone explain a little bit about how meshes are positioned and when this information is on the CPU vs the GPU? How do animations affect this?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI used to think that all movement was essentially changing the position_co_ rotation_co_ or scale of a mesh on the CPU_co_ and then that this information would be sent to the GPU for rendering. But I_t_ve recently learned that bone-based animations leverage GPU_co_ which implies to me that the rendered position of a mesh (when using bone animations) is not going to be the same as that mesh position as set in our javascript code. Is that true?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI ask because I_t_m doing a lot of movement of objects in NullEngine (where this is no rendering) and I_t_m trying to very accurately sync the transforms of meshes across a network. Everything is working great so far_co_ but I am doing my animations somewhat tediously on the CPU to reduce any potential errors (100% transform-based in javascript_co_ no rigs/bones/animations).\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s a rough version of the type of code being used to move things_co_ but I am curious to what degree bones and other types of animations can be used.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_span style_eq__qt_background-color_dd_#ffffff_sm_color_dd_#444444_sm_font-size_dd_13px_sm__qt__gt__lt_a href_eq__qt_https_dd_//www.babylonjs-playground.com/#YYH1CJ%2313_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.babylonjs-playground.com/#YYH1CJ#13_lt_/a_gt_  (shows 100% babylon-based animation... just using the transforms)_lt_/span_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"NasimiAsl","Date":"2018-10-30T10:42:04Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tfor make optimize GPU always better than CPU\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthink about object that have more than 100k vertex\n_lt_/p_gt_\n\n_lt_p_gt_\n\tand you wanna control then by CPU with all condition in each frame ? (in some mobile device_t_s that is not impossible but GPU can do that easily )\n_lt_/p_gt_\n\n_lt_p_gt_\n\tfor rig+skeletons after animation converted to transform matrix ( in cpu side ) in each frame Engine just send a frame matrix to shader  that is how GPU control that\n_lt_/p_gt_\n\n_lt_p_gt_\n\t** we can make full GPU animation system too but that is so complicated \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-10-30T14:57:32Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOnly bones and morph targets are done on GPU side. Everything else is done by the CPU and thus you should not have big issues synchronizing over network.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBones can be forced on CPU with mesh.computeBonesUsingShader _eq_ false but this will be a major drawback on your performance\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-10-31T00:07:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThanks for the replies._lt_br /_gt_\n\t_lt_br /_gt_\n\tPerhaps someone could advise from a babylon perspective about lag compensation shots in a first person shooter. I_t_ll explain the network part_co_ so we can narrow the topic down just to ideas of how to use babylon in this context.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI did something like this in the past and posted on this forum_co_ but this time I_t_ve made a much more complicated character with multiple body parts and animations and the hit detection can hit any part of the body and report it accurately.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI save the positions of each body part of the player character which provides me the ability to rewind to any past position. I have a working prototype of this. It is possible to have multiple players running and jumping and still land shots in the head_co_ or the hand_co_ or anywhere_co_ at pings from 10 ms to 500 ms.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Animations_lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThese have been discussed a little already. They_t_re entirely made by parenting one part to another and moving them in an update loop. Stuff like lowerLeftArm.rotation.x +_eq_ Math.PI * 2 * deltaTime. From what I_t_m understanding so far_co_ this isn_t_t the best for performance_co_ but given my goals maybe this is the best way...? Any other way of doing this would have to be compatible with the network rewind stuff down below. In the end my character is very simple and minecraft-esque_co_ but I am hoping to enrich it with a large number of animations. I remain unclear as to the degree which changing to bones would be superior. Will these actually move in NullEngine or is it GPU only?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Saving Snapshots of Body Positions_lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThe game doesn_t_t need to save everything about the transforms_co_ just a few things. Every pose+animation so far can be achieved by changing ~20 variables. This is mostly thanks to babylon_t_s ability to parent meshes to each other_co_ so I don_t_t have to bother with setting every single transform property.. usually just the rotation of x or y is sufficient to make something like a bending elbow. ( _lt_a href_eq__qt_https_dd_//www.youtube.com/watch?v_eq_a8Gdt5Qeo1Q_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//www.youtube.com/watch?v_eq_a8Gdt5Qeo1Q_lt_/a_gt_ ) My video really doesn_t_t show how much everything can blend into everything else_co_ but there is also jumping_co_ aiming down sights_co_ and the upper body and lower body can be doing very different things.  These 20 variables are what get saved/networked and can deterministically put the character into any of its possible poses (and everything in between). I_t_m on the fence as to whether doing something more conventional with network messages such as _qt_startAimDownSightsAnimation_qt_ would actually be compatible with blending multiple other animations and being rewound/replayed. If I could get something like that fully deterministic_co_ it would certainly save some bandwidth.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_strong_gt_Rewinding and Checking Collisions_lt_/strong_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere_t_s where things get pretty weird. I run a ray through the *past* state of the game and see what it hits. Using nengi.js (network lib) I obtain the past positions of all characters in the vicinity of the shot. This required some creativity in babylon_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_// note_dd_ instance comes from the networking lib api\n// REWIND\nconst pastStates _eq_ instance.historian.getLagCompensatedArea(latency + 100_co_ area)\npastStates.forEach(pastState _eq_&gt_sm_ {\n    // getting the current version of the entity\n    const current _eq_ instance.entities.get(pastState.id)\n\n    // don_t_t rewind ourself_co_ that would mess up the shot\n    if (isMe(current)) { return }\n\n    // move the entity to a past position\n    Object.assign(current_co_ pastState) // uses get/set to modify transforms\n\n    // dummy mesh to which the player model is attached\n    current.node.computeWorldMatrix(true)\n    // individual body parts of the player model\n    current.model.head.computeWorldMatrix(true)\n    current.model.torso.computeWorldMatrix(true)\n    // etc for all 12 body parts\n})\n\n// HIT CHECK\n// the predicate allows only hits against\n// 1_dd_ the map geometry\n// 2_dd_ players that aren_t_t ourself\nconst predicate _eq_ () _eq_&gt_sm_ { /* skipped */ }\nconst hit _eq_ scene.pickWithRay(ray_co_ predicate)\nconsole.log(_t_scored a hit in the_dd__t__co_ hit.pickedMesh.tag)\n// e.g. _qt_scored a hit in the_dd_ leftHand_qt_\n\n// NOT shown_dd_ unrewind - restore the character to the correct position_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tConcerns and questions_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI had to invoke computeWolrdMatrix on just about everything before the meshes seemed to be in a new position.  All of this occurs essentially instantly and *between* rendering ticks...so that makes sense right?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIs this an appropriate way to use the scene and quickly check collisions? I figured rewinding the entities in the existing scene and re computing their matrices was a way to avoid creating entirely new meshes or scenes.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat kind of optimization should I consider as I add buildings and generally a ton more stuff to the scene? Babylon_t_s Octrees? Multiple scenes / some sort of custom spatial structures?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNullEngine is extremely awesome btw.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThanks _lt_img alt_eq__qt__dd_D_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_biggrin.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/biggrin@2x.png 2x_qt_ title_eq__qt__dd_D_qt_ width_eq__qt_20_qt_ /_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-10-31T16:01:01Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_233320_qt_ data-ipsquote-contentid_eq__qt_40947_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1540944454_qt_ data-ipsquote-userid_eq__qt_12667_qt_ data-ipsquote-username_eq__qt_timetocode_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t15 hours ago_co_ timetocode said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents ipsClearfix_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tAll of this occurs essentially instantly and *between* rendering ticks...so that makes sense right?\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tYes sir! This is a good way to check collisions\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOctrees will be your next step if you have a lot of meshes_dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees_qt_ ipsnoembed_eq__qt_true_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\tQuote\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents ipsClearfix_qt__gt_\n\t\t_lt_p_gt_\n\t\t\t_lt_span style_eq__qt_background-color_dd_#ffffff_sm_ color_dd_#353c41_sm_ font-size_dd_14px_sm_ text-align_dd_start_qt__gt_NullEngine is extremely awesome btw._lt_/span_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tThank you_dd_)\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-11-01T07:17:38Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIs there an example of manual usage of the octree? I can_t_t figure out what the _creationFunc needs to be. Also not sure about addMesh(mesh) vs update(start_co_ end_co_ meshes).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tGoal would be essentially something like this_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_const broadphaseOctree _eq_ new Octree(null_co_ 64_co_ 2)_sm_\nshootableStuff.forEach(mesh _eq_&gt_sm_ {\n  octree.addMesh(mesh)_sm_\n})\n\n// the meshes contained in the octree nodes touched by the ray\nconst broadPhaseObjects _eq_ broadphaseOctree.intersectsRay(shotRay)_sm_\n\n// and then doing ray vs mesh collision checks to what got actually hit_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"timetocode","Date":"2018-11-01T08:23:08Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tNever mind_co_ finally found the code (for some reason github searching does not seem to find things).\n_lt_/p_gt_\n\n_lt_p_gt_\n\tManual usage_dd__lt_br /_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_// test meshes\nconst boxes _eq_ []\nfor (let i _eq_ 0_sm_ i &lt_sm_ 10000_sm_ i++) {\n    const box _eq_ BABYLON.MeshBuilder.CreateBox(_t_myBox_t__co_ { height_dd_ 15_co_ width_dd_ 15_co_ depth_dd_ 15 }_co_ scene)\n    box.position.x _eq_ Math.random() * 100\n    box.position.y _eq_ Math.random() * 20\n    box.position.z _eq_ Math.random() * 100\n    boxes.push(box)\n}\n\n\nconst octree _eq_ new BABYLON.Octree(BABYLON.Octree.CreationFuncForMeshes_co_ 64_co_ 2)\n\n// adding meshes\noctree.update(new BABYLON.Vector3(0_co_ 0_co_ 0)_co_ new BABYLON.Vector3(100_co_ 20_co_ 100)_co_ boxes)\n\n// ray\nconst stuff _eq_ octree.intersectsRay(someRay_co_ false)\n\n// sphere\nconst stuff2 _eq_ octree.intersects(sphereCenterVector3_co_ sphereRadius_co_ false)_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2018-11-01T14:58:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tGood catch!\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]