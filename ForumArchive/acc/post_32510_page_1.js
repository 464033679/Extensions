[{"Owner":"MackeyK24","Date":"2017-08-22T11:37:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tDoes anyone know how to tell/check if the object the physics state attach to is _t_grounded_t_ or _t_airborne_t_...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI need to check if I_t_m on the ground for movement and jumping... Unity has a CharacterController.isGrounded flag they use to check for such things.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tDo we have ANYTHING like that so I can check if my player character is grounded or airborne ???\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYo _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ yet another one for ya _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"barbara","Date":"2017-08-22T12:44:42Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tAre you using phaser? In that case i think that what you are looking for is_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tif(sprite.touching.down){ doSomething}\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"adam","Date":"2017-08-22T19:48:55Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think you_t_re going to have to determine if the body is grounded by observing collisions.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou can use PhysicsImposter.registerOnPhysicsCollide_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Physics/babylon.physicsImpostor.ts#L320_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Physics/babylon.physicsImpostor.ts#L320_lt_/a_gt_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"MackeyK24","Date":"2017-08-23T00:35:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI saw the collide.... I actually use that for all my physics collision... But seems expensive to collide with everything to see if I_t_m grounded or not.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat I am actually trying to do is create some _qt_Downloadable Content_qt_ for the Toolkit... So far I got Particle systems and material libraries done.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tBut now I am try to create a _t_MovementController_t_ class ... which will function like the Unity CharacterController... It is responsible for all the movement and meant to be used by other components... So you could attach a MovementController to an object and then create a PlayerController that has the main player logic and use this.getComponent(_qt_BABYLON.MovementController_qt_) from the player controller to get reference to movement controller and do whatever... Just like you would in a unity game... I also added AUTO User input support right on the Movement controller to actually handle getting the user input and moving accordingly.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have TWO problems I gotta work out... First... I Gott a tell when I_t_m on the ground (or grounded) I need this to NOT allow DOUBLE JUMPING in the air...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tAlso I want the player to lookAt the horizontal and vertical direction the user input is... So I use mesh.lookAt ... BUT IT SNAPS TO THAT ROTATION to look at\n_lt_/p_gt_\n\n_lt_p_gt_\n\tthe direction... its way too fast look funny to SNAP from left to right instead of rotating a little slower....  _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ got any ideas for me here _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tHere is my current MovementController.ts script design to be attached to ANY _t_Actor_t_ to give movement... Please look at how I could check to see if grounded or ANY OTHER WAY to handle jumping... And what can I do about the mesh.lookAt so it does not SNAP to that look at direction but rotates to that direction...\n_lt_/p_gt_\n\n_lt_p_gt_\n\tThink Third-Person Controller _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\tMovementController_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_/* Babylon Character Movement Controller Component */\n/* &lt_sm_reference path_eq__qt_{*path*}/Assets/Babylon/Library/babylon.d.ts_qt_ /&gt_sm_ */\n\nmodule BABYLON {\n    export class MovementController extends BABYLON.MeshComponent {\n        public enableInput_dd_boolean _eq_ true_sm_\n        public autoTurning_dd_boolean _eq_ true_sm_\n        public moveSpeed_dd_number _eq_ 5.0_sm_\n        public jumpForce_dd_number _eq_ 5.0_sm_\n        public dropForce_dd_number _eq_ 20.0_sm_\n        public rotateSpeed_dd_number _eq_ 0.085_sm_\n        public isGrounded()_dd_boolean { return this._grounded_sm_ }\n        public getVelocity()_dd_BABYLON.Vector3 { return this._movementVelocity_sm_ }\n        public onUpdateMovement_dd_(velocity_dd_BABYLON.Vector3_co_ horizontal_dd_number_co_ vertical_dd_number_co_ mousex_dd_number_co_ mousey_dd_number_co_ jumped_dd_boolean)_eq_&gt_sm_void _eq_ null_sm_\n\n        private _grounded_dd_boolean _eq_ true_sm_\n        private _inputVelocity_dd_BABYLON.Vector3 _eq_ BABYLON.Vector3.Zero()_sm_\n        private _movementVelocity_dd_BABYLON.Vector3 _eq_ BABYLON.Vector3.Zero()_sm_\n        public constructor(owner_dd_ BABYLON.AbstractMesh_co_ scene_dd_ BABYLON.Scene_co_ tick_dd_ boolean _eq_ true_co_ propertyBag_dd_ any _eq_ {}) {\n            super(owner_co_ scene_co_ tick_co_ propertyBag)_sm_\n            this.autoTurning _eq_ this.getProperty(_qt_autoTurning_qt__co_ true)_sm_\n            this.moveSpeed _eq_ this.getProperty(_qt_moveSpeed_qt__co_ 5.0)_sm_\n            this.jumpForce _eq_ this.getProperty(_qt_jumpForce_qt__co_ 5.0)_sm_\n            this.dropForce _eq_ this.getProperty(_qt_dropForce_qt__co_ 20.0)_sm_\n            this.rotateSpeed _eq_ this.getProperty(_qt_rotateSpeed_qt__co_ 0.085)_sm_\n            this.enableInput _eq_ this.getProperty(_qt_enableInput_qt__co_ true)_sm_\n        }\n\n        public move(velocity_dd_BABYLON.Vector3)_dd_void {\n            this._movementVelocity.x _eq_ velocity.x_sm_\n            this._movementVelocity.y _eq_ velocity.y_sm_\n            this._movementVelocity.z _eq_ velocity.z_sm_\n            this.manager.moveWithPhysics(this.mesh_co_ velocity)_sm_\n        }\n\n        protected after() _dd_void {\n            var ground_dd_number _eq_ 2.0_sm_ // TODO_dd_ Get Physics Grounded\n            this._grounded _eq_ !(this.mesh.position.y &gt_sm_ ground)_sm_ \n            if (this.enableInput _eq__eq__eq_ true) {\n                var horizontal_dd_number _eq_ this.manager.getUserInput(BABYLON.UserInputAxis.Horizontal)_sm_\n                var vertical_dd_number _eq_ this.manager.getUserInput(BABYLON.UserInputAxis.Vertical)_sm_\n                var mousex_dd_number _eq_ this.manager.getUserInput(BABYLON.UserInputAxis.MouseX)_sm_\n                var mousey_dd_number _eq_ this.manager.getUserInput(BABYLON.UserInputAxis.MouseY)_sm_\n                var gravity_dd_number _eq_ this.dropForce * this.manager.deltaTime_sm_\n                var jumped_dd_boolean _eq_ false_sm_\n                // Avatar movement and jumping velocity\n                if (this._grounded _eq__eq__eq_ true) {\n                    var jump1_dd_boolean _eq_ this.manager.getKeyInput(BABYLON.UserInputKey.SpaceBar)_sm_\n                    var jump2_dd_boolean _eq_ this.manager.getButtonInput(BABYLON.Xbox360Button.A)_sm_\n                    this._inputVelocity.x _eq_ horizontal * this.moveSpeed_sm_\n                    this._inputVelocity.z _eq_ vertical * this.moveSpeed_sm_\n                    if ((jump1 || jump2) &amp_sm_&amp_sm_ this.jumpForce &gt_sm_ 0.0) {\n                        jumped _eq_ true_sm_\n                        this._inputVelocity.y _eq_ this.jumpForce_sm_\n                    }\n                } else {\n                    this._inputVelocity.y -_eq_ gravity_sm_\n                }\n                // Update avatar movement handler\n                if (this.onUpdateMovement !_eq_ null) {\n                    this.onUpdateMovement(this._inputVelocity_co_ horizontal_co_ vertical_co_ mousex_co_ mousey_co_ jumped)_sm_\n                }\n                // Update avatar position and rotation\n                this.move(this._inputVelocity)_sm_\n                if (this.autoTurning _eq__eq__eq_ true &amp_sm_&amp_sm_ (horizontal !_eq__eq_ 0.0 || vertical !_eq__eq_ 0.0)) {\n                    // TODO_dd_ Rotate actor to face horizontal and vertical movement direction\n                    this.mesh.lookAt(this.mesh.position.add(new BABYLON.Vector3(-horizontal_co_ 0.0_co_ -vertical)))_sm_\n                }\n            }\n        }\n    }\n}\n_lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhat do you think ???\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"MackeyK24","Date":"2017-08-23T02:44:25Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_blockquote class_eq__qt_ipsQuote_qt_ data-ipsquote_eq__qt__qt_ data-ipsquote-contentapp_eq__qt_forums_qt_ data-ipsquote-contentclass_eq__qt_forums_Topic_qt_ data-ipsquote-contentcommentid_eq__qt_186408_qt_ data-ipsquote-contentid_eq__qt_32510_qt_ data-ipsquote-contenttype_eq__qt_forums_qt_ data-ipsquote-timestamp_eq__qt_1503431335_qt_ data-ipsquote-userid_eq__qt_4289_qt_ data-ipsquote-username_eq__qt_adam_qt__gt_\n\t_lt_div class_eq__qt_ipsQuote_citation_qt__gt_\n\t\t6 hours ago_co_ adam said_dd_\n\t_lt_/div_gt_\n\n\t_lt_div class_eq__qt_ipsQuote_contents_qt__gt_\n\t\t_lt_p_gt_\n\t\t\tI think you_t_re going to have to determine if the body is grounded by observing collisions.\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\tYou can use PhysicsImposter.registerOnPhysicsCollide_dd_\n\t\t_lt_/p_gt_\n\n\t\t_lt_p_gt_\n\t\t\t_lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Physics/babylon.physicsImpostor.ts#L320_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Physics/babylon.physicsImpostor.ts#L320_lt_/a_gt_\n\t\t_lt_/p_gt_\n\t_lt_/div_gt_\n_lt_/blockquote_gt_\n\n_lt_p_gt_\n\tI use this in other places to detect collision so I know where to set it up... Also I found the THREE.JS/CANNON source for _qt_CanJump_qt_ flag_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_ var canJump _eq_ false_sm_\n\n    var contactNormal _eq_ new CANNON.Vec3()_sm_ // Normal in the contact_co_ pointing *out* of whatever the player touched\n    var upAxis _eq_ new CANNON.Vec3(0_co_1_co_0)_sm_\n    cannonBody.addEventListener(_qt_collide_qt__co_function(e){\n        var contact _eq_ e.contact_sm_\n\n        // contact.bi and contact.bj are the colliding bodies_co_ and contact.ni is the collision normal.\n        // We do not yet know which one is which! Let_t_s check.\n        if(contact.bi.id _eq__eq_ cannonBody.id)  // bi is the player body_co_ flip the contact normal\n            contact.ni.negate(contactNormal)_sm_\n        else\n            contactNormal.copy(contact.ni)_sm_ // bi is something else. Keep the normal as it is\n\n        // If contactNormal.dot(upAxis) is between 0 and 1_co_ we know that the contact normal is somewhat in the up direction.\n        if(contactNormal.dot(upAxis) &gt_sm_ 0.5) // Use a _qt_good_qt_ threshold value between 0 and 1 here!\n            canJump _eq_ true_sm_\n    })_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tIll try and mess with that... Thanks for the info... Ill let ya know how it works _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt__lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]