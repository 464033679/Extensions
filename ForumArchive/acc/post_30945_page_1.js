[{"Owner":"Fedor","Date":"2017-06-09T04:39:14Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWorking on my sculpting tool with 50K vertices_co_ I am still researching ways to modify the vertices as fast as possible. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tAs I understand it now_co_ the methods meshes offer to modify the geometry do the following_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- setVerticesData - creates a new array and does a copy of the given buffer\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- updataVerticesData - only copies the buffer.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- The ApplyToMesh from VertexData copies all the buffers to the mesh \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI just found the _geometry-property of the mesh_co_ which seems to hold all buffers. So I started testing modifying them directly.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen I modify the color buffer (base_model.mesh._geometry._vertexBuffers.color._buffer._data) nothing happens. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy guess is I need something to trigger the buffer to be fed to WebGl. Does anyone know how to pull this trigger?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-09T07:08:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tthis one is fast (used in the SPS and can change colors_co_ positions_co_ uvs_co_ normals_co_ etc of thousands of vertices per frame) _dd_ _lt_a href_eq__qt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticleSystem.ts#L826_qt_ rel_eq__qt_external nofollow_qt__gt_https_dd_//github.com/BabylonJS/Babylon.js/blob/master/src/Particles/babylon.solidParticleSystem.ts#L826_lt_/a_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-09T07:20:24Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tIs it in my case?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI red it copies the given buffer. I can imagine that would be very fast in cases where many vertices are changed at once. But when changing only a handful of vertices per rendering pass_co_ copying the entire buffer would be a lot of overhead. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am sure it is the fastest of all the _t_official_t_ methods that are now available. But could there be a hack that allows me to directly write the buffers WebGL uses. Or even better_co_ could there be a method to do this in the future.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-09T07:36:05Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWell... interesting approach.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNevertheless be careful because BJS provides a cache mechanism_co_ so skipping it can lead to weird results sometimes.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-09T07:53:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI am aware that hacking can lead to unforseen or even unwanted results. I am hoping someone will stop by who can help me a) get it to work and b) prevent some problems... _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-09T15:00:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI can help only if you provide a repro _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ (in the PG)\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-09T15:30:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOk_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tHere is a simple exampe_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#YVA9CM%231_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#YVA9CM#1_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI take the custom mesh from the manual _t_Creating Custom Meshes_t_. At creation time the first vertice is blue and the second is green. I then try to change the color of the second vertice as follows_dd_\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_    colorbuffer_eq_customMesh._geometry._vertexBuffers.color._buffer._data_sm_\n    idx_eq_2\n        colorbuffer[idx*4]_eq_1_sm_\n        colorbuffer[idx*4+1]_eq_0_sm_\n        colorbuffer[idx*4+2]_eq_0_sm_\n        colorbuffer[idx*4+3]_eq_1_sm__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tI would expect the second vertice to be red now. But as you see it isn_t_t\n_lt_/p_gt_\n\n_lt_p_gt_\n\tWhen you hit F12_co_ you_t_ll see in the console that the buffer is filled with the expected values - being the original color array with postions 4 to 7 altered. So I got a hunch this is the color buffer but the changes are not applied.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tMy expectation is_co_ that if I get this to work_co_ it will be a faster way to modify the meshes - at least in the case where there only are a few vertices changed per frame.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow_co_ how do I get these change to be rendered?\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-10T17:51:21Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tSo good news_dd_ this is feasible with no hack _lt_img alt_eq__qt__dd_)_qt_ data-emoticon_eq__qt__qt_ height_eq__qt_20_qt_ src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ title_eq__qt__dd_)_qt_ width_eq__qt_20_qt_ /_gt_ \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#YVA9CM%232_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#YVA9CM#2_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNote several things_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- Must flag the mesh as updatable to be able to change a part of the buffer_dd_ customMesh.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.ColorKind_co_ true)_sm_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- You can get the geometry through mesh.geometry\n_lt_/p_gt_\n\n_lt_p_gt_\n\t- the geometry knows how to update a part of buffer_dd_ geometry.updateVerticesDataDirectly(BABYLON.VertexBuffer.ColorKind_co_ new Float32Array(newData)_co_ idx * 4)_sm_\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-11T08:50:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tGreat_co_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tI will create a speed benchmark demo in PG to see how much time we have won.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-12T04:39:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tOkay_co_ here it is_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#DMYNYQ%2310_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#DMYNYQ#10_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tIt shows that setVerticesData and updateVerticesData do not differ in speed all too much. updateVerticesDataDirectly indeed is a lot faster. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI am updating about 100 vertices per frame in this benchmark.\n_lt_/p_gt_\n\n_lt_p_gt_\n\tYou may want to try this in all major browsers_co_ there is a huge speed difference between Firefox and Chrome. The latter one being much slower for the first two cases and twice as fast for _t_Directly_t_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tOne more question for _lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt__dd_ as you can see in case _t_2_t_ I pick a number between 0 and the number of vertices and multiply that by 4 (four numbers in a colour). Strange enough I only got this case to work when I multiplied the idx variable by 4 a second time... \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-12T15:45:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tIt works for me if I do not multiply by 4_dd_ _lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#DMYNYQ%2311_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#DMYNYQ#11_lt_/a_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-12T17:49:59Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tif you comment out the test++ line (#124) you will notice that it will only cover the top of the sphere AND that test #2 uses different colors while it should only paint vertices red_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#DMYNYQ%2313_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#DMYNYQ#13_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\tNow multiply it again and it does what I_t_ve asked it to do_co_ color vertices red all over the sphere_dd_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a href_eq__qt_http_dd_//www.babylonjs-playground.com/#DMYNYQ%2314_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//www.babylonjs-playground.com/#DMYNYQ#14_lt_/a_gt_\n_lt_/p_gt_\n\n_lt_p_gt_\n\t(tested on Chrome and Firefox on Ubuntu 17.04 machine)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"sable","Date":"2017-06-12T23:23:23Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tI think this is because the offset is in bytes. With four bytes per float32 number the multiply by 4 is needed to convert the index offset to the byte offset.\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-13T14:16:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tThat sounds like a plausible explaination... \n_lt_/p_gt_\n\n_lt_p_gt_\n\t_lt_a contenteditable_eq__qt_false_qt_ data-ipshover_eq__qt__qt_ data-ipshover-target_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/?do_eq_hovercard_qt_ data-mentionid_eq__qt_4442_qt_ href_eq__qt_http_dd_//www.html5gamedevs.com/profile/4442-deltakosh/_qt_ rel_eq__qt__qt__gt_@Deltakosh_lt_/a_gt_ can I ask for an extra feature? It would be great if there would be a function that would (re)calculate a single normal... \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-13T23:42:06Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tWhat for? How do you think about using it?\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-14T03:53:19Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tWell_co_ I am building a sculpting application in which I will change a small number of vertices per frame on a now 50K vertices model. The updateVerticesDataDirectly-method helps me to change just them and not have to swap the entire vertices buffers all the time. But to recalculate the normals every frame I now use computeNormals and then use updateVerticesData to swap the entire normals-table.\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2017-06-14T17:06:39Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI understand. In this case you will have to save the faces somewhere and when you update the vertices_co_ you will have to find the affected faces_co_ recompute the normals and update only affected normals (the same way you update the positions with updateVerticesDataDirectly)\n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"jerome","Date":"2017-06-14T20:58:56Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t_lt_p_gt_\n\tto get facets_co_ facet normals_co_ and other info about each face_co_ simply use FacetData _dd_ _lt_a href_eq__qt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_facetdata_qt_ rel_eq__qt_external nofollow_qt__gt_http_dd_//doc.babylonjs.com/tutorials/how_to_use_facetdata_lt_/a_gt_\n_lt_/p_gt_\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-17T05:01:48Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tUsing facet data would not help here because I need updated normals for just a few facets. \n_lt_/p_gt_\n\n_lt_p_gt_\n\tI have coded a function that recalculates the vertice normals. It depends on an extra buffer for the vertice to triangle relation. I also stored indices_co_ normals and points in my own object to have quicker access.\n_lt_/p_gt_\n\n_lt_pre_gt_\n_lt_code_gt_calcNormals_dd_ function(list) {\n\tvar tri_normals _eq_ {}_sm_\n\tvar newData3 _eq_ new Float32Array(3)_sm_\n\tvar idx _eq_ 0_sm_\n\t\n\tvar _p2t _eq_ base_model.p2t_sm_\n\tvar points _eq_ base_model.points_sm_\n\tvar poly _eq_ base_model.poly_sm_\n\tvar normals _eq_ base_model.normals_sm_\n\tvar geometry _eq_ base_model.mesh.geometry_sm_\n\t\n\tvar tlist _eq_ []_sm_\n\n\tfor (var i in list) {\n\t\t// Recalculate for every vertice in the list\n\t\t\n\t\tvar currPoint_eq_list[i]_sm_\n\t\ttlist _eq_ _p2t[currPoint]_sm_\n\t\tvar normal _eq_ new BABYLON.Vector3(0_co_ 0_co_ 0)_sm_\n\n\t\tvar tl _eq_ tlist.length_sm_\n\t\tfor (var t _eq_ 0_sm_ t &lt_sm_ tl_sm_ t++) {\n\t\t\t// Calc all triangles connected to the vertice\n\t\t\tvar currTri_eq_tlist[t]_sm_\n\n\t\t\t\n\t\t\tif (tri_normals[tlist[t]]) {\n\t\t\t\t// If we already got this one_co_ use that\n\t\t\t\tvar tnormal _eq_ tri_normals[currTri]_sm_\n\t\t\t} else {\n\t\t\t\t// If not_co_ calculate it.  \n\t\t\t\tfaceId _eq_ currTri*3_sm_\n\t\t\t\tvar vertex1 _eq_ BABYLON.Vector3.FromArray(points_co_ poly[faceId] * 3)_sm_\n\t\t\t\tvar vertex2 _eq_ BABYLON.Vector3.FromArray(points_co_ poly[faceId + 1] * 3)_sm_\n\t\t\t\tvar vertex3 _eq_ BABYLON.Vector3.FromArray(points_co_ poly[faceId + 2] * 3)_sm_\n\t\t\t\tvar p1p2 _eq_ vertex1.subtract(vertex2)_sm_\n\t\t\t\tvar p3p2 _eq_ vertex3.subtract(vertex2)_sm_\n\t\t\t\tvar tnormal _eq_ BABYLON.Vector3.Normalize(BABYLON.Vector3.Cross(p1p2_co_ p3p2))_sm_\n\t\t\t\t// Keep it for later use\n\t\t\t\ttri_normals[currTri] _eq_ tnormal_sm_\n\t\t\t}\n\n\t\t\tnormal.x +_eq_ tnormal.x_sm_\n\t\t\tnormal.y +_eq_ tnormal.y_sm_\n\t\t\tnormal.z +_eq_ tnormal.z_sm_\n\n\t\t}\n\t\t// Divide to get the average (no need to normalize it!)\n\t\tnormal.x/_eq_tl_sm_\n\t\tnormal.y/_eq_tl_sm_\n\t\tnormal.z/_eq_tl_sm_\n\t\t\n\t\t// Store it in my normals array and feed it to the mesh\n\t\tidx_eq_currPoint*3_sm_\n\t\tnewData3[0]_eq_normals[idx]_eq_normal.x_sm_\n\t\tnewData3[1]_eq_normals[idx+1]_eq_normal.y_sm_\n\t\tnewData3[2]_eq_normals[idx+2]_eq_normal.z_sm_\n\t\tgeometry.updateVerticesDataDirectly(BABYLON.VertexBuffer.NormalKind_co_ newData3_co_ idx * 4)\n\t\t\n\t}\n}_co__lt_/code_gt__lt_/pre_gt_\n\n_lt_p_gt_\n\tWorks fine_co_ hope it will be of use for others. If anyone has an idea how to increase the speed_co_ let me know.\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"NasimiAsl","Date":"2017-06-17T18:24:12Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\twhy you don_t_t change it in GPU side?\n_lt_/p_gt_\n\n_lt_p_gt_\n\tyou can calculate normal in gpu side too\n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Fedor","Date":"2017-06-18T03:40:41Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_\n\tI think that is what Babylon does. But that seems to be slower then this routine. It involves copying buffers and it does all normals on my 50K model... \n_lt_/p_gt_\n\n_lt_p_gt_\n\t \n_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]