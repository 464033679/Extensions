[{"Owner":"Nico","Date":"2014-04-11T13:38:52Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hi !_lt_/p_gt__lt_p_gt_I_t_m playing with BABYLON.RenderTargetTexture_co_ and I_t_ve got a weird issue with Internet Explorer..._lt_/p_gt__lt_p_gt_First here is my code (I may do something wrong_co_ since I_t_ve recently started playing with textures)_dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var texture _eq_ new BABYLON.RenderTargetTexture(_qt_wholeScene_qt__co_ 2048_co_ myScene)_sm_texture.renderList _eq_ myScene.meshes_sm_texture.render()_sm_//I_t_ve first putted some code here_co_ but you can see the issue without any line of code.texture.dispose()_sm__lt_/pre_gt__lt_p_gt_All is working well on all browser except IE..._lt_/p_gt__lt_p_gt_I am trying this on BabylonJS demos_co_ and it_t_s working like a charm for some demos like Spaceship_co_ Blender_co_ or Train_co_ but not working for Dude_co_ Heart or Hillvalley (my favorite demo!)._lt_/p_gt__lt_p_gt_After disposing the texture_co_ the scene disappear_co_ and the canvas seems to show only the clearColor. I first thought that the problem come from the renderLoop which seems to be stoped_co_ but it still running..._lt_/p_gt__lt_p_gt_The problem appears just after texture.render()_co_ without texture.dispose()_co_ the scene seems to freeze._lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Thanks for reading_co__lt_/p_gt__lt_p_gt_Nico._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-11T15:39:20Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Hello_co__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_could you share an example on jsfiddle?_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nico","Date":"2014-04-14T08:58:10Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I_t_ve tried to make an example with the issue_co_ but I can_t_t reproduce it by creating basic scene on the javascript side..._lt_/p_gt__lt_p_gt_The only way to reproduce it is to use BABYLON.SceneLoader.Load_co_ but I can_t_t make it work on JSFiddle _dd_/_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_But I_t_ve made an temporary online version using basic babylon demos (Dude and Blender)_co_ available _lt_a href_eq__qt_http_dd_//babylon.obre.fr_qt_ rel_eq__qt_external nofollow_qt__gt_here_lt_/a_gt__lt_/p_gt__lt_p_gt_Here is my javascript code used to handle button click_co_ renderTargetTexture generation_co_ and scene loading _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var canvas _eq_ document.getElementById(_qt_renderCanvas_qt_)_sm_var engine _eq_ new BABYLON.Engine(canvas)_sm_var scene_sm_var loading _eq_ document.getElementById(_qt_loading_qt_)_sm_var loadSceneNewScene _eq_ function(folder_co_ file){    if(scene){        scene.dispose()_sm_        engine.stopRenderLoop()_sm_    }    loading.innerHTML _eq_ _qt_Loading scene ..._qt__sm_    BABYLON.SceneLoader.Load(folder_co_ file_co_ engine_co_ function(newScene){        scene _eq_ newScene_sm_        scene.executeWhenReady(function(){                    scene.activeCamera.attachControl(canvas)_sm_                        engine.runRenderLoop(function(){                scene.render()_sm_            })_sm_        })_sm_    }_co_ function(e){        if(e.loaded  _eq__eq_ e.total){            loading.innerHTML _eq_ _qt__qt__sm_        }    })_sm_}_sm_var loadSceneButtonCallback _eq_ function(e){    var folder _eq_ e.currentTarget.getAttribute(_qt_data-folder_qt_)_sm_    var file _eq_ e.currentTarget.getAttribute(_qt_data-file_qt_)_sm_        loadSceneNewScene(folder_co_ file)_sm_}_sm_document.getElementById(_qt_createTexture_qt_).addEventListener(_qt_click_qt__co_ function(e){    var texture _eq_ new BABYLON.RenderTargetTexture(_qt_wholeScene_qt__co_ 128_co_ scene)_sm_    texture.renderList _eq_ scene.meshes_sm_    texture.render()_sm_    texture.dispose()_sm_})_sm_var buttons _eq_ document.getElementsByClassName(_qt_loadScene_qt_)_sm_var length _eq_ buttons.length_sm_for(var i _eq_ 0_sm_ i &lt_sm_ length_sm_ i++){    buttons[i].addEventListener(_qt_click_qt__co_ loadSceneButtonCallback)_sm_}_lt_/pre_gt__lt_p_gt_I have also tried to load a scene (and unload previous scene) when you click on a button_co_ but it doesn_t_t work if you have already loaded Dude scene and if you try to load Blender scene_co_ I_t_ve got WebGL errors on Chrome console_co_ it doesn_t_t work on Firefox_co_ BUT it works on Internet Explorer here..._lt_/p_gt__lt_p_gt_You can see what I get on chrome console _dd__lt_/p_gt__lt_p_gt__lt_img src_eq__qt_http_dd_//pix.keuse.fr/images/babylomlm.jpg_qt_ alt_eq__qt_babylomlm.jpg_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nico","Date":"2014-04-14T14:30:34Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I_t_ve just found something_co_ not sure if it_t_s the proper way to do_co_ but it works _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_var texture _eq_ new BABYLON.RenderTargetTexture(_qt_wholeScene_qt__co_ 2048_co_ myScene)_sm_texture.renderList _eq_ myScene.meshes_sm_texture.render()_sm_//I_t_ve first putted some code here_co_ but you can see the issue without any line of code.texture.dispose()_sm_engine.restoreDefaultFramebuffer()_sm__lt_/pre_gt__lt_p_gt_Using a renderTargetTexture imply using the framebuffer_co_ and engine.unBindFramebuffer seems to do nothing in my case (my texture doesn_t_t need mipmap)._lt_/p_gt__lt_p_gt_Does an engine.restoreDefaultFramebuffer call must be done at the end of a renderTargetTexture render() method ?_lt_/p_gt__lt_p_gt_I could be wrong since this solution is a big lucky guess _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_mellow.png_qt_ alt_eq__qt__dd_mellow_dd__qt__gt__lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_EDIT_dd_ After some tests_co_ the only line I needed in the restoreDefaultFramebuffer method was _qt_this._gl.bindFramebuffer(this._gl.FRAMEBUFFER_co_ null)_sm__qt_ it allows to _qt_unbind_qt_ the framebuffer previously bound._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nico","Date":"2014-04-14T14:42:46Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_If it is the right way to do_co_ could I send you a pull request with this code _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.Engine.prototype.unBindFramebuffer _eq_ function (texture) {        if (texture.generateMipMaps) {            var gl _eq_ this._gl_sm_            gl.bindTexture(gl.TEXTURE_2D_co_ texture)_sm_            gl.generateMipmap(gl.TEXTURE_2D)_sm_            gl.bindTexture(gl.TEXTURE_2D_co_ null)_sm_        }        //line added        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER_co_ null)_sm_    }_sm__lt_/pre_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-14T17:04:09Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_Sounds good to me_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_Basically rendertexture are designed to be used during a render loop. You register your render texture and babylon.js will call the render for you and then restore the framebuffer_lt_/p_gt__lt_p_gt_ _lt_/p_gt__lt_p_gt_but with your update_co_ things are smoother _lt_img src_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/default_smile.png_qt_ alt_eq__qt__dd_)_qt_ srcset_eq__qt_http_dd_//www.html5gamedevs.com/uploads/emoticons/smile@2x.png 2x_qt_ width_eq__qt_20_qt_ height_eq__qt_20_qt__gt__lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Nico","Date":"2014-04-14T18:24:27Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I have read the BABYLON.RenderTargetTexture.prototype.render method once again_co_ and if my fix is applied_co_ if you manipulate texture with WebGL calls you won_t_t be able to do this anymore_co_ since the framebuffer will be cleared before the _qt_onAfterRender_qt_ call _dd__lt_/p_gt__lt_pre class_eq__qt_ipsCode prettyprint_qt__gt_BABYLON.RenderTargetTexture.prototype.render _eq_ function () {        if (this.onBeforeRender) {            this.onBeforeRender()_sm_        }        [...]        // Bind        engine.bindFramebuffer(this._texture)_sm_        [...]        // Render        this._renderingManager.render(this.customRenderFunction_co_ this.renderList_co_ this.renderParticles_co_ this.renderSprites)_sm_        // Unbind        engine.unBindFramebuffer(this._texture)_sm_        if (this.onAfterRender) {            this.onAfterRender()_sm_        }    }_sm__lt_/pre_gt__lt_p_gt_I think there is 2 solutions_co_ if my fix is applied_co_ you need to call onAfterRender before unBindFramebuffer_co_ or_co_ I can call manually _qt_this._gl.bindFramebuffer(this._gl.FRAMEBUFFER_co_ null)_sm__qt_ on my onAfterRender function_co_ in this case_co_ my fix won_t_t be needed._lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"},{"Owner":"Deltakosh","Date":"2014-04-14T20:20:49Z","Content":"_lt_div class_eq__qt_mages_qt__gt_\n\t\t\t\n_lt_p_gt_I think we can invert the call to onAfterRender_lt_/p_gt_\n\n\n\t\t\t\n\t\t_lt_/div_gt_\n\n\t\t_lt_div class_eq__qt_ipsI_qt__gt__lt_/div_gt__lt_/div_gt_"}]