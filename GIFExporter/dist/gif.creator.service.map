{"version":3,"sources":["..\\..\\..\\..\\..\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\process\\browser.js","gif.creator.service.ts"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"gif.creator.service.map","sourceRoot":"..\\src","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* ----------------------------------------------NeuQuant START---------------------------------------------------------- */\n/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nfunction toInt(v) {\n\treturn ~~v;\n}\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = 1 << intbiasshift;\nvar gammashift = 10;\nvar gamma = 1 << gammashift;\nvar betashift = 10;\nvar beta = intbias >> betashift; /* beta = 1/1024 */\nvar betagamma = intbias << (gammashift - betashift);\n\n// defs for decreasing radius factor\nvar initrad = netsize >> 3; // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = 1 << radiusbiasshift;\nvar initradius = initrad * radiusbias; //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = 1 << alphabiasshift;\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = 1 << radbiasshift;\nvar alpharadbshift = alphabiasshift + radbiasshift;\nvar alpharadbias = 1 << alpharadbshift;\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = 3 * prime4;\n\n/*\n    Constructor: NeuQuant\n  \n    Arguments:\n  \n    pixels - array of pixels in RGB format\n    samplefac - sampling factor 1 to 30 where lower is better quality\n  \n    >\n    > pixels = [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\nexport default function NeuQuant(pixels, samplefac) {\n\tvar network; // int[netsize][4]\n\tvar netindex; // for network lookup - really 256\n\n\t// bias and freq arrays for learning\n\tvar bias;\n\tvar freq;\n\tvar radpower;\n\n\t/*\n      Private Method: init\n  \n      sets up arrays\n    */\n\tfunction init() {\n\t\tnetwork = [];\n\t\tnetindex = [];\n\t\tbias = [];\n\t\tfreq = [];\n\t\tradpower = [];\n\n\t\tvar i, v;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tv = (i << (netbiasshift + 8)) / netsize;\n\t\t\tnetwork[i] = [v, v, v];\n\t\t\tfreq[i] = intbias / netsize;\n\t\t\tbias[i] = 0;\n\t\t}\n\t}\n\n\t/*\n      Private Method: unbiasnet\n  \n      unbiases network to give byte values 0..255 and record position i to prepare for sort\n    */\n\tfunction unbiasnet() {\n\t\tfor (var i = 0; i < netsize; i++) {\n\t\t\tnetwork[i][0] >>= netbiasshift;\n\t\t\tnetwork[i][1] >>= netbiasshift;\n\t\t\tnetwork[i][2] >>= netbiasshift;\n\t\t\tnetwork[i][3] = i; // record color number\n\t\t}\n\t}\n\n\t/*\n      Private Method: altersingle\n  \n      moves neuron *i* towards biased (b,g,r) by factor *alpha*\n    */\n\tfunction altersingle(alpha, i, b, g, r) {\n\t\tnetwork[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n\t\tnetwork[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n\t\tnetwork[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n\t}\n\n\t/*\n      Private Method: alterneigh\n  \n      moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n    */\n\tfunction alterneigh(radius, i, b, g, r) {\n\t\tvar lo = Math.abs(i - radius);\n\t\tvar hi = Math.min(i + radius, netsize);\n\n\t\tvar j = i + 1;\n\t\tvar k = i - 1;\n\t\tvar m = 1;\n\n\t\tvar p, a;\n\t\twhile (j < hi || k > lo) {\n\t\t\ta = radpower[m++];\n\n\t\t\tif (j < hi) {\n\t\t\t\tp = network[j++];\n\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\n\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\n\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\n\t\t\t}\n\n\t\t\tif (k > lo) {\n\t\t\t\tp = network[k--];\n\t\t\t\tp[0] -= (a * (p[0] - b)) / alpharadbias;\n\t\t\t\tp[1] -= (a * (p[1] - g)) / alpharadbias;\n\t\t\t\tp[2] -= (a * (p[2] - r)) / alpharadbias;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n      Private Method: contest\n  \n      searches for biased BGR values\n    */\n\tfunction contest(b, g, r) {\n\t\t/*\n        finds closest neuron (min dist) and updates freq\n        finds best neuron (min dist-bias) and returns position\n        for frequently chosen neurons, freq[i] is high and bias[i] is negative\n        bias[i] = gamma * ((1 / netsize) - freq[i])\n      */\n\n\t\tvar bestd = ~(1 << 31);\n\t\tvar bestbiasd = bestd;\n\t\tvar bestpos = -1;\n\t\tvar bestbiaspos = bestpos;\n\n\t\tvar i, n, dist, biasdist, betafreq;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tn = network[i];\n\n\t\t\tdist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n\t\t\tif (dist < bestd) {\n\t\t\t\tbestd = dist;\n\t\t\t\tbestpos = i;\n\t\t\t}\n\n\t\t\tbiasdist = dist - (bias[i] >> (intbiasshift - netbiasshift));\n\t\t\tif (biasdist < bestbiasd) {\n\t\t\t\tbestbiasd = biasdist;\n\t\t\t\tbestbiaspos = i;\n\t\t\t}\n\n\t\t\tbetafreq = freq[i] >> betashift;\n\t\t\tfreq[i] -= betafreq;\n\t\t\tbias[i] += betafreq << gammashift;\n\t\t}\n\n\t\tfreq[bestpos] += beta;\n\t\tbias[bestpos] -= betagamma;\n\n\t\treturn bestbiaspos;\n\t}\n\n\t/*\n      Private Method: inxbuild\n  \n      sorts network and builds netindex[0..255]\n    */\n\tfunction inxbuild() {\n\t\tvar i,\n\t\t\tj,\n\t\t\tp,\n\t\t\tq,\n\t\t\tsmallpos,\n\t\t\tsmallval,\n\t\t\tpreviouscol = 0,\n\t\t\tstartpos = 0;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tp = network[i];\n\t\t\tsmallpos = i;\n\t\t\tsmallval = p[1]; // index on g\n\t\t\t// find smallest in i..netsize-1\n\t\t\tfor (j = i + 1; j < netsize; j++) {\n\t\t\t\tq = network[j];\n\t\t\t\tif (q[1] < smallval) {\n\t\t\t\t\t// index on g\n\t\t\t\t\tsmallpos = j;\n\t\t\t\t\tsmallval = q[1]; // index on g\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = network[smallpos];\n\t\t\t// swap p (i) and q (smallpos) entries\n\t\t\tif (i != smallpos) {\n\t\t\t\tj = q[0];\n\t\t\t\tq[0] = p[0];\n\t\t\t\tp[0] = j;\n\t\t\t\tj = q[1];\n\t\t\t\tq[1] = p[1];\n\t\t\t\tp[1] = j;\n\t\t\t\tj = q[2];\n\t\t\t\tq[2] = p[2];\n\t\t\t\tp[2] = j;\n\t\t\t\tj = q[3];\n\t\t\t\tq[3] = p[3];\n\t\t\t\tp[3] = j;\n\t\t\t}\n\t\t\t// smallval entry is now in position i\n\n\t\t\tif (smallval != previouscol) {\n\t\t\t\tnetindex[previouscol] = (startpos + i) >> 1;\n\t\t\t\tfor (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\t\t\t\tpreviouscol = smallval;\n\t\t\t\tstartpos = i;\n\t\t\t}\n\t\t}\n\t\tnetindex[previouscol] = (startpos + maxnetpos) >> 1;\n\t\tfor (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; // really 256\n\t}\n\n\t/*\n      Private Method: inxsearch\n  \n      searches for BGR values 0..255 and returns a color index\n    */\n\tfunction inxsearch(b, g, r) {\n\t\tvar a, p, dist;\n\n\t\tvar bestd = 1000; // biggest possible dist is 256*3\n\t\tvar best = -1;\n\n\t\tvar i = netindex[g]; // index on g\n\t\tvar j = i - 1; // start at netindex[g] and work outwards\n\n\t\twhile (i < netsize || j >= 0) {\n\t\t\tif (i < netsize) {\n\t\t\t\tp = network[i];\n\t\t\t\tdist = p[1] - g; // inx key\n\t\t\t\tif (dist >= bestd) i = netsize;\n\t\t\t\t// stop iter\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (dist < 0) dist = -dist;\n\t\t\t\t\ta = p[0] - b;\n\t\t\t\t\tif (a < 0) a = -a;\n\t\t\t\t\tdist += a;\n\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\ta = p[2] - r;\n\t\t\t\t\t\tif (a < 0) a = -a;\n\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\tbestd = dist;\n\t\t\t\t\t\t\tbest = p[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tp = network[j];\n\t\t\t\tdist = g - p[1]; // inx key - reverse dif\n\t\t\t\tif (dist >= bestd) j = -1;\n\t\t\t\t// stop iter\n\t\t\t\telse {\n\t\t\t\t\tj--;\n\t\t\t\t\tif (dist < 0) dist = -dist;\n\t\t\t\t\ta = p[0] - b;\n\t\t\t\t\tif (a < 0) a = -a;\n\t\t\t\t\tdist += a;\n\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\ta = p[2] - r;\n\t\t\t\t\t\tif (a < 0) a = -a;\n\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\tbestd = dist;\n\t\t\t\t\t\t\tbest = p[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn best;\n\t}\n\n\t/*\n      Private Method: learn\n  \n      \"Main Learning Loop\"\n    */\n\tfunction learn() {\n\t\tvar i;\n\n\t\tvar lengthcount = pixels.length;\n\t\tvar alphadec = toInt(30 + (samplefac - 1) / 3);\n\t\tvar samplepixels = toInt(lengthcount / (3 * samplefac));\n\t\tvar delta = toInt(samplepixels / ncycles);\n\t\tvar alpha = initalpha;\n\t\tvar radius = initradius;\n\n\t\tvar rad = radius >> radiusbiasshift;\n\n\t\tif (rad <= 1) rad = 0;\n\t\tfor (i = 0; i < rad; i++) radpower[i] = toInt(alpha * (((rad * rad - i * i) * radbias) / (rad * rad)));\n\n\t\tvar step;\n\t\tif (lengthcount < minpicturebytes) {\n\t\t\tsamplefac = 1;\n\t\t\tstep = 3;\n\t\t} else if (lengthcount % prime1 !== 0) {\n\t\t\tstep = 3 * prime1;\n\t\t} else if (lengthcount % prime2 !== 0) {\n\t\t\tstep = 3 * prime2;\n\t\t} else if (lengthcount % prime3 !== 0) {\n\t\t\tstep = 3 * prime3;\n\t\t} else {\n\t\t\tstep = 3 * prime4;\n\t\t}\n\n\t\tvar b, g, r, j;\n\t\tvar pix = 0; // current pixel\n\n\t\ti = 0;\n\t\twhile (i < samplepixels) {\n\t\t\tb = (pixels[pix] & 0xff) << netbiasshift;\n\t\t\tg = (pixels[pix + 1] & 0xff) << netbiasshift;\n\t\t\tr = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n\t\t\tj = contest(b, g, r);\n\n\t\t\taltersingle(alpha, j, b, g, r);\n\t\t\tif (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n\t\t\tpix += step;\n\t\t\tif (pix >= lengthcount) pix -= lengthcount;\n\n\t\t\ti++;\n\n\t\t\tif (delta === 0) delta = 1;\n\t\t\tif (i % delta === 0) {\n\t\t\t\talpha -= alpha / alphadec;\n\t\t\t\tradius -= radius / radiusdec;\n\t\t\t\trad = radius >> radiusbiasshift;\n\n\t\t\t\tif (rad <= 1) rad = 0;\n\t\t\t\tfor (j = 0; j < rad; j++) radpower[j] = toInt(alpha * (((rad * rad - j * j) * radbias) / (rad * rad)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n      Method: buildColormap\n  \n      1. initializes network\n      2. trains it\n      3. removes misconceptions\n      4. builds colorindex\n    */\n\tfunction buildColormap() {\n\t\tinit();\n\t\tlearn();\n\t\tunbiasnet();\n\t\tinxbuild();\n\t}\n\tthis.buildColormap = buildColormap;\n\n\t/*\n      Method: getColormap\n  \n      builds colormap from the index\n  \n      returns array in the format:\n  \n      >\n      > [r, g, b, r, g, b, r, g, b, ..]\n      >\n    */\n\tfunction getColormap() {\n\t\tvar map = [];\n\t\tvar index = [];\n\n\t\tfor (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n\n\t\tvar k = 0;\n\t\tfor (var l = 0; l < netsize; l++) {\n\t\t\tvar j = index[l];\n\t\t\tmap[k++] = network[j][0];\n\t\t\tmap[k++] = network[j][1];\n\t\t\tmap[k++] = network[j][2];\n\t\t}\n\t\treturn map;\n\t}\n\tthis.getColormap = getColormap;\n\n\t/*\n      Method: lookupRGB\n  \n      looks for the closest *r*, *g*, *b* color in the map and\n      returns its index\n    */\n\tthis.lookupRGB = inxsearch;\n}\n\n/* ----------------------------------------------NeuQuant END---------------------------------------------------------- */\n\n/* ----------------------------------------------ColorTableGen START---------------------------------------------------------- */\n\nexport class ColorTableGenerator {\n\tprivate _colorTable: number[] = [];\n\tprivate _GCT: string[] = [];\n\tprivate _neuQuant: NeuQuant;\n\tprivate _distribution = 51;\n\tprivate _colorLookup: {\n\t\t[index: string]: number;\n\t} = {};\n\n\tconstructor(frame: Uint8Array) {\n\t\tthis._neuQuant = new NeuQuant(frame, 20);\n\t\tthis._neuQuant.buildColormap();\n\t\tthis._colorTable = this._neuQuant.getColormap();\n\t}\n\n\tpublic generate(): [{ [index: string]: number }, string[]] {\n\t\tlet pixel: string = '';\n\t\tlet count = 0;\n\t\tthis._colorTable.forEach((value, index, array) => {\n\t\t\tpixel += this.pad(value);\n\t\t\tif ((index + 1) % 3 === 0) {\n\t\t\t\tthis._GCT.push(pixel);\n\t\t\t\tthis._colorLookup[pixel] = count;\n\t\t\t\tcount++;\n\t\t\t\tpixel = '';\n\t\t\t}\n\t\t\tif (index === this._colorTable.length - 1) return [this._colorLookup, this._GCT];\n\t\t});\n\t\treturn [this._colorLookup, this._GCT];\n\t}\n\n\tpublic lookupRGB(pixel: string): number {\n\t\tconst R = parseInt(pixel.substr(0, 2), 16);\n\t\tconst G = parseInt(pixel.substr(2, 2), 16);\n\t\tconst B = parseInt(pixel.substr(4, 2), 16);\n\t\tconst pixelIndex = this._neuQuant.lookupRGB(R, G, B);\n\n\t\treturn pixelIndex as number;\n\t}\n\n\tprivate pad(color: number): string {\n\t\tif (color < 16) {\n\t\t\treturn `0${color.toString(16)}`;\n\t\t} else {\n\t\t\treturn color.toString(16);\n\t\t}\n\t}\n}\n\n/* ----------------------------------------------ColorTableGen END---------------------------------------------------------- */\n\n/* ----------------------------------------------EncodedImage START---------------------------------------------------------- */\n\nexport class EncodedImage {\n\tdata: number[] = [];\n\n\tconstructor() {}\n\n\tpublic get(): number[] {\n\t\treturn this.data;\n\t}\n\n\tpublic write(byte: number): void {\n\t\tthis.data.push(byte);\n\t}\n\n\tpublic writeArray(array: number[], arraySize: number): void {\n\t\tfor (let i = 0; i < arraySize; i++) {\n\t\t\tthis.write(array[i]);\n\t\t}\n\t}\n\n\tpublic writeUTF(UTF: string): void {\n\t\tfor (let i = 0; i < UTF.length; i++) {\n\t\t\tthis.write(UTF.charCodeAt(i));\n\t\t}\n\t}\n\n\tpublic writeColor(color: string): void {\n\t\tfor (let i = 0; i < color.length; i += 2) {\n\t\t\tconst intValue: number = parseInt(color[i] + color[i + 1], 16);\n\t\t\tthis.write(intValue);\n\t\t}\n\t}\n\n\tpublic writeLittleEndian(num: number): void {\n\t\tthis.write(num & 0xff);\n\t\tthis.write((num >> 8) & 0xff);\n\t}\n\n\tpublic reset() {\n\t\tthis.data = [];\n\t}\n}\n\n/* ----------------------------------------------EncodedImage END---------------------------------------------------------- */\n\n/* ----------------------------------------------TypedLZW START---------------------------------------------------------- */\n\n/**\n * This class handles LZW encoding\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @author Anthony Powell (TypeScript version 2018)\n * @version 0.1 AS3 implementation\n */\n\nexport class LZWEncoder {\n\tprivate readonly EOF = 1;\n\n\t// GIFCOMPR.C - GIF Image compression routines\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\n\t// General DEFINEs\n\n\tprivate readonly BITS = 12;\n\tprivate readonly HSIZE = 5003;\n\n\tprivate _imgW: number;\n\tprivate _imgH: number;\n\tprivate _pixels: number[];\n\tprivate _initCodeSize: number;\n\tprivate _remaining: number;\n\tprivate _curPixel: number;\n\n\t// GIF Image compression - modified 'compress'\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n\t// Jim McKie (decvax!mcvax!jim)\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\n\t// Joe Orost (decvax!vax135!petsd!joe)\n\n\tprivate _n_bits: number; // number of bits/code\n\tprivate _maxbits = this.BITS; // user settable max # bits/code\n\tprivate _maxcode: number; // maximum code, given n_bits\n\tprivate _maxmaxcode = 1 << this.BITS; // should NEVER generate this code\n\tprivate _htab: number[] = [];\n\tprivate _codetab: number[] = [];\n\tprivate _hsize = this.HSIZE; // for dynamic table sizing\n\tprivate _free_ent = 0; // first unused entry\n\n\t// block compression parameters -- after all codes are used up,\n\t// and compression rate changes, start over.\n\n\tprivate _clear_flg = false;\n\n\t// Algorithm: use open addressing double hashing (no chaining) on the\n\t// prefix code / next character combination. We do a variant of Knuth's\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n\t// secondary probe. Here, the modular division first probe is gives way\n\t// to a faster exclusive-or manipulation. Also do block compression with\n\t// an adaptive reset, whereby the code table is cleared when the compression\n\t// ratio decreases, but after the table fills. The variable-length output\n\t// codes are re-sized at this point, and a special CLEAR code is generated\n\t// for the decompressor. Late addition: construct the table according to\n\t// file size for noticeable speed improvement on small files. Please direct\n\t// questions about this implementation to ames!jaw.\n\n\tprivate _g_init_bits: number;\n\tprivate _ClearCode: number;\n\tprivate _EOFCode: number;\n\n\t// output\n\t// Output the given code.\n\t// Inputs:\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\n\t// that n_bits =< wordsize - 1.\n\t// Outputs:\n\t// Outputs code to the file.\n\t// Assumptions:\n\t// Chars are 8 bits long.\n\t// Algorithm:\n\t// Maintain a BITS character long buffer (so that 8 codes will\n\t// fit in it exactly). Use the VAX insv instruction to insert each\n\t// code in turn. When the buffer fills up empty it and start over.\n\n\tprivate _cur_accum = 0;\n\tprivate _cur_bits = 0;\n\tprivate _masks = [\n\t\t0x0000,\n\t\t0x0001,\n\t\t0x0003,\n\t\t0x0007,\n\t\t0x000f,\n\t\t0x001f,\n\t\t0x003f,\n\t\t0x007f,\n\t\t0x00ff,\n\t\t0x01ff,\n\t\t0x03ff,\n\t\t0x07ff,\n\t\t0x0fff,\n\t\t0x1fff,\n\t\t0x3fff,\n\t\t0x7fff,\n\t\t0xffff,\n\t];\n\n\t// Number of characters so far in this 'packet'\n\tprivate _a_count: number;\n\n\t// Define the storage for the packet accumulator\n\tprivate _accum: number[] = [];\n\n\tconstructor(width: number, height: number, pixels: number[], colorDepth: number) {\n\t\tthis._imgW = width;\n\t\tthis._imgH = height;\n\t\tthis._pixels = pixels;\n\t\tthis._initCodeSize = Math.max(2, colorDepth);\n\t}\n\n\t// Add a character to the end of the current packet, and if it is 254\n\t// characters, flush the packet to disk.\n\tprivate writeCharToPacket(c: number, outs: EncodedImage): void {\n\t\tthis._accum[this._a_count++] = c;\n\t\tif (this._a_count >= 254) this.flush_char(outs);\n\t}\n\n\t// Clear out the hash table\n\t// table clear for block compress\n\n\tprivate cl_block(outs: EncodedImage): void {\n\t\tthis.cl_hash(this._hsize);\n\t\tthis._free_ent = this._ClearCode + 2;\n\t\tthis._clear_flg = true;\n\t\tthis.output(this._ClearCode, outs);\n\t}\n\n\t// reset code table\n\tprivate cl_hash(hsize: number): void {\n\t\tfor (let i = 0; i < hsize; ++i) this._htab[i] = -1;\n\t}\n\n\tprivate compress(init_bits: number, outs: EncodedImage) {\n\t\tlet fcode;\n\t\tlet i; /* = 0 */\n\t\tlet c;\n\t\tlet ent;\n\t\tlet disp;\n\t\tlet hsize_reg;\n\t\tlet hshift;\n\n\t\t// Set up the globals: g_init_bits - initial number of bits\n\t\tthis._g_init_bits = init_bits;\n\n\t\t// Set up the necessary values\n\t\tthis._clear_flg = false;\n\t\tthis._n_bits = this._g_init_bits;\n\t\tthis._maxcode = this.MAXCODE(this._n_bits);\n\n\t\tthis._ClearCode = 1 << (init_bits - 1);\n\t\tthis._EOFCode = this._ClearCode + 1;\n\t\tthis._free_ent = this._ClearCode + 2;\n\n\t\tthis._a_count = 0; // clear packet\n\n\t\tent = this.nextPixel();\n\n\t\thshift = 0;\n\t\tfor (fcode = this._hsize; fcode < 65536; fcode *= 2) ++hshift;\n\t\thshift = 8 - hshift; // set hash code range bound\n\n\t\thsize_reg = this._hsize;\n\t\tthis.cl_hash(hsize_reg); // clear hash table\n\n\t\tthis.output(this._ClearCode, outs);\n\n\t\touter_loop: while ((c = this.nextPixel()) != this.EOF) {\n\t\t\tfcode = (c << this._maxbits) + ent;\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\n\n\t\t\tif (this._htab[i] == fcode) {\n\t\t\t\tent = this._codetab[i];\n\t\t\t\tcontinue;\n\t\t\t} else if (this._htab[i] >= 0) {\n\t\t\t\t// non-empty slot\n\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\n\t\t\t\tif (i === 0) disp = 1;\n\n\t\t\t\tdo {\n\t\t\t\t\tif ((i -= disp) < 0) i += hsize_reg;\n\n\t\t\t\t\tif (this._htab[i] == fcode) {\n\t\t\t\t\t\tent = this._codetab[i];\n\t\t\t\t\t\tcontinue outer_loop;\n\t\t\t\t\t}\n\t\t\t\t} while (this._htab[i] >= 0);\n\t\t\t}\n\n\t\t\tthis.output(ent, outs);\n\t\t\tent = c;\n\t\t\tif (this._free_ent < this._maxmaxcode) {\n\t\t\t\tthis._codetab[i] = this._free_ent++; // code -> hashtable\n\t\t\t\tthis._htab[i] = fcode;\n\t\t\t} else this.cl_block(outs);\n\t\t}\n\n\t\t// Put out the final code.\n\t\tthis.output(ent, outs);\n\t\tthis.output(this._EOFCode, outs);\n\t}\n\n\t// ----------------------------------------------------------------------------\n\tpublic encode(os: EncodedImage) {\n\t\tos.write(this._initCodeSize); // write \"initial code size\" byte\n\t\tthis._remaining = this._imgW * this._imgH; // reset navigation variables\n\t\tthis._curPixel = 0;\n\t\tthis.compress(this._initCodeSize + 1, os); // compress and write the pixel data\n\t\tos.write(0); // write block terminator\n\t}\n\n\t// Flush the packet to disk, and reset the accumulator\n\tprivate flush_char(outs: EncodedImage) {\n\t\tif (this._a_count > 0) {\n\t\t\touts.write(this._a_count);\n\t\t\touts.writeArray(this._accum, this._a_count);\n\t\t\tthis._a_count = 0;\n\t\t}\n\t}\n\n\tprivate MAXCODE(n_bits: number) {\n\t\treturn (1 << n_bits) - 1;\n\t}\n\n\t// ----------------------------------------------------------------------------\n\t// Return the next pixel from the image\n\t// ----------------------------------------------------------------------------\n\n\tprivate nextPixel() {\n\t\tif (this._remaining === 0) return this.EOF;\n\t\t--this._remaining;\n\t\tlet pix = this._pixels[this._curPixel++];\n\t\treturn pix & 0xff;\n\t}\n\n\tprivate output(code: number, outs: EncodedImage) {\n\t\tthis._cur_accum &= this._masks[this._cur_bits];\n\n\t\tif (this._cur_bits > 0) this._cur_accum |= code << this._cur_bits;\n\t\telse this._cur_accum = code;\n\n\t\tthis._cur_bits += this._n_bits;\n\n\t\twhile (this._cur_bits >= 8) {\n\t\t\tthis.writeCharToPacket(this._cur_accum & 0xff, outs);\n\t\t\tthis._cur_accum >>= 8;\n\t\t\tthis._cur_bits -= 8;\n\t\t}\n\n\t\t// If the next entry is going to be too big for the code size,\n\t\t// then increase it, if possible.\n\n\t\tif (this._free_ent > this._maxcode || this._clear_flg) {\n\t\t\tif (this._clear_flg) {\n\t\t\t\tthis._maxcode = this.MAXCODE((this._n_bits = this._g_init_bits));\n\t\t\t\tthis._clear_flg = false;\n\t\t\t} else {\n\t\t\t\t++this._n_bits;\n\t\t\t\tif (this._n_bits == this._maxbits) this._maxcode = this._maxmaxcode;\n\t\t\t\telse this._maxcode = this.MAXCODE(this._n_bits);\n\t\t\t}\n\t\t}\n\n\t\tif (code == this._EOFCode) {\n\t\t\t// At EOF, write the rest of the buffer.\n\t\t\twhile (this._cur_bits > 0) {\n\t\t\t\tthis.writeCharToPacket(this._cur_accum & 0xff, outs);\n\t\t\t\tthis._cur_accum >>= 8;\n\t\t\t\tthis._cur_bits -= 8;\n\t\t\t}\n\n\t\t\tthis.flush_char(outs);\n\t\t}\n\t}\n}\n\n/* ----------------------------------------------TypedLZW END---------------------------------------------------------- */\n\n/* ----------------------------------------------GIFGen START---------------------------------------------------------- */\n\nexport class GIFGenerator {\n\tprivate stream: EncodedImage = new EncodedImage();\n\tprivate width: number;\n\tprivate height: number;\n\tprivate frameIndexedPixels: number[];\n\tprivate frameCount: number = 0;\n\tprivate GCT: string[];\n\n\tconstructor() {\n\t\tconsole.log(`Generator now running...`);\n\t}\n\n\tpublic init(width: number, height: number, GCT: string[]): void {\n\t\tthis.reset();\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.GCT = GCT;\n\t\tthis.writeHeader();\n\t\tthis.writeLogicalScreenDescriptor();\n\t\tthis.writeGlobalColorTable();\n\t\tthis.writeApplicationExtension();\n\t}\n\n\tpublic generateFrame(indexedPixels: number[]): void {\n\t\tthis.frameIndexedPixels = indexedPixels;\n\t\tthis.frameCount += 1;\n\t\tconsole.log(`generating frame ${this.frameCount}`);\n\t\tthis.writeGraphicControlExtension();\n\t\tthis.writeImageDescriptor();\n\t\tthis.writeImageData();\n\t}\n\n\tpublic getStream(): number[] {\n\t\tthis.writeTrailer();\n\t\treturn this.stream.get();\n\t}\n\n\tprivate writeHeader(): void {\n\t\tthis.stream.writeUTF('GIF89a'); /* GIF Header */\n\t}\n\n\tprivate writeLogicalScreenDescriptor(): void {\n\t\tthis.stream.writeLittleEndian(this.width); /* Canvas Width */\n\t\tthis.stream.writeLittleEndian(this.height); /* Canvas Height */\n\t\tthis.stream.write(0xf7); /* Packed Field */\n\t\tthis.stream.write(0); /* Background Color Index */\n\t\tthis.stream.write(0); /* Pixel Aspect Ration */\n\t}\n\n\tprivate writeGlobalColorTable(): void {\n\t\tlet count = 0;\n\n\t\tthis.GCT.forEach(color => {\n\t\t\tcount += 3;\n\t\t\tthis.stream.writeColor(color);\n\t\t});\n\n\t\tfor (let i = count; i < 3 * 256; i++) {\n\t\t\tthis.stream.write(0);\n\t\t}\n\t}\n\n\tprivate writeApplicationExtension(): void {\n\t\tthis.stream.write(0x21); /* extension introducer */\n\t\tthis.stream.write(0xff); /* app extension label */\n\t\tthis.stream.write(11); /* block size */\n\t\tthis.stream.writeUTF('NETSCAPE' + '2.0'); /* app id + auth code */\n\t\tthis.stream.write(3); /* sub-block size */\n\t\tthis.stream.write(1); /* loop sub-block id */\n\t\tthis.stream.writeLittleEndian(0); /* loop count (extra iterations, 0=repeat forever) */\n\t\tthis.stream.write(0); /* Block Terminator */\n\t}\n\n\tprivate writeGraphicControlExtension(): void {\n\t\tthis.stream.write(0x21); /* Extension Introducer */\n\t\tthis.stream.write(0xf9); /* Graphic Control Label */\n\t\tthis.stream.write(0x4); /* Byte Size */\n\t\tthis.stream.write(0x4); /* Packed Field */\n\t\tthis.stream.writeLittleEndian(0x9); /* Delay Time */\n\t\tthis.stream.write(0x0); /* Transparent Color Index */\n\t\tthis.stream.write(0x0); /* Block Terminator */\n\t}\n\n\tprivate writeImageDescriptor(): void {\n\t\tthis.stream.write(0x2c); /* Image Seperator Always 2C */\n\t\tthis.stream.writeLittleEndian(0x0); /* Image Left */\n\t\tthis.stream.writeLittleEndian(0x0); /* Image Top */\n\t\tthis.stream.writeLittleEndian(this.width); /* Image Width */\n\t\tthis.stream.writeLittleEndian(this.height); /* Image Height */\n\t\tthis.stream.write(0x0); /* Block Terminator */\n\t}\n\n\tprivate async writeImageData(): Promise<void> {\n\t\tconst encoder = new LZWEncoder(this.width, this.height, this.frameIndexedPixels, 8);\n\t\tencoder.encode(this.stream);\n\t\tconsole.log(`completed frame ${this.frameCount}`);\n\t}\n\n\tprivate writeTrailer(): void {\n\t\tthis.stream.write(0x3b); /* Trailer Marker */\n\t\tconsole.log(`Generator now finished.`);\n\t\tthis.frameCount = 0; /* Reset frame count for next GIF */\n\t}\n\n\tprivate writeLocalColorTable(): void {}\n\n\tprivate writePlainTextExtension(): void {}\n\n\tprivate writeCommentExtension(): void {}\n\n\tprivate reset() {\n\t\tthis.stream.reset();\n\t\tthis.frameCount = 0;\n\t}\n}\n\n/* ----------------------------------------------GIFGen END---------------------------------------------------------- */\n\n/* ----------------------------------------------Worker Processing Duties START---------------------------------------------------------- */\n\nconst ctx: Worker = self as any;\nlet _colorTableGen: ColorTableGenerator;\n\nconst gifGenerator: GIFGenerator = new GIFGenerator();\nconst _frameCollection: Uint8Array[] = [];\n\nfunction createColorTable(frame: Uint8Array, width: number, height: number): { [index: string]: number } {\n\t_colorTableGen = new ColorTableGenerator(frame);\n\tlet colorLookup: { [index: string]: number }, colorTable: string[];\n\t[colorLookup, colorTable] = _colorTableGen.generate();\n\twriteColorTable(colorTable, width, height);\n\treturn colorLookup;\n\n\tfunction writeColorTable(globalColorTable: string[], width: number, height: number): Promise<void> {\n\t\tgifGenerator.init(width, height, globalColorTable);\n\t\treturn;\n\t}\n}\n\nfunction processFrames(\n\tframes: Uint8Array[],\n\twidth: number,\n\theight: number\n): {\n\tnumericalRGBFrames: Uint8Array[];\n\tstringRGBFrames: string[][];\n} {\n\tfunction process(): {\n\t\tnumericalRGBFrames: Uint8Array[];\n\t\tstringRGBFrames: string[][];\n\t} {\n\t\tconst numericalRGBFrames: Uint8Array[] = [];\n\t\tconst stringRGBFrames: string[][] = [];\n\t\tframes.forEach(frame => {\n\t\t\tconst { numericalRGBData, stringRGBData } = toRGB(frame);\n\t\t\tnumericalRGBFrames.push(numericalRGBData);\n\t\t\tstringRGBFrames.push(stringRGBData);\n\t\t});\n\t\treturn { numericalRGBFrames, stringRGBFrames };\n\t}\n\tfunction toRGB(frame: Uint8Array): { numericalRGBData: Uint8Array; stringRGBData: string[] } {\n\t\tconst numericalRGBData = frame.filter((pixel: number, index: number) => (index + 1) % 4 !== 0);\n\n\t\tconst stringRGBData: string[] = [];\n\t\tlet pixel = '';\n\t\tnumericalRGBData.forEach((color, index) => {\n\t\t\tpixel += pad(color);\n\t\t\tif ((index + 1) % 3 === 0) {\n\t\t\t\tstringRGBData.push(pixel);\n\t\t\t\tpixel = '';\n\t\t\t}\n\t\t});\n\t\treturn { numericalRGBData, stringRGBData };\n\t}\n\n\tfunction pad(color: number): string {\n\t\tif (color < 16) {\n\t\t\treturn `0${color.toString(16)}`;\n\t\t} else {\n\t\t\treturn color.toString(16);\n\t\t}\n\t}\n\treturn process();\n}\n\nfunction generateGIF(frames: string[][], colorLookup: { [index: string]: number }) {\n\tfunction mapPixelsToIndex(frames: string[][], colorLookup: { [index: string]: number }): number[][] {\n\t\tconst indexedFrames: number[][] = [];\n\t\tframes.forEach((frame, index) => {\n\t\t\tconst indexedPixels: number[] = [];\n\t\t\tframe.forEach(pixel => {\n\t\t\t\tindexedPixels.push(lookup(pixel));\n\t\t\t});\n\t\t\tindexedFrames.push(indexedPixels);\n\t\t});\n\t\treturn indexedFrames;\n\t}\n\n\tfunction lookup(pixel: string) {\n\t\treturn /* colorLookup[pixel] ? colorLookup[pixel] : */ _colorTableGen.lookupRGB(pixel);\n\t}\n\tconst indexedFrames = mapPixelsToIndex(frames, colorLookup);\n\n\tindexedFrames.forEach(frame => {\n\t\tgifGenerator.generateFrame(frame);\n\t});\n\treturn gifGenerator.getStream();\n}\n\nfunction collectFrames(frame: ArrayBuffer) {\n\t_frameCollection.push(new Uint8Array(frame));\n}\n\nfunction getColorSamplingFrames(frames: Uint8Array[]) {\n\t/* every 5 frames placed in sampling frames array */\n\tconst samplingFrames = frames.filter((frame, index) => (index + 1) % 5 === 0);\n\t/* Combine arrays in samplingFrames into one Uint8Array */\n\treturn samplingFrames.reduce((accFrame: Uint8Array, frame) => {\n\t\tconst sampling = new Uint8Array(accFrame.length + frame.length);\n\t\tsampling.set(accFrame);\n\t\tsampling.set(frame, accFrame.length);\n\n\t\treturn sampling;\n\t}, new Uint8Array([]));\n}\n\n/* ----------------------------------------------Worker Processing Duties END---------------------------------------------------------- */\n\n/* ----------------------------------------------Worker Router START---------------------------------------------------------- */\n\nonmessage = ({ data: { job, params } }) => {\n\tswitch (job) {\n\t\tcase 'createGIF':\n\t\t\tconst { width, height } = params;\n\t\t\tconst { numericalRGBFrames, stringRGBFrames } = processFrames(_frameCollection, width, height);\n\t\t\tconst samplingFrame = getColorSamplingFrames(numericalRGBFrames);\n\t\t\tconst colorLookup: { [index: string]: number } = createColorTable(samplingFrame, width, height);\n\t\t\tconst gifData = generateGIF(stringRGBFrames, colorLookup);\n\t\t\tctx.postMessage(gifData);\n\t\t\tbreak;\n\t\tcase 'collectFrames':\n\t\t\tconst { frame }: { frame: ArrayBuffer } = params;\n\t\t\tcollectFrames(frame);\n\t\t\tbreak;\n\t}\n};\n\n/* ----------------------------------------------Worker Router END---------------------------------------------------------- */\n"]}